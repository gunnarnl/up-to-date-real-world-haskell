<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 12: Barcode Recognition</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 12: Barcode Recognition</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#a-little-bit-about-barcodes"><span
class="toc-section-number">1</span> A little bit about barcodes</a>
<ul>
<li><a href="#ean-13-encoding"><span
class="toc-section-number">1.1</span> EAN-13 encoding</a></li>
</ul></li>
<li><a href="#introducing-arrays"><span
class="toc-section-number">2</span> Introducing arrays</a>
<ul>
<li><a href="#arrays-and-laziness"><span
class="toc-section-number">2.1</span> Arrays and laziness</a></li>
<li><a href="#folding-over-arrays"><span
class="toc-section-number">2.2</span> Folding over arrays</a></li>
<li><a href="#modifying-array-elements"><span
class="toc-section-number">2.3</span> Modifying array elements</a></li>
<li><a href="#exercises"><span class="toc-section-number">2.4</span>
Exercises</a></li>
</ul></li>
<li><a href="#encoding-an-ean-13-barcode"><span
class="toc-section-number">3</span> Encoding an EAN-13 barcode</a></li>
<li><a href="#constraints-on-our-decoder"><span
class="toc-section-number">4</span> Constraints on our decoder</a></li>
<li><a href="#divide-and-conquer"><span
class="toc-section-number">5</span> Divide and conquer</a></li>
<li><a href="#turning-a-colour-image-into-something-tractable"><span
class="toc-section-number">6</span> Turning a colour image into
something tractable</a>
<ul>
<li><a href="#parsing-a-colour-image"><span
class="toc-section-number">6.1</span> Parsing a colour image</a></li>
<li><a href="#greyscale-conversion"><span
class="toc-section-number">6.2</span> Greyscale conversion</a></li>
<li><a href="#greyscale-to-binary-and-type-safety"><span
class="toc-section-number">6.3</span> Greyscale to binary, and type
safety</a></li>
</ul></li>
<li><a href="#what-have-we-done-to-our-image"><span
class="toc-section-number">7</span> What have we done to our
image?</a></li>
<li><a href="#finding-matching-digits"><span
class="toc-section-number">8</span> Finding matching digits</a>
<ul>
<li><a href="#run-length-encoding"><span
class="toc-section-number">8.1</span> Run length encoding</a></li>
<li><a href="#scaling-run-lengths-and-finding-approximate-matches"><span
class="toc-section-number">8.2</span> Scaling run lengths, and finding
approximate matches</a></li>
<li><a href="#list-comprehensions"><span
class="toc-section-number">8.3</span> List comprehensions</a></li>
<li><a href="#remembering-a-matchs-parity"><span
class="toc-section-number">8.4</span> Remembering a match's
parity</a></li>
<li><a href="#chunking-a-list"><span
class="toc-section-number">8.5</span> Chunking a list</a></li>
<li><a href="#generating-a-list-of-candidate-digits"><span
class="toc-section-number">8.6</span> Generating a list of candidate
digits</a></li>
</ul></li>
<li><a href="#life-without-arrays-or-hash-tables"><span
class="toc-section-number">9</span> Life without arrays or hash
tables</a>
<ul>
<li><a href="#a-forest-of-solutions"><span
class="toc-section-number">9.1</span> A forest of solutions</a></li>
<li><a href="#a-brief-introduction-to-maps"><span
class="toc-section-number">9.2</span> A brief introduction to
maps</a></li>
<li><a href="#further-reading"><span
class="toc-section-number">9.3</span> Further reading</a></li>
</ul></li>
<li><a href="#turning-digit-soup-into-an-answer"><span
class="toc-section-number">10</span> Turning digit soup into an
answer</a>
<ul>
<li><a href="#solving-for-check-digits-in-parallel"><span
class="toc-section-number">10.1</span> Solving for check digits in
parallel</a></li>
<li><a href="#completing-the-solution-map-with-the-first-digit"><span
class="toc-section-number">10.2</span> Completing the solution map with
the first digit</a></li>
<li><a href="#finding-the-correct-sequence"><span
class="toc-section-number">10.3</span> Finding the correct
sequence</a></li>
</ul></li>
<li><a href="#working-with-row-data"><span
class="toc-section-number">11</span> Working with row data</a></li>
<li><a href="#pulling-it-all-together"><span
class="toc-section-number">12</span> Pulling it all together</a></li>
<li><a href="#a-few-comments-on-development-style"><span
class="toc-section-number">13</span> A few comments on development
style</a></li>
<li><a href="#footnotes"><span class="toc-section-number">14</span>
Footnotes</a></li>
</ul>
</nav>
<p>In this chapter, we'll make use of the image parsing library we
developed in <a href="10-parsing-a-binary-data-format.org">Chapter 10,
<em>Code case study: parsing a binary data format</em></a> to build a
barcode recognition application. Given a picture of the back of a book
taken with a camera phone, we could use this to extract its ISBN
number.</p>
<h1 data-number="1" id="a-little-bit-about-barcodes"><span
class="header-section-number">1</span> A little bit about barcodes</h1>
<p>The vast majority of packaged and mass-produced consumer goods sold
have a barcode somewhere on them. Although there are dozens of barcode
systems used across a variety specialised domains, consumer products
typically use either UPC-A or EAN-13. UPC-A was developed in the United
States, while EAN-13 is European in origin.</p>
<p>EAN-13 was developed after UPC-A, and is a superset of UPC-A. (In
fact, UPC-A has been officially declared obsolete since 2005, though
it's still widely used within the United States.) Any software or
hardware that can understand EAN-13 barcodes will automatically handle
UPC-A barcodes. This neatly reduces our descriptive problem to one
standard.</p>
<p>As the name suggests, EAN-13 describes a 13-digit sequence, which is
broken into four groups.</p>
<ul>
<li>The first two digits describe the <em>number system</em>. This can
either indicate the nationality of the manufacturer, or describe one of
a few other categories, such as ISBN (book identifier) numbers.</li>
<li>The next five digits are a manufacturer ID, assigned by a country's
numbering authority.</li>
<li>The five digits that follow are a product ID, assigned by the
manufacturer. (Smaller manufacturers may have a longer manufacturer ID
and shorter product ID, but they still add up to ten digits.)</li>
<li>The last digit is a <em>check digit</em>, allowing a scanner to
validate the digit string it scans.</li>
</ul>
<p>The only way in which an EAN-13 barcode differs from a UPC-A barcode
is that the latter uses a single digit to represent its number system.
EAN-13 barcodes retain UPC-A compatibility by setting the first number
system digit to zero.</p>
<h2 data-number="1.1" id="ean-13-encoding"><span
class="header-section-number">1.1</span> EAN-13 encoding</h2>
<p>Before we worry about decoding an EAN-13 barcode, we need to
understand how they are encoded. The system used by EAN-13 is a little
involved. We start by computing the check digit, which is the last digit
of a string.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">checkDigit ::</span> (<span class="dt">Integral</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>checkDigit ds <span class="ot">=</span> <span class="dv">10</span> <span class="op">-</span> (<span class="fu">sum</span> products <span class="ot">`mod`</span> <span class="dv">10</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> products <span class="ot">=</span> mapEveryOther (<span class="op">*</span><span class="dv">3</span>) (<span class="fu">reverse</span> ds)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ot">mapEveryOther ::</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>mapEveryOther f <span class="ot">=</span> <span class="fu">zipWith</span> (<span class="op">$</span>) (<span class="fu">cycle</span> [f,<span class="fu">id</span>])</span></code></pre></div>
</div>
<p>This is one of those algorithms that is more easily understood via
the code than a verbal description. The computation proceeds from the
right of the string. Each successive digit is either multiplied by three
or left alone (the <code>cycle</code> function repeats its input list
infinitely). The check digit is the difference between their sum, modulo
ten, and the number ten.</p>
<p>A barcode is a series of fixed-width bars, where black represents a
binary "one" bit, and white a "zero". A run of the same digits thus
looks like a thicker bar.</p>
<p>The sequence of bits in a barcode is as follows.</p>
<ul>
<li>The leading guard sequence, encoded as 101.</li>
<li>A group of six digits, each seven bits wide.</li>
<li>Another guard sequence, encoded as 01010.</li>
<li>A group of six more digits.</li>
<li>The trailing guard sequence, encoded as 101.</li>
</ul>
<p>The digits in the left and right groups have separate encodings. On
the left, digits are encoded with parity bits. The parity bits encode
the 13th digit of the barcode.</p>
<h1 data-number="2" id="introducing-arrays"><span
class="header-section-number">2</span> Introducing arrays</h1>
<p>Before we continue, here are all of the imports that we will be using
in the remainder of this chapter.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Array</span> (<span class="dt">Array</span>(..), (!), bounds, elems, indices,</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>                   ixmap, listArray)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span> (digitToInt)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ix</span> (<span class="dt">Ix</span>(..))</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl&#39;, group, sort, sortBy, tails)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Maybe</span> (catMaybes, listToMaybe)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Ratio</span> (<span class="dt">Ratio</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Word</span> (<span class="dt">Word8</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Parse</span>                    <span class="co">-- from chapter 10</span></span></code></pre></div>
</div>
<p>The barcode encoding process can largely be table-driven, in which we
use small tables of bit patterns to decide how to encode each digit.
Haskell's bread-and-butter data types, lists and tuples, are not well
suited to use for tables whose elements may be accessed randomly. A list
has to be traversed linearly to reach the /k/th element. A tuple doesn't
have this problem, but Haskell's type system makes it difficult to write
a function that takes a tuple and an element offset and returns the
element at that offset within the tuple. (We'll explore why in the
exercises below.)</p>
<p>The usual data type for constant-time random access is of course the
array. Haskell provides several array data types. We'll thus represent
our encoding tables as arrays of strings.</p>
<p>The simplest array type is in the <code>Data.Array</code> module,
which we're using here. This presents arrays that can contain values of
any Haskell type. Like other common Haskell types, these arrays are
immutable. An immutable array is populated with values just once, when
it is created. Its contents cannot subsequently be modified. (The
standard libraries also provide other array types, some of which are
mutable, but we won't cover those for a while.)</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>leftOddList <span class="ot">=</span> [<span class="st">&quot;0001101&quot;</span>, <span class="st">&quot;0011001&quot;</span>, <span class="st">&quot;0010011&quot;</span>, <span class="st">&quot;0111101&quot;</span>, <span class="st">&quot;0100011&quot;</span>,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>               <span class="st">&quot;0110001&quot;</span>, <span class="st">&quot;0101111&quot;</span>, <span class="st">&quot;0111011&quot;</span>, <span class="st">&quot;0110111&quot;</span>, <span class="st">&quot;0001011&quot;</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>rightList <span class="ot">=</span> <span class="fu">map</span> complement <span class="op">&lt;$&gt;</span> leftOddList</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> complement <span class="ch">&#39;0&#39;</span> <span class="ot">=</span> <span class="ch">&#39;1&#39;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>          complement <span class="ch">&#39;1&#39;</span> <span class="ot">=</span> <span class="ch">&#39;0&#39;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>leftEvenList <span class="ot">=</span> <span class="fu">map</span> <span class="fu">reverse</span> rightList</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>parityList <span class="ot">=</span> [<span class="st">&quot;111111&quot;</span>, <span class="st">&quot;110100&quot;</span>, <span class="st">&quot;110010&quot;</span>, <span class="st">&quot;110001&quot;</span>, <span class="st">&quot;101100&quot;</span>,</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>              <span class="st">&quot;100110&quot;</span>, <span class="st">&quot;100011&quot;</span>, <span class="st">&quot;101010&quot;</span>, <span class="st">&quot;101001&quot;</span>, <span class="st">&quot;100101&quot;</span>]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="ot">listToArray ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Array</span> <span class="dt">Int</span> a</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>listToArray xs <span class="ot">=</span> listArray (<span class="dv">0</span>,l<span class="op">-</span><span class="dv">1</span>) xs</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> l <span class="ot">=</span> <span class="fu">length</span> xs</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>leftOddCodes, leftEvenCodes, rightCodes,<span class="ot"> parityCodes ::</span> <span class="dt">Array</span> <span class="dt">Int</span> <span class="dt">String</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>leftOddCodes <span class="ot">=</span> listToArray leftOddList</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>leftEvenCodes <span class="ot">=</span> listToArray leftEvenList</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>rightCodes <span class="ot">=</span> listToArray rightList</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>parityCodes <span class="ot">=</span> listToArray parityList</span></code></pre></div>
</div>
<p>The <code>Data.Array</code> module's <code>listArray</code> function
populates an array from a list. It takes as its first parameter the
bounds of the array to create; the second is the values with which to
populate it.</p>
<p>An unusual feature of the <code>Array</code> type is that its type is
parameterised over both the data it contains and the index type. For
example, the type of a one-dimensional array of <code>String</code> is
<code>Array Int String</code>, but a two-dimensional array would have
the type <code>Array (Int, Int) String</code>.</p>
<pre class="screen"><code>ghci&gt; :m +Data.Array
ghci&gt; :type listArray
listArray :: Ix i =&gt; (i, i) -&gt; [e] -&gt; Array i e
</code></pre>
<p>We can construct an array easily.</p>
<pre class="screen"><code>ghci&gt; listArray (0,2) &quot;foo&quot;
array (0,2) [(0,&#39;f&#39;),(1,&#39;o&#39;),(2,&#39;o&#39;)]
</code></pre>
<p>Notice that we have to specify the lower and upper bounds of the
array. These bounds are inclusive, so an array from 0 to 2 has elements
0, 1, and 2.</p>
<pre class="screen"><code>ghci&gt; listArray (0,3) [True,False,False,True,False]
array (0,3) [(0,True),(1,False),(2,False),(3,True)]
ghci&gt; listArray (0,10) &quot;too short&quot;
array (0,10) [(0,&#39;t&#39;),(1,&#39;o&#39;),(2,&#39;o&#39;),(3,&#39; &#39;),(4,&#39;s&#39;),(5,&#39;h&#39;),
(6,&#39;o&#39;),(7,&#39;r&#39;),(8,&#39;t&#39;),(9,*** Exception: (Array.!): undefined
array element
</code></pre>
<p>Once an array is constructed, we can use the <code>(!)</code>
operator to access its elements by index.</p>
<pre class="screen"><code>ghci&gt; a = listArray (0,14) [&#39;a&#39;..]
ghci&gt; a ! 2
&#39;c&#39;
ghci&gt; a ! 100
*** Exception: Ix{Integer}.index: Index (100) out of range ((0,14))
</code></pre>
<p>Since the array construction function lets us specify the bounds of
an array, we don't have to use the zero-based array indexing familiar to
C programmers. We can choose whatever bounds are convenient for our
purposes.</p>
<pre class="screen"><code>ghci&gt; a = listArray (-9,5) [&#39;a&#39;..]
ghci&gt; a ! (-2)
&#39;h&#39;
</code></pre>
<p>The index type can be any member of the <code>Ix</code> type. This
lets us use, for example, <code>Char</code> as the index type.</p>
<pre class="screen"><code>ghci&gt; a = listArray (&#39;a&#39;, &#39;h&#39;) [97..]
ghci&gt; a ! &#39;e&#39;
101
</code></pre>
<p>To create a higher-dimensioned array, we use a tuple of
<code>Ix</code> instances as the index type. The prelude makes tuples of
up to five elements members of the <code>Ix</code> class. To illustrate,
here's a small three-dimensional array.</p>
<pre class="screen"><code>ghci&gt; a = listArray ((0,0,0), (9,9,9)) [0..]
ghci&gt; a ! (4,3,7)
437
</code></pre>
<h2 data-number="2.1" id="arrays-and-laziness"><span
class="header-section-number">2.1</span> Arrays and laziness</h2>
<p>The list that we use to populate the array must contain at least as
many elements as are in the array. If we do not provide enough elements,
we'll get an error at runtime. When the error will occur depends on the
nature of the array.</p>
<p>Here, we are using an array type that is non-strict in its elements.
If we provide a list of three values to an array that we specify as
containing more than three elements, the remaining elements will
undefined. We will not get an error unless we access an element beyond
the third.</p>
<pre class="screen"><code>ghci&gt; a = listArray (0,5) &quot;bar&quot;
ghci&gt; a ! 2
&#39;r&#39;
ghci&gt; a ! 4
*** Exception: (Array.!): undefined array element
</code></pre>
<p>Haskell also provides strict arrays, which behave differently. We
will discuss the tradeoffs between the two kinds of array much later, in
<a
href="26-building-a-bloom-filter.org::*Unboxing, lifting, and bottom">the
section called "Unboxing, lifting, and bottom"</a></p>
<h2 data-number="2.2" id="folding-over-arrays"><span
class="header-section-number">2.2</span> Folding over arrays</h2>
<p>The <code>bounds</code> function returns a tuple describing the
bounds that we used to create the array. The <code>indices</code>
function returns a list of every index. We can use these to define some
useful folds, since the <code>Data.Array</code> module doesn't define
any fold functions itself.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Strict left fold, similar to foldl&#39; on lists.</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="ot">foldA ::</span> <span class="dt">Ix</span> k <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Array</span> k b <span class="ot">-&gt;</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>foldA f s a <span class="ot">=</span> go s (indices a)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go s (j<span class="op">:</span>js) <span class="ot">=</span> <span class="kw">let</span> s&#39; <span class="ot">=</span> f s (a <span class="op">!</span> j)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">in</span> s&#39; <span class="ot">`seq`</span> go s&#39; js</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>          go s _ <span class="ot">=</span> s</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Strict left fold using the first element of the array as its</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- starting value, similar to foldl1 on lists.</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="ot">foldA1 ::</span> <span class="dt">Ix</span> k <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Array</span> k a <span class="ot">-&gt;</span> a</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>foldA1 f a <span class="ot">=</span> foldA f (a <span class="op">!</span> <span class="fu">fst</span> (bounds a)) a</span></code></pre></div>
</div>
<p>You might wonder why the array modules don't already provide such
useful things as folding functions. There are some obvious
correspondences between a one-dimensional array and a list. For
instance, there are only two natural ways in which we can fold
sequentially: left-to-right and right-to-left. Additionally, we can only
fold over one element at a time.</p>
<p>This does not translate even to two-dimensional arrays. First of all,
there are several kinds of fold that make sense. We might still want to
fold over single elements, but we now have the possibility of folding
over rows or columns, too. On top of this, for element-at-a-time
folding, there are no longer just two sequences for traversal.</p>
<p>In other words, for two-dimensional arrays, there are enough
permutations of possibly useful behaviour that there aren't many
compelling reasons to choose a handful for a standard library. This
problem is only compounded for higher dimensions, so it's best to let
developers write folds that suit the needs of their applications. As we
can see from our examples above, this is not hard to do.</p>
<h2 data-number="2.3" id="modifying-array-elements"><span
class="header-section-number">2.3</span> Modifying array elements</h2>
<p>While there exist "modification" functions for immutable arrays, they
are not very practical. For example, the <code>accum</code> function
takes an array and a list of <code>(index, value)</code> pairs, and
returns a new array with the values at the given indices replaced.</p>
<p>Since arrays are immutable, modifying even one element requires
copying the entire array. This quickly becomes prohibitively expensive
on arrays of even modest size.</p>
<p>Another array type, <code>DiffArray</code> in the
<code>Data.Array.Diff</code> module, attempts to offset the cost of
small modifications by storing deltas between successive versions of an
array. Unfortunately, it is not implemented efficiently at the time we
are writing this book, and is currently too slow to be of practical
use.</p>
<div class="NOTE">
<p>Don't lose hope</p>
<p>It <em>is</em> in fact possible to modify an array efficiently in
Haskell, using the <code>ST</code> monad. This is a subject that we will
return to later, in <a href="26-building-a-bloom-filter.org">Chapter 26,
<em>Advanced library design: building a Bloom filter</em></a>.</p>
</div>
<h2 data-number="2.4" id="exercises"><span
class="header-section-number">2.4</span> Exercises</h2>
<p>Let's briefly explore the suitability of tuples as stand-ins for
arrays.</p>
<ol>
<li>Write a function that takes two arguments: a four-element tuple, and
an integer. With an integer argument of zero, it should return the
leftmost element of the tuple. With an argument of one, it should return
the next element. And so on. What restrictions do you have to put on the
types of the arguments in order to write a function that type-checks
correctly?</li>
<li>Write a similar function that takes a six-tuple as its first
argument.</li>
<li>Try refactoring the two functions to share any common code you can
identify. How much shared code are you able to you find?</li>
</ol>
<h1 data-number="3" id="encoding-an-ean-13-barcode"><span
class="header-section-number">3</span> Encoding an EAN-13 barcode</h1>
<p>Even though our goal is to <em>decode</em> a barcode, it's useful to
have an encoder for reference. This will allow us to, for example,
ensure that our code is correct by checking that the output of
<code>decode . encode</code> the same as its input.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">encodeEAN13 ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>encodeEAN13 <span class="ot">=</span> <span class="fu">concat</span> <span class="op">.</span> encodeDigits <span class="op">.</span> <span class="fu">map</span> <span class="fu">digitToInt</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- | This function computes the check digit; don&#39;t pass one in.</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="ot">encodeDigits ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> [<span class="dt">String</span>]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>encodeDigits s<span class="op">@</span>(first<span class="op">:</span>rest) <span class="ot">=</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    outerGuard <span class="op">:</span> lefties <span class="op">++</span> centerGuard <span class="op">:</span> righties <span class="op">++</span> [outerGuard]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> (left, right) <span class="ot">=</span> <span class="fu">splitAt</span> <span class="dv">6</span> rest</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        lefties <span class="ot">=</span> <span class="fu">zipWith</span> leftEncode (parityCodes <span class="op">!</span> first) left</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        righties <span class="ot">=</span> <span class="fu">map</span> rightEncode (right <span class="op">++</span> [checkDigit s])</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="ot">leftEncode ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>leftEncode <span class="ch">&#39;1&#39;</span> <span class="ot">=</span> (leftOddCodes <span class="op">!</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>leftEncode <span class="ch">&#39;0&#39;</span> <span class="ot">=</span> (leftEvenCodes <span class="op">!</span>)</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="ot">rightEncode ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>rightEncode <span class="ot">=</span> (rightCodes <span class="op">!</span>)</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>outerGuard <span class="ot">=</span> <span class="st">&quot;101&quot;</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>centerGuard <span class="ot">=</span> <span class="st">&quot;01010&quot;</span></span></code></pre></div>
</div>
<p>The string to encode is twelve digits long, with
<code>encodeDigits</code> adding a thirteenth check digit.</p>
<p>The barcode is encoded as two groups of six digits, with a guard
sequence in the middle and "outside" sequences on either side. But if we
have two groups of six digits, what happened to the missing digit?</p>
<p>Each digit in the left group is encoded using either odd or even
parity, with the parity chosen based on the bits of the first digit in
the string. If a bit of the first digit is zero, the corresponding digit
in the left group is encoded with even parity. A one bit causes the
digit to be encoded with odd parity. This encoding is an elegant hack,
chosen to make EAN-13 barcodes backwards compatible with the older UPC-A
standard.</p>
<h1 data-number="4" id="constraints-on-our-decoder"><span
class="header-section-number">4</span> Constraints on our decoder</h1>
<p>Before we talk about decoding, let's set a few practical limits on
what kinds of barcode image we can work with.</p>
<p>Phone cameras and webcams generally output JPEG images, but writing a
JPEG decoder would take us several chapters. We'll simplify our parsing
problem by handling the netpbm file format. We will use the parsing
combinators we developed earlier, in <a
href="10-parsing-a-binary-data-format.org">Chapter 10, <em>Code case
study: parsing a binary data format</em></a>.</p>
<p>We'd like to deal with real images from the kinds of cheap,
fixed-focus cameras that come with low-end cell phones. These images
tend to be out of focus, noisy, low in contrast, and of poor resolution.
Fortunately, it's not hard to write code that can handle noisy,
defocused VGA-resolution (640x480) images with terrible contrast ratios.
We've verified that the code in this chapter captures barcodes from real
books, using pictures taken by authentically mediocre cameras.</p>
<p>We will avoid any image processing heroics, because that's another
chapter-consuming subject. We won't correct perspective. Neither will we
sharpen images taken from too near to the subject, which causes narrow
bars to fade out; or from too far, which causes adjacent bars to blur
together.</p>
<p><span class="spurious-link"
target="figs/ch12-bad-angled.jpg"><em>figs/ch12-bad-angled.jpg</em></span></p>
<p><span class="spurious-link"
target="figs/ch12-bad-too-near.jpg"><em>figs/ch12-bad-too-near.jpg</em></span></p>
<p><span class="spurious-link"
target="figs/ch12-bad-too-far.jpg"><em>figs/ch12-bad-too-far.jpg</em></span></p>
<h1 data-number="5" id="divide-and-conquer"><span
class="header-section-number">5</span> Divide and conquer</h1>
<p>Our task is to take a camera image and extract a valid barcode from
it. Given such a nonspecific description, it can be hard to see how to
make progress. However, we can break the big problem into a series of
subproblems, each of which is self-contained and more tractable.</p>
<ul>
<li>Convert colour data into a form we can easily work with.</li>
<li>Sample a single scan line from the image, and extract a set of
guesses as to what the encoded digits in this line could be.</li>
<li>From the guesses, create a list of valid decodings.</li>
</ul>
<p>Many of these subproblems can be further divided, as we'll see.</p>
<p>You might wonder how closely this approach of subdivision mirrors the
actual work we did when writing the code that we present in this
chapter. The answer is that we're far from image processing gurus, and
when we started on this chapter we didn't know exactly what our solution
was going to look like.</p>
<p>We made some early educated guesses as to what a reasonable solution
might look like, and came up with the list of subtasks above. We were
then able to start tackling those parts that we knew how to solve, using
our spare time to think about the bits that we had no prior experience
with. We certainly didn't have a pre-existing algorithm or master plan
in mind.</p>
<p>Dividing the problem up like this helped us in two ways. By making
progress on familiar ground, we had the psychological advantage of
starting to solve the problem, even when we didn't really know where we
were going. And as we started to work on a particular subproblem, we
found ourselves able to further subdivide it into tasks of varying
familiarity. We continued to focus on easier components, deferring ones
we hadn't thought about in enough detail yet, and jumping from one
element of the master list above to another. Eventually, we ran out of
problems that were both unfamiliar and unsolved, and we had a complete
idea of our eventual solution.</p>
<h1 data-number="6"
id="turning-a-colour-image-into-something-tractable"><span
class="header-section-number">6</span> Turning a colour image into
something tractable</h1>
<p>Since we want to work with barcodes, which are sequences of black and
white stripes, and we want to write a simple decoder, an easy
representation to work with will be a monochrome image, in which each
pixel is either black or white.</p>
<h2 data-number="6.1" id="parsing-a-colour-image"><span
class="header-section-number">6.1</span> Parsing a colour image</h2>
<p>As we mentioned earlier, we'll work with netpbm images. The netpbm
colour image format is only slightly more complicated than the greyscale
image format that we parsed in <a
href="10-parsing-a-binary-data-format.org">Chapter 10, <em>Code case
study: parsing a binary data format</em></a>. The identifying string in
a header is "P6", with the rest of the header layout identical to the
greyscale format. In the body of an image, each pixel is represented as
three bytes, one each for red, green and blue.</p>
<p>We'll represent the image data as a two-dimensional array of pixels.
We're using arrays here purely to gain experience with them. For this
application, we could just as well use a list of lists. The only
advantage of an array here is slight: we can efficiently extract a
row.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pixel</span> <span class="ot">=</span> <span class="dt">Word8</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RGB</span> <span class="ot">=</span> (<span class="dt">Pixel</span>, <span class="dt">Pixel</span>, <span class="dt">Pixel</span>)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Pixmap</span> <span class="ot">=</span> <span class="dt">Array</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="dt">RGB</span></span></code></pre></div>
</div>
<p>We provide a few type synonyms to make our type signatures more
readable.</p>
<p>Since Haskell gives us considerable freedom in how we lay out an
array, we must choose a representation. We'll play safe and follow a
popular convention: indices begin at zero. We don't need to store the
dimensions of the image explicitly, since we can extract them using the
<code>bounds</code> function.</p>
<p>The actual parser is mercifully short, thanks to the combinators we
developed in <a href="10-parsing-a-binary-data-format.org">Chapter 10,
<em>Code case study: parsing a binary data format</em></a>.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseRawPPM ::</span> <span class="dt">Parse</span> <span class="dt">Pixmap</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>parseRawPPM <span class="ot">=</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    parseWhileWith w2c (<span class="op">/=</span> <span class="ch">&#39;\n&#39;</span>) <span class="op">==&gt;</span> \header <span class="ot">-&gt;</span> skipSpaces <span class="op">==&gt;&amp;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    assert (header <span class="op">==</span> <span class="st">&quot;P6&quot;</span>) <span class="st">&quot;invalid raw header&quot;</span> <span class="op">==&gt;&amp;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    parseNat <span class="op">==&gt;</span> \width <span class="ot">-&gt;</span> skipSpaces <span class="op">==&gt;&amp;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    parseNat <span class="op">==&gt;</span> \height <span class="ot">-&gt;</span> skipSpaces <span class="op">==&gt;&amp;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    parseNat <span class="op">==&gt;</span> \maxValue <span class="ot">-&gt;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    assert (maxValue <span class="op">==</span> <span class="dv">255</span>) <span class="st">&quot;max value out of spec&quot;</span> <span class="op">==&gt;&amp;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    parseByte <span class="op">==&gt;&amp;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    parseTimes (width <span class="op">*</span> height) parseRGB <span class="op">==&gt;</span> \pxs <span class="ot">-&gt;</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    identity (listArray ((<span class="dv">0</span>,<span class="dv">0</span>),(width<span class="op">-</span><span class="dv">1</span>,height<span class="op">-</span><span class="dv">1</span>)) pxs)</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="ot">parseRGB ::</span> <span class="dt">Parse</span> <span class="dt">RGB</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>parseRGB <span class="ot">=</span> parseByte <span class="op">==&gt;</span> \r <span class="ot">-&gt;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>           parseByte <span class="op">==&gt;</span> \g <span class="ot">-&gt;</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>           parseByte <span class="op">==&gt;</span> \b <span class="ot">-&gt;</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>           identity (r,g,b)</span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="ot">parseTimes ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Parse</span> a <span class="ot">-&gt;</span> <span class="dt">Parse</span> [a]</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>parseTimes <span class="dv">0</span> _ <span class="ot">=</span> identity []</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a>parseTimes n p <span class="ot">=</span> p <span class="op">==&gt;</span> \x <span class="ot">-&gt;</span> (x<span class="op">:</span>) <span class="op">&lt;$&gt;</span> parseTimes (n<span class="op">-</span><span class="dv">1</span>) p</span></code></pre></div>
</div>
<p>The only function of note above is <code>parseTimes</code>, which
calls another parser a given number of times, building up a list of
results.</p>
<h2 data-number="6.2" id="greyscale-conversion"><span
class="header-section-number">6.2</span> Greyscale conversion</h2>
<p>Now that we have a colour image in hand, we need to convert the
colour data into monochrome. An intermediate step is to convert the data
to greyscale. There's a simple, widely used formula<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> for
converting an RGB image into a greyscale image, based on the perceived
brightness of each colour channel.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ot">luminance ::</span> (<span class="dt">Pixel</span>, <span class="dt">Pixel</span>, <span class="dt">Pixel</span>) <span class="ot">-&gt;</span> <span class="dt">Pixel</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>luminance (r,g,b) <span class="ot">=</span> <span class="fu">round</span> (r&#39; <span class="op">*</span> <span class="fl">0.30</span> <span class="op">+</span> g&#39; <span class="op">*</span> <span class="fl">0.59</span> <span class="op">+</span> b&#39; <span class="op">*</span> <span class="fl">0.11</span>)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> r&#39; <span class="ot">=</span> <span class="fu">fromIntegral</span> r</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>          g&#39; <span class="ot">=</span> <span class="fu">fromIntegral</span> g</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>          b&#39; <span class="ot">=</span> <span class="fu">fromIntegral</span> b</span></code></pre></div>
</div>
<p>Haskell arrays are members of the <code>Functor</code> type class, so
we can simply use <code>fmap</code> to turn an entire image, or a single
scanline, from colour into greyscale.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Greymap</span> <span class="ot">=</span> <span class="dt">Array</span> (<span class="dt">Int</span>,<span class="dt">Int</span>) <span class="dt">Pixel</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="ot">pixmapToGreymap ::</span> <span class="dt">Pixmap</span> <span class="ot">-&gt;</span> <span class="dt">Greymap</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>pixmapToGreymap <span class="ot">=</span> <span class="fu">fmap</span> luminance</span></code></pre></div>
</div>
<p>This <code>pixmapToGreymap</code> function is just for illustration.
Since we'll only be checking a few rows of an image for possible
barcodes, there's no reason to do the extra work of converting data
we'll never subsequently use.</p>
<h2 data-number="6.3" id="greyscale-to-binary-and-type-safety"><span
class="header-section-number">6.3</span> Greyscale to binary, and type
safety</h2>
<p>Our next subproblem is to convert the greyscale image into a
two-valued image, where each pixel is either on or off.</p>
<p>In an image processing application, where we're juggling lots of
numbers, it would be easy to reuse the same numeric type for several
different purposes. For example, we could use the <code>Pixel</code>
type to represent on/off states, using the convention that the digit one
represents a bit that's "on", and zero "off".</p>
<p>However, reusing types for multiple purposes in this way quickly
leads to potential confusion. To see whether a particular
<code>Pixel</code> is a number or an on/off value, we can no longer
simply glance at a type signature. We could easily use a value
containing "the wrong kind of number" in some context, and the compiler
won't catch it because the types work out.</p>
<p>We could try to work around this by introducing a type alias. In the
same way that we declared <code>Pixel</code> to be a synonym of
<code>Word8</code>, we could declare a <code>Bit</code> type as a
synonym of <code>Pixel</code>. While this might help readability, type
synonyms still don't make the compiler do any useful work on our
behalf.</p>
<p>The compiler would treat <code>Pixel</code> and <code>Bit</code> as
exactly the same type, so it could not catch a mistake such as using a
<code>Pixel</code> value of 253 in a function that expects
<code>Bit</code> values of zero or one.</p>
<p>If we define the monochrome type ourselves, the compiler will prevent
us from accidentally mixing our types up like this.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Bit</span> <span class="ot">=</span> <span class="dt">Zero</span> <span class="op">|</span> <span class="dt">One</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>           <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="ot">threshold ::</span> (<span class="dt">Ix</span> k, <span class="dt">Integral</span> a) <span class="ot">=&gt;</span> <span class="dt">Double</span> <span class="ot">-&gt;</span> <span class="dt">Array</span> k a <span class="ot">-&gt;</span> <span class="dt">Array</span> k <span class="dt">Bit</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>threshold n a <span class="ot">=</span> binary <span class="op">&lt;$&gt;</span> a</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> binary i <span class="op">|</span> i <span class="op">&lt;</span> pivot  <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="fu">otherwise</span>  <span class="ot">=</span> <span class="dt">One</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>          pivot    <span class="ot">=</span> <span class="fu">round</span> <span class="op">$</span> least <span class="op">+</span> (greatest <span class="op">-</span> least) <span class="op">*</span> n</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>          least    <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> choose (<span class="op">&lt;</span>) a</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>          greatest <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> choose (<span class="op">&gt;</span>) a</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>          choose f <span class="ot">=</span> foldA1 <span class="op">$</span> \x y <span class="ot">-&gt;</span> <span class="kw">if</span> f x y <span class="kw">then</span> x <span class="kw">else</span> y</span></code></pre></div>
</div>
<p>Our <code>threshold</code> function computes the minimum and maximum
values in its input array. It takes these and a threshold valued between
zero and one, and computes a "pivot" value. Then for each value in the
array, if that value is less than the pivot, the result is
<code>Zero</code>, otherwise <code>One</code>. Notice that we use one of
the folding functions that we wrote in <a
href="12-barcode-recognition.org::*Folding over arrays">the section
called "Folding over arrays"</a></p>
<h1 data-number="7" id="what-have-we-done-to-our-image"><span
class="header-section-number">7</span> What have we done to our
image?</h1>
<p>Let's step back for a moment and consider what we've done to our
image when we converted it from colour to monochrome. Here's an image
captured from a VGA-resolution camera. All we've done is crop it down to
the barcode.</p>
<p><img src="ch12-barcode-photo.jpg" /></p>
<p>The encoded digit string, 9780132114677, is printed below the
barcode. The left group encodes the digits 780132, with 9 encoded in
their parity. The right group encodes the digits 114677, where the final
7 is the check digit. Here's a clean encoding of this barcode, from one
of the many web sites that offer barcode image generation for free.</p>
<p><img src="ch12-barcode-generated.png" /></p>
<p>We've chosen a row from the captured image, and stretched it out
vertically to make it easier to see. We've superimposed this on top of
the perfect image, and stretched it out so that the two are aligned.</p>
<p><img src="ch12-barcode-example.png" /></p>
<p>The luminance-converted row from the photo is in the dark grey band.
It is low in contrast and poor in quality, with plenty of blurring and
noise. The paler band is the same row with the contrast adjusted.</p>
<p>Somewhat below these two bands is another: this shows the effect of
thresholding the luminance-converted row. Notice that some bars have
gotten thicker, others thinner, and many bars have moved a little to the
left or right.</p>
<p>Clearly, any attempt to find exact matches in an image with problems
like these is not going to succeed very often. We must write code that's
robust in the face of bars that are too thick, too thin, or not exactly
where they're supposed to be. The widths of our bars will depend on how
far our book was from the camera, so we can't make any assumptions about
widths, either.</p>
<h1 data-number="8" id="finding-matching-digits"><span
class="header-section-number">8</span> Finding matching digits</h1>
<p>Our first problem is to find the digits that <em>might</em> be
encoded at a given position. For the next while, we'll make a few
simplifying assumptions. The first is that we're working with a single
row. The second is that we know exactly where in a row the left edge of
a barcode begins.</p>
<h2 data-number="8.1" id="run-length-encoding"><span
class="header-section-number">8.1</span> Run length encoding</h2>
<p>How can we overcome the problem of not even knowing how thick our
bars are? The answer is to run length encode our image data.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Run</span> <span class="ot">=</span> <span class="dt">Int</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RunLength</span> a <span class="ot">=</span> [(<span class="dt">Run</span>, a)]</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="ot">runLength ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">RunLength</span> a</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>runLength <span class="ot">=</span> <span class="fu">map</span> rle <span class="op">.</span> <span class="fu">group</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> rle xs <span class="ot">=</span> (<span class="fu">length</span> xs, <span class="fu">head</span> xs)</span></code></pre></div>
</div>
<p>The <code>group</code> function takes sequences of identical elements
in a list, and groups them into sublists.</p>
<pre class="screen"><code>ghci&gt; group [1,1,2,3,3,3,3]
[[1,1],[2],[3,3,3,3]]
</code></pre>
<p>Our <code>runLength</code> function represents each group as a pair
of its length and first element.</p>
<pre class="screen"><code>ghci&gt; :l Barcode.hs
[1 of 3] Compiling PNM              ( PNM.hs, interpreted )
[2 of 3] Compiling Parse            ( Parse.hs, interpreted )
[3 of 3] Compiling Main             ( Barcode.hs, interpreted )
Ok, three modules loaded.
ghci&gt; bits = [0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,1,1,1,0,0,0,0]
ghci&gt; runLength bits
[(2,0),(2,1),(2,0),(2,1),(6,0),(4,1),(4,0)]
</code></pre>
<p>Since the data we're run length encoding are just ones and zeros, the
encoded numbers will simply alternate between one and zero. We can throw
the encoded values away without losing any useful information, keeping
only the length of each run.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runLengths ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Run</span>]</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>runLengths <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span> <span class="op">.</span> runLength</span></code></pre></div>
</div>
<pre class="screen"><code>ghci&gt; runLengths bits
[2,2,2,2,6,4,4]
</code></pre>
<p>The bit patterns above aren't random; they're the left outer guard
and first encoded digit of a row from our captured image. If we drop the
guard bars, we're left with the run lengths <code>[2,6,4,4]</code>. How
do we find matches for these in the encoding tables we wrote in <a
href="12-barcode-recognition.org::*Introducing arrays">the section
called "Introducing arrays"</a></p>
<h2 data-number="8.2"
id="scaling-run-lengths-and-finding-approximate-matches"><span
class="header-section-number">8.2</span> Scaling run lengths, and
finding approximate matches</h2>
<p>One possible approach is to scale the run lengths so that they sum to
one. We'll use the <code>Ratio Int</code> type instead of the usual
<code>Double</code> to manage these scaled values, as
<code>Ratio~s print out more
readably in ~ghci</code>. This makes interactive debugging and
development much easier.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Score</span> <span class="ot">=</span> <span class="dt">Ratio</span> <span class="dt">Int</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="ot">scaleToOne ::</span> [<span class="dt">Run</span>] <span class="ot">-&gt;</span> [<span class="dt">Score</span>]</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>scaleToOne xs <span class="ot">=</span> <span class="fu">map</span> divide xs</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> divide d <span class="ot">=</span> <span class="fu">fromIntegral</span> d <span class="op">/</span> divisor</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>          divisor <span class="ot">=</span> <span class="fu">fromIntegral</span> (<span class="fu">sum</span> xs)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- A more compact alternative that &quot;knows&quot; we&#39;re using Ratio Int:</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="co">-- scaleToOne xs = map (% sum xs) xs</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ScoreTable</span> <span class="ot">=</span> [[<span class="dt">Score</span>]]</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;SRL&quot; means &quot;scaled run length&quot;.</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a><span class="ot">asSRL ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> <span class="dt">ScoreTable</span></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>asSRL <span class="ot">=</span> <span class="fu">map</span> (scaleToOne <span class="op">.</span> runLengths)</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>leftOddSRL <span class="ot">=</span> asSRL leftOddList</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>leftEvenSRL <span class="ot">=</span> asSRL leftEvenList</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>rightSRL <span class="ot">=</span> asSRL rightList</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>paritySRL <span class="ot">=</span> asSRL parityList</span></code></pre></div>
</div>
<p>We use the <code>Score</code> type synonym so that most of our code
won't have to care what the underlying type is. Once we're done
developing our code and poking around with <code>ghci</code>, we could,
if we wish, go back and turn the <code>Score</code> type synonym into
~Double~s, without changing any code.</p>
<p>We can use <code>scaleToOne</code> to scale a sequence of digits that
we're searching for. We've now corrected for variations in bar widths
due to distance, as there should be a pretty close match between an
entry in a scaled run length encoding table and a run length sequence
pulled from an image.</p>
<p>The next question is how we turn the intuitive idea of "pretty close"
into a measure of "close enough". Given two scaled run length sequences,
we can calculate an approximate "distance" between them as follows.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">distance ::</span> [<span class="dt">Score</span>] <span class="ot">-&gt;</span> [<span class="dt">Score</span>] <span class="ot">-&gt;</span> <span class="dt">Score</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>distance a b <span class="ot">=</span> <span class="fu">sum</span> <span class="op">.</span> <span class="fu">map</span> <span class="fu">abs</span> <span class="op">$</span> <span class="fu">zipWith</span> (<span class="op">-</span>) a b</span></code></pre></div>
</div>
<p>An exact match will give a distance of zero, with weaker matches
resulting in larger distances.</p>
<pre class="screen"><code>ghci&gt; group = scaleToOne [2,6,4,4]
ghci&gt; distance group (head leftEvenSRL)
13 % 28
ghci&gt; distance group (head leftOddSRL)
17 % 28
</code></pre>
<p>Given a scaled run length table, we choose the best few matches in
that table for a given input sequence.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Digit</span> <span class="ot">=</span> <span class="dt">Word8</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="ot">bestScores ::</span> <span class="dt">ScoreTable</span> <span class="ot">-&gt;</span> [<span class="dt">Run</span>] <span class="ot">-&gt;</span> [(<span class="dt">Score</span>, <span class="dt">Digit</span>)]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>bestScores srl ps <span class="ot">=</span> <span class="fu">take</span> <span class="dv">3</span> <span class="op">.</span> <span class="fu">sort</span> <span class="op">$</span> scores</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> scores <span class="ot">=</span> <span class="fu">zip</span> [distance d (scaleToOne ps) <span class="op">|</span> d <span class="ot">&lt;-</span> srl] digits</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a>          digits <span class="ot">=</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">9</span>]</span></code></pre></div>
</div>
<h2 data-number="8.3" id="list-comprehensions"><span
class="header-section-number">8.3</span> List comprehensions</h2>
<p>The new notation that we introduced in the previous example is an
example of a <em>list comprehension</em>, which creates a list from one
or more other lists.</p>
<pre class="screen"><code>ghci&gt; [ (a,b) | a &lt;- [1,2], b &lt;- &quot;abc&quot; ]
[(1,&#39;a&#39;),(1,&#39;b&#39;),(1,&#39;c&#39;),(2,&#39;a&#39;),(2,&#39;b&#39;),(2,&#39;c&#39;)]
</code></pre>
<p>The expression on the left of the vertical bar is evaluated for each
combination of <em>generator expressions</em> on the right. A generator
expression binds a variable on the left of a <code>&lt;-</code> to an
element of the list on the right. As the example above shows, the
combinations of generators are evaluated in depth first order: for the
first element of the first list, we evaluate every element of the
second, and so on.</p>
<p>In addition to generators, we can also specify guards on the right of
a list comprehension. A guard is a <code>Bool</code> expression. If it
evaluates to <code>False</code>, that element is skipped over.</p>
<pre class="screen"><code>ghci&gt; [ (a,b) | a &lt;- [1..6], b &lt;- [5..7], even (a + b ^ 2) ]
[(1,5),(1,7),(2,6),(3,5),(3,7),(4,6),(5,5),(5,7),(6,6)]
</code></pre>
<p>We can also bind local variables using a <code>let</code>
expression.</p>
<pre class="screen"><code>ghci&gt; vowel = (`elem` &quot;aeiou&quot;)
ghci&gt; [ x | a &lt;- &quot;etaoin&quot;, b &lt;- &quot;shrdlu&quot;, let x = [a,b], all vowel x ]
[&quot;eu&quot;,&quot;au&quot;,&quot;ou&quot;,&quot;iu&quot;]
</code></pre>
<p>If a pattern match fails in a generator expression, no error occurs.
Instead, that list element is skipped.</p>
<pre class="screen"><code>ghci&gt; [ a | (3,a) &lt;- [(1,&#39;y&#39;),(3,&#39;e&#39;),(5,&#39;p&#39;)] ]
&quot;e&quot;
</code></pre>
<p>List comprehensions are powerful and concise. As a result, they can
be difficult to read. When used with care, they can make our code easier
to follow.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- our original score from Barcode.hs</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span> [distance d (scaleToOne ps) <span class="op">|</span> d <span class="ot">&lt;-</span> srl] digits</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- the same expression, expressed without a list comprehension</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="fu">zip</span> (<span class="fu">map</span> (<span class="fu">flip</span> distance (scaleToOne ps)) srl) digits</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- the same expression, written entirely as a list comprehension</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>[(distance d (scaleToOne ps), n) <span class="op">|</span> d <span class="ot">&lt;-</span> srl, n <span class="ot">&lt;-</span> digits]</span></code></pre></div>
<h2 data-number="8.4" id="remembering-a-matchs-parity"><span
class="header-section-number">8.4</span> Remembering a match's
parity</h2>
<p>For each match in the left group, we have to remember whether we
found it in the even parity table or the odd table.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Parity</span> a <span class="ot">=</span> <span class="dt">Even</span> a <span class="op">|</span> <span class="dt">Odd</span> a <span class="op">|</span> <span class="dt">None</span> a</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>                <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="ot">fromParity ::</span> <span class="dt">Parity</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>fromParity (<span class="dt">Even</span> a) <span class="ot">=</span> a</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>fromParity (<span class="dt">Odd</span> a) <span class="ot">=</span> a</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a>fromParity (<span class="dt">None</span> a) <span class="ot">=</span> a</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="ot">parityMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Parity</span> a <span class="ot">-&gt;</span> <span class="dt">Parity</span> b</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>parityMap f (<span class="dt">Even</span> a) <span class="ot">=</span> <span class="dt">Even</span> (f a)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>parityMap f (<span class="dt">Odd</span> a) <span class="ot">=</span> <span class="dt">Odd</span> (f a)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>parityMap f (<span class="dt">None</span> a) <span class="ot">=</span> <span class="dt">None</span> (f a)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parity</span> <span class="kw">where</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> parityMap</span></code></pre></div>
</div>
<p>We wrap a value in the parity with which it was encoded, and making
it a <code>Functor</code> instance so that we can easily manipulate
parity-encoded values.</p>
<p>We would like to be able to sort parity-encoded values based on the
values they contain. The <code>Data.Function</code> module provides a
lovely combinator that we can use for this, named <code>on</code>.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">on ::</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> b</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>on f g x y <span class="ot">=</span> g x <span class="ot">`f`</span> g y</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>compareWithoutParity <span class="ot">=</span> <span class="fu">compare</span> <span class="ot">`on`</span> fromParity</span></code></pre></div>
</div>
<p>In case it's unclear, try thinking of <code>on</code> as a function
of two arguments, <code>f</code> and <code>g</code>, which returns a
function of two arguments, <code>x</code> and <code>y</code>. It applies
<code>g</code> to <code>x</code> and to <code>y</code>, then
<code>f</code> on the two results (hence the name <code>on</code>).</p>
<p>Wrapping a match in a parity value is straightforward.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bestLeft ::</span> [<span class="dt">Run</span>] <span class="ot">-&gt;</span> [<span class="dt">Parity</span> (<span class="dt">Score</span>, <span class="dt">Digit</span>)]</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>bestLeft ps <span class="ot">=</span> sortBy compareWithoutParity</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>              ((<span class="fu">map</span> <span class="dt">Odd</span> (bestScores leftOddSRL ps)) <span class="op">++</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>               (<span class="fu">map</span> <span class="dt">Even</span> (bestScores leftEvenSRL ps)))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="ot">bestRight ::</span> [<span class="dt">Run</span>] <span class="ot">-&gt;</span> [<span class="dt">Parity</span> (<span class="dt">Score</span>, <span class="dt">Digit</span>)]</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>bestRight <span class="ot">=</span> <span class="fu">map</span> <span class="dt">None</span> <span class="op">.</span> bestScores rightSRL</span></code></pre></div>
</div>
<p>Once we have the best left-hand matches from the even and odd tables,
we sort them based only on the quality of each match.</p>
<ol>
<li><p>Another kind of laziness, of the keyboarding variety</p>
<p>In our definition of the <code>Parity</code> type, we could have used
Haskell's record syntax to avoid the need to write a
<code>fromParity</code> function. In other words, we could have written
it as follows.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">AltParity</span> a <span class="ot">=</span> <span class="dt">AltEven</span> {<span class="ot">fromAltParity ::</span> a}</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="dt">AltOdd</span>  {<span class="ot">fromAltParity ::</span> a}</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>                 <span class="op">|</span> <span class="dt">AltNone</span> {<span class="ot">fromAltParity ::</span> a}</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>Why did we not do this? The answer is slightly shameful, and has to
do with interactive debugging in <code>ghci</code>. When we tell GHC to
automatically derive a <code>Show</code> instance for a type, it
produces different code depending on whether or not we declare the type
with record syntax.</p>
<pre class="screen"><code>ghci&gt; show $ Even 1
&quot;Even 1&quot;
ghci&gt; show $ AltEven 1
&quot;AltEven {fromAltParity = 1}&quot;
ghci&gt; length . show $ Even 1
6
ghci&gt; length . show $ AltEven 1
27
</code></pre>
<p>The <code>Show</code> instance for the variant that uses record
syntax is considerably more verbose. This creates much more noise that
we must scan through when we're trying to read, say, a list of
parity-encoded values output by <code>ghci</code>.</p>
<p>Of course we could write our own, less noisy, <code>Show</code>
instance. It's simply less effort to avoid record syntax and write our
own <code>fromParity</code> function instead, letting GHC derive a more
terse <code>Show</code> instance for us. This isn't an especially
satisfying rationale, but programmer laziness can lead in odd directions
at times.</p></li>
</ol>
<h2 data-number="8.5" id="chunking-a-list"><span
class="header-section-number">8.5</span> Chunking a list</h2>
<p>A common aspect of working with lists is needing to "chunk" them. For
example, each digit in a barcode is encoded using a run of four digits.
We can turn the flat list that represents a row into a list of
four-element lists as follows.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chunkWith ::</span> ([a] <span class="ot">-&gt;</span> ([a], [a])) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>chunkWith _ [] <span class="ot">=</span> []</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>chunkWith f xs <span class="ot">=</span> <span class="kw">let</span> (h, t) <span class="ot">=</span> f xs</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> h <span class="op">:</span> chunkWith f t</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="ot">chunksOf ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [[a]]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>chunksOf n <span class="ot">=</span> chunkWith (<span class="fu">splitAt</span> n)</span></code></pre></div>
</div>
<p>It's somewhat rare that we need to write generic list manipulation
functions like this. Often, a glance through the <code>Data.List</code>
module will find us a function that does exactly, or close enough to,
what we need.</p>
<h2 data-number="8.6" id="generating-a-list-of-candidate-digits"><span
class="header-section-number">8.6</span> Generating a list of candidate
digits</h2>
<p>With our small army of helper functions deployed, the function that
generates lists of candidate matches for each digit group is easy to
write. First of all, we take care of a few early checks to determine
whether matching even makes sense. A list of runs must start on a black
(<code>Zero</code>) bar, and contain enough bars. Here are the first few
equations of our function.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb39"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ot">candidateDigits ::</span> <span class="dt">RunLength</span> <span class="dt">Bit</span> <span class="ot">-&gt;</span> [[<span class="dt">Parity</span> <span class="dt">Digit</span>]]</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>candidateDigits ((_, <span class="dt">One</span>)<span class="op">:</span>_) <span class="ot">=</span> []</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>candidateDigits rle <span class="op">|</span> <span class="fu">length</span> rle <span class="op">&lt;</span> <span class="dv">59</span> <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>If any application of <code>bestLeft</code> or <code>bestRight</code>
results in an empty list, we can't possibly have a match. Otherwise, we
throw away the scores, and return a list of lists of parity-encoded
candidate digits. The outer list is twelve elements long, one per digit
in the barcode. The digits in each sublist are ordered by match
quality.</p>
<p>Here is the remainder of the definition of our function.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>candidateDigits rle</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">any</span> <span class="fu">null</span> match <span class="ot">=</span> []</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> <span class="fu">map</span> (<span class="fu">map</span> (<span class="fu">fmap</span> <span class="fu">snd</span>)) match</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> match <span class="ot">=</span> <span class="fu">map</span> bestLeft left <span class="op">++</span> <span class="fu">map</span> bestRight right</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>        left <span class="ot">=</span> chunksOf <span class="dv">4</span> <span class="op">.</span> <span class="fu">take</span> <span class="dv">24</span> <span class="op">.</span> <span class="fu">drop</span> <span class="dv">3</span> <span class="op">$</span> runLengths</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>        right <span class="ot">=</span> chunksOf <span class="dv">4</span> <span class="op">.</span> <span class="fu">take</span> <span class="dv">24</span> <span class="op">.</span> <span class="fu">drop</span> <span class="dv">32</span> <span class="op">$</span> runLengths</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>        runLengths <span class="ot">=</span> <span class="fu">map</span> <span class="fu">fst</span> rle</span></code></pre></div>
</div>
<p>Let's take a glance at the candidate digits chosen for each group of
bars, from a row taken from the image above.</p>
<pre class="screen"><code>ghci&gt; input = zip (runLengths $ encodeEAN13 &quot;9780132114677&quot;) (cycle [Zero, One])
ghci&gt; :type input
input :: [(Run, Bit)]
ghci&gt; take 7 input
[(1,Zero),(1,One),(1,Zero),(1,One),(3,Zero),(1,One),(2,Zero)]
ghci&gt; mapM_ print $ candidateDigits input
[Odd 7,Even 1,Even 2,Odd 3,Even 4,Odd 8]
[Even 8,Odd 0,Odd 1,Odd 2,Even 6,Even 7]
[Even 0,Even 1,Odd 2,Odd 4,Odd 6,Even 9]
[Odd 1,Odd 0,Even 1,Odd 2,Even 2,Even 4]
[Even 3,Odd 4,Odd 5,Even 7,Even 0,Odd 1]
[Odd 2,Even 0,Odd 1,Even 1,Even 2,Odd 4]
[None 1,None 0,None 2]
[None 1,None 0,None 2]
[None 4,None 2,None 5]
[None 6,None 8,None 2]
[None 7,None 3,None 8]
[None 7,None 3,None 8]
</code></pre>
<h1 data-number="9" id="life-without-arrays-or-hash-tables"><span
class="header-section-number">9</span> Life without arrays or hash
tables</h1>
<p>In an imperative language, the array is as much a "bread and butter"
type as a list or tuple in Haskell. We take it for granted that an array
in an imperative language is usually mutable; we can change an element
of an array whenever it suits us.</p>
<p>As we mentioned in <a
href="12-barcode-recognition.org::*Modifying array elements">the section
called "Modifying array elements"</a> Haskell arrays are <em>not</em>
mutable. This means that to "modify" a single array element, a copy of
the entire array is made, with that single element set to its new value.
Clearly, this approach is not a winner for performance.</p>
<p>The mutable array is a building block for another ubiquitous
imperative data structure, the hash table. In the typical
implementation, an array acts as the "spine" of the table, with each
element containing a list of elements. To add an element to a hash
table, we hash the element to find the array offset, and modify the list
at that offset to add the element to it.</p>
<p>If arrays aren't mutable, to updating a hash table, we must create a
new one. We copy the array, putting a new list at the offset indicated
by the element's hash. We don't need to copy the lists at other offsets,
but we've already dealt performance a fatal blow simply by having to
copy the spine.</p>
<p>At a single stroke, then, immutable arrays have eliminated
<em>two</em> canonical imperative data structures from our toolbox.
Arrays are somewhat less useful in pure Haskell code than in many other
languages. Still, many array codes only update an array during a build
phase, and subsequently use it in a read-only manner.</p>
<h2 data-number="9.1" id="a-forest-of-solutions"><span
class="header-section-number">9.1</span> A forest of solutions</h2>
<p>This is not the calamitous situation that it might seem, though.
Arrays and hash tables are often used as collections indexed by a key,
and in Haskell we use <em>trees</em> for this purpose.</p>
<p>Implementing a naive tree type is particularly easy in Haskell.
Beyond that, more useful tree types are also unusually easy to
implement. Self-balancing structures, such as red-black trees, have
struck fear into generations of undergraduate computer science students,
because the balancing algorithms are notoriously hard to get right.</p>
<p>Haskell's combination of algebraic data types, pattern matching, and
guards reduce even the hairiest of balancing operations to a few lines
of code. We'll bite back our enthusiasm for building trees, however, and
focus on why they're particularly useful in a pure functional
language.</p>
<p>The attraction of a tree to a functional programmer is <em>cheap
modification</em>. We don't break the immutability rule: trees are
immutable just like everything else. However, when we modify a tree,
creating a new tree, we can share most of the structure of the tree
between the old and new versions. For example, in a tree containing
10,000 nodes, we might expect that the old and new versions will share
about 9,985 elements when we add or remove one. In other words, the
number of elements modified per update depends on the height of the
tree, or the logarithm of the size of the tree.</p>
<p>Haskell's standard libraries provide two collection types that are
implemented using balanced trees behind the scenes:
<code>Data.Map</code> for key/value pairs, and <code>Data.Set</code> for
sets of values. As we'll be using <code>Data.Map</code> in the sections
that follow, we'll give a quick introduction to it below.
<code>Data.Set</code> is sufficiently similar that you should be able to
pick it up quickly.</p>
<div class="NOTE">
<p>A word about performance</p>
<p>Compared to a hash table, a well-implemented purely functional tree
data structure will perform competitively. You should not approach trees
with the assumption that your code will pay a performance penalty.</p>
</div>
<h2 data-number="9.2" id="a-brief-introduction-to-maps"><span
class="header-section-number">9.2</span> A brief introduction to
maps</h2>
<p>The <code>Data.Map</code> module provides a parameterised type,
<code>Map k a</code>, that maps from a key type <code>k</code> to a
value type <code>a</code>. Although it is internally a size-balanced
binary tree, the implementation is not visible to us.</p>
<p>Map is strict in its keys, but non-strict in its values. In other
words, the <em>spine</em>, or structure, of the map is always kept up to
date, but values in the map aren't evaluated unless we force them to
be.</p>
<p>It is very important to remember this, as map's laziness over values
is a frequent source of space leaks among coders who are not expecting
it.</p>
<p>Because the <code>Data.Map</code> module contains a number of names
that clash with <code>Prelude</code> names, it's usually imported in
qualified form. Earlier in this chapter, we imported it using the prefix
<code>M</code>.</p>
<ol>
<li><p>Type constraints</p>
<p>The <code>Map</code> type doesn't place any explicit constraints on
its key type, but most of the module's useful functions require that
keys be instances of <code>Ord</code>. This is noteworthy, as it's an
example of a common design pattern in Haskell code: type constraints are
pushed out to where they're actually needed, not necessarily applied at
the point where they'd result in the least fingertyping for a library's
author.</p>
<p>Neither the <code>Map</code> type nor any functions in the module
constrain the types that can be used as values.</p></li>
<li><p>Partial application awkwardness</p>
<p>For some reason, the type signatures of the functions in
<code>Data.Map</code> are not generally friendly to partial application.
The map parameter always comes last, whereas it would be easier to
partially apply if it were first. As a result, code that uses partially
applied map functions almost always contains adapter functions to fiddle
with argument ordering.</p></li>
<li><p>Getting started with the API</p>
<p>The <code>Data.Map</code> module has a large "surface area": it
exports dozens of functions. Just a handful of these comprise the most
frequently used core of the module.</p>
<p>To create an empty map, we use <code>empty</code>. For a map
containing one key/value pair, we use <code>singleton</code>.</p>
<pre class="screen"><code>ghci&gt; M.empty
fromList []
ghci&gt; M.singleton &quot;foo&quot; True
fromList [(&quot;foo&quot;,True)]
</code></pre>
<p>Since the implementation is abstract, we can't pattern match on
<code>Map</code> values. Instead, it provides a number of lookup
functions, of which two are particularly widely used.</p>
<pre class="screen"><code>ghci&gt; :type M.lookup
M.lookup :: Ord k =&gt; k -&gt; M.Map k a -&gt; Maybe a
</code></pre>
<p>As we can see if the map contains a value for the given key,
<code>lookup</code> will return the value wrapped in <code>Just</code>.
Otherwise, it will return <code>Nothing</code>.</p>
<pre class="screen"><code>ghci&gt; m = M.singleton &quot;foo&quot; 1 :: M.Map String Int
ghci&gt; case M.lookup &quot;bar&quot; m of { Just v -&gt; &quot;yay&quot;; Nothing -&gt; &quot;boo&quot; }
&quot;boo&quot;
</code></pre>
<p>The <code>findWithDefault</code> function takes a value to return if
the key isn't in the map.</p>
<div class="WARNING">
<p>Beware the partial functions!</p>
<p>There exists a <code>(!)</code> operator that performs a lookup and
returns the unadorned value associated with a key (i.e. not wrapped in
<code>Maybe</code> or whatever). Unfortunately, it is not a total
function: it calls <code>error</code> if the key is not present in the
map.</p>
</div>
<p>To add a key/value pair to the map, the most useful functions are
<code>insert</code> and <code>insertWith</code>. The <code>insert</code>
function simply inserts a value into the map, overwriting any matching
value that may already have been present.</p>
<pre class="screen"><code>ghci&gt; :type M.insert
M.insert :: Ord k =&gt; k -&gt; a -&gt; M.Map k a -&gt; M.Map k a
ghci&gt; M.insert &quot;quux&quot; 10 m
fromList [(&quot;foo&quot;,1),(&quot;quux&quot;,10)]
ghci&gt; M.insert &quot;foo&quot; 9999 m
fromList [(&quot;foo&quot;,9999)]
</code></pre>
<p>The <code>Data.Map.Strict.insertWith</code> function takes a further
<em>combining function</em> as its argument. If no matching key was
present in the map, the new value is inserted verbatim. Otherwise, the
combining function is called on the new and old values, and its result
is inserted into the map.</p>
<pre class="screen"><code>ghci&gt; :module Data.Map.Strict
ghci&gt; :type insertWith
insertWith :: Ord k =&gt; (a -&gt; a -&gt; a) -&gt; k -&gt; a -&gt; Map k a -&gt; Map k a
ghci&gt; insertWith (+) &quot;zippity&quot; 10 m
fromList [(&quot;foo&quot;,1),(&quot;zippity&quot;,10)]
ghci&gt; insertWith (+) &quot;foo&quot; 9999 m
fromList [(&quot;foo&quot;,10000)]
</code></pre>
<p>As the module name suggests this version of <code>insertWith</code>
evaluates the combining function strictly. This allows you to avoid
space leaks. While there exists a lazy variant of
<code>insertWith</code> in <code>Data.Map</code> it's rarely what you
actually want.</p>
<p>The <code>delete</code> function deletes the given key from the map.
It returns the map unmodified if the key was not present.</p>
<pre class="screen"><code>ghci&gt; :type M.delete
M.delete :: Ord k =&gt; k -&gt; Map k a -&gt; Map k a
ghci&gt; M.delete &quot;foo&quot; m
fromList []
</code></pre>
<p>Finally, there are several efficient functions for performing
set-like operations on maps. Of these, we'll be using <code>union</code>
below. This function is "left biased": if two maps contain the same key,
the result will contain the value from the left map.</p>
<pre class="screen"><code>ghci&gt; m `M.union` M.singleton &quot;quux&quot; 1
fromList [(&quot;foo&quot;,1),(&quot;quux&quot;,1)]
ghci&gt; m `M.union` M.singleton &quot;foo&quot; 0
fromList [(&quot;foo&quot;,1)]
</code></pre>
<p>We have barely covered ten percent of the <code>Data.Map</code> API.
We will cover maps and similar data structures in greater detail in <a
href="13-data-structures.org">Chapter 13, <em>Data Structures</em></a>.
For further inspiration, we encourage you to browse the module
documentation. The module is impressively thorough.</p></li>
</ol>
<h2 data-number="9.3" id="further-reading"><span
class="header-section-number">9.3</span> Further reading</h2>
<p>The book [<a href="bibliography.org::Okasaki99">Okasaki99</a>] gives
a wonderful and thorough implementor's tour of many pure functional data
structures, including several kinds of balanced tree. It also provides
valuable insight into reasoning about the performance of purely
functional data structures and lazy evaluation.</p>
<p>We recommend Okasaki's book as essential reading for functional
programmers. If you're not convinced, Okasaki's PhD thesis, [<a
href="bibliography.org::Okasaki96">Okasaki96</a>], is a less complete
and polished version of the book, and it is available for free
online.</p>
<h1 data-number="10" id="turning-digit-soup-into-an-answer"><span
class="header-section-number">10</span> Turning digit soup into an
answer</h1>
<p>We've got yet another problem to solve now. We have many candidates
for the last twelve digits of the barcode. In addition, we need to use
the parities of the first six digits to figure out what the first digit
is. Finally, we need to ensure that our answer's check digit makes
sense.</p>
<p>This seems quite challenging! We have a lot of uncertain data; what
should we do? It's reasonable to ask if we could perform a brute force
search. Given the candidates we saw in the <code>ghci</code> session
above, how many combinations would we have to examine?</p>
<pre class="screen"><code>ghci&gt; product . map length . candidateDigits $ input
34012224
</code></pre>
<p>So much for that idea. Once again, we'll initially focus on a
subproblem that we know how to solve, and postpone worrying about the
rest.</p>
<h2 data-number="10.1" id="solving-for-check-digits-in-parallel"><span
class="header-section-number">10.1</span> Solving for check digits in
parallel</h2>
<p>Let's abandon the idea of searching for now, and focus on computing a
check digit. The check digit for a barcode can assume one of ten
possible values. For a given parity digit, which input sequences can
cause that digit to be computed?</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Map</span> a <span class="ot">=</span> <span class="dt">M.Map</span> <span class="dt">Digit</span> [a]</span></code></pre></div>
</div>
<p>In this map, the key is a check digit, and the value is a sequence
that evaluates to this check digit. We have two further map types based
on this definition.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">DigitMap</span> <span class="ot">=</span> <span class="dt">Map</span> <span class="dt">Digit</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">ParityMap</span> <span class="ot">=</span> <span class="dt">Map</span> (<span class="dt">Parity</span> <span class="dt">Digit</span>)</span></code></pre></div>
</div>
<p>We'll generically refer to these as "solution maps", because they
show us the digit sequence that "solves for" each check digit.</p>
<p>Given a single digit, here's how we can update an existing solution
map.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">updateMap ::</span> <span class="dt">Parity</span> <span class="dt">Digit</span>       <span class="co">-- ^ new digit</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">Digit</span>              <span class="co">-- ^ existing key</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> [<span class="dt">Parity</span> <span class="dt">Digit</span>]     <span class="co">-- ^ existing digit sequence</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">ParityMap</span>          <span class="co">-- ^ map to update</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>          <span class="ot">-&gt;</span> <span class="dt">ParityMap</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>updateMap digit key <span class="fu">seq</span> <span class="ot">=</span> insertMap key (fromParity digit) (digit<span class="op">:</span><span class="fu">seq</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a><span class="ot">insertMap ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Map</span> a <span class="ot">-&gt;</span> <span class="dt">Map</span> a</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>insertMap key digit val m <span class="ot">=</span> val <span class="ot">`seq`</span> M.insert key&#39; val m</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> key&#39; <span class="ot">=</span> (key <span class="op">+</span> digit) <span class="ot">`mod`</span> <span class="dv">10</span></span></code></pre></div>
</div>
<p>With an existing check digit drawn from the map, the sequence that
solves for it, and a new input digit, this function updates the map with
the new sequence that leads to the new check digit.</p>
<p>This might seem a bit much to digest, but an example will make it
clear. Let's say the check digit we're looking at is <code>4</code>, the
sequence leading to it is <code>[1,3]</code>, and the digit we want to
add to the map is <code>8</code>. The sum of <code>4</code> and
<code>8</code>, modulo 10, is <code>2</code>, so this is the key we'll
be inserting into the map. The sequence that leads to the new check
digit <code>2</code> is thus <code>[8,1,3]</code>, so this is what we'll
insert as the value.</p>
<p>For each digit in a sequence, we'll generate a new solution map,
using that digit and an older solution map.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">useDigit ::</span> <span class="dt">ParityMap</span> <span class="ot">-&gt;</span> <span class="dt">ParityMap</span> <span class="ot">-&gt;</span> <span class="dt">Parity</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> <span class="dt">ParityMap</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>useDigit old new digit <span class="ot">=</span></span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>    new <span class="ot">`M.union`</span> M.foldrWithKey (updateMap digit) M.empty old</span></code></pre></div>
</div>
<p>Once again, let's illustrate what this code is doing using some
examples.</p>
<pre class="screen"><code>ghci&gt; single n = M.singleton n [Even n] :: ParityMap
ghci&gt; useDigit (single 1) M.empty (Even 1)
fromList [(2,[Even 1,Even 1])]
ghci&gt; useDigit (single 1) (single 2) (Even 2)
fromList [(2,[Even 2]),(3,[Even 2,Even 1])]
</code></pre>
<p>The new solution map that we feed to <code>useDigits</code> starts
out empty. We populate it completely by folding <code>useDigits</code>
over a sequence of input digits.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="ot">incorporateDigits ::</span> <span class="dt">ParityMap</span> <span class="ot">-&gt;</span> [<span class="dt">Parity</span> <span class="dt">Digit</span>] <span class="ot">-&gt;</span> <span class="dt">ParityMap</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>incorporateDigits old digits <span class="ot">=</span> foldl&#39; (useDigit old) M.empty digits</span></code></pre></div>
</div>
<p>This generates a complete new solution map from an old one.</p>
<pre class="screen"><code>ghci&gt; incorporateDigits (M.singleton 0 []) [Even 1, Even 5]
fromList [(1,[Even 1]),(5,[Even 5])]
</code></pre>
<p>Finally, we must build the complete solution map. We start out with
an empty map, then fold over each digit position from the barcode in
turn. For each position, we create a new map from our guesses at the
digits in that position. This becomes the old map for the next round of
the fold.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="ot">finalDigits ::</span> [[<span class="dt">Parity</span> <span class="dt">Digit</span>]] <span class="ot">-&gt;</span> <span class="dt">ParityMap</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>finalDigits <span class="ot">=</span> foldl&#39; incorporateDigits (M.singleton <span class="dv">0</span> [])</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>            <span class="op">.</span> mapEveryOther (<span class="fu">map</span> (<span class="fu">fmap</span> (<span class="op">*</span><span class="dv">3</span>)))</span></code></pre></div>
</div>
<p>(From the <code>checkDigit</code> function that we defined in <a
href="12-barcode-recognition.org::*EAN-13 encoding">the section called
"EAN-13 encoding"</a> digit computation requires that we multiply every
other digit by <code>3</code>.)</p>
<p>How long is the list with which we call <code>finalDigits</code>? We
don't yet know what the first digit of our sequence is, so obviously we
can't provide that. And we don't want to include our guess at the check
digit. So the list must be eleven elements long.</p>
<p>Once we've returned from <code>finalDigits</code>, our solution map
is necessarily incomplete, because we haven't yet figured out what the
first digit is.</p>
<h2 data-number="10.2"
id="completing-the-solution-map-with-the-first-digit"><span
class="header-section-number">10.2</span> Completing the solution map
with the first digit</h2>
<p>We haven't yet discussed how we should extract the value of the first
digit from the parities of the left group of digits. This is a
straightforward matter of reusing code that we've already written.</p>
<div class="captioned-content">
<div class="caption">
Barcodes.hs
</div>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">firstDigit ::</span> [<span class="dt">Parity</span> a] <span class="ot">-&gt;</span> <span class="dt">Digit</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>firstDigit <span class="ot">=</span> <span class="fu">snd</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>           <span class="op">.</span> <span class="fu">head</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>           <span class="op">.</span> bestScores paritySRL</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>           <span class="op">.</span> runLengths</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a>           <span class="op">.</span> <span class="fu">map</span> parityBit</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a>           <span class="op">.</span> <span class="fu">take</span> <span class="dv">6</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> parityBit (<span class="dt">Even</span> _) <span class="ot">=</span> <span class="dt">Zero</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a>        parityBit (<span class="dt">Odd</span> _) <span class="ot">=</span> <span class="dt">One</span></span></code></pre></div>
</div>
<p>Each element of our partial solution map now contains a reversed list
of digits and parity data. Our next task is to create a completed
solution map, by computing the first digit in each sequence, and using
it to create that last solution map.</p>
<div class="captioned-content">
<div class="caption">
Barcodes.hs
</div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">addFirstDigit ::</span> <span class="dt">ParityMap</span> <span class="ot">-&gt;</span> <span class="dt">DigitMap</span></span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>addFirstDigit <span class="ot">=</span> M.foldWithKey updateFirst M.empty</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a><span class="ot">updateFirst ::</span> <span class="dt">Digit</span> <span class="ot">-&gt;</span> [<span class="dt">Parity</span> <span class="dt">Digit</span>] <span class="ot">-&gt;</span> <span class="dt">DigitMap</span> <span class="ot">-&gt;</span> <span class="dt">DigitMap</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>updateFirst key <span class="fu">seq</span> <span class="ot">=</span> insertMap key digit (digit<span class="op">:</span>renormalize qes)</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> renormalize <span class="ot">=</span> mapEveryOther (<span class="ot">`div`</span> <span class="dv">3</span>) <span class="op">.</span> <span class="fu">map</span> fromParity</span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>        digit <span class="ot">=</span> firstDigit qes</span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>        qes <span class="ot">=</span> <span class="fu">reverse</span> <span class="fu">seq</span></span></code></pre></div>
</div>
<p>Along the way, we get rid of the <code>Parity</code> type, and
reverse our earlier multiplications by three. Our last step is to
complete the check digit computation.</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">buildMap ::</span> [[<span class="dt">Parity</span> <span class="dt">Digit</span>]] <span class="ot">-&gt;</span> <span class="dt">DigitMap</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>buildMap <span class="ot">=</span> M.mapKeys (<span class="dv">10</span> <span class="op">-</span>)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> addFirstDigit</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>         <span class="op">.</span> finalDigits</span></code></pre></div>
<h2 data-number="10.3" id="finding-the-correct-sequence"><span
class="header-section-number">10.3</span> Finding the correct
sequence</h2>
<p>We now have a map of all possible checksums and the sequences that
lead to each. All that remains is to take our guesses at the check
digit, and see if we have a corresponding solution map entry.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb61"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="ot">solve ::</span> [[<span class="dt">Parity</span> <span class="dt">Digit</span>]] <span class="ot">-&gt;</span> [[<span class="dt">Digit</span>]]</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>solve [] <span class="ot">=</span> []</span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>solve xs <span class="ot">=</span> catMaybes <span class="op">$</span> <span class="fu">map</span> (addCheckDigit m) checkDigits</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> checkDigits <span class="ot">=</span> <span class="fu">map</span> fromParity (<span class="fu">last</span> xs)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>          m <span class="ot">=</span> buildMap (<span class="fu">init</span> xs)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>          addCheckDigit m k <span class="ot">=</span> (<span class="op">++</span>[k]) <span class="op">&lt;$&gt;</span> M.lookup k m</span></code></pre></div>
</div>
<p>Let's try this out on the row we picked from our photo, and see if we
get a sensible answer.</p>
<pre class="screen"><code>ghci&gt; listToMaybe . solve . candidateDigits $ input
Just [9,7,8,0,1,3,2,1,1,4,6,7,7]
</code></pre>
<p>Excellent! This is exactly the string encoded in the barcode we
photographed.</p>
<h1 data-number="11" id="working-with-row-data"><span
class="header-section-number">11</span> Working with row data</h1>
<p>We've mentioned repeatedly that we are taking a single row from our
image. Here's how.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withRow ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Pixmap</span> <span class="ot">-&gt;</span> (<span class="dt">RunLength</span> <span class="dt">Bit</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>withRow n greymap f <span class="ot">=</span> f <span class="op">.</span> runLength <span class="op">.</span> elems <span class="op">$</span> posterized</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> posterized <span class="ot">=</span> threshold <span class="fl">0.4</span> <span class="op">.</span> <span class="fu">fmap</span> luminance <span class="op">.</span> row n <span class="op">$</span> greymap</span></code></pre></div>
</div>
<p>The <code>withRow</code> function takes a row, converts it to
monochrome, then calls another function on the run length encoded row
data. To get the row data, it calls <code>row</code>.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">row ::</span> (<span class="dt">Ix</span> a, <span class="dt">Ix</span> b) <span class="ot">=&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Array</span> (a,b) c <span class="ot">-&gt;</span> <span class="dt">Array</span> a c</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>row j a <span class="ot">=</span> ixmap (l,u) project a</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> project i <span class="ot">=</span> (i,j)</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>          ((l,_), (u,_)) <span class="ot">=</span> bounds a</span></code></pre></div>
</div>
<p>This function takes a bit of explaining. Whereas <code>fmap</code>
transforms the <em>values</em> in an array, <code>ixmap</code>
transforms the <em>indices</em> of an array. It's a very powerful
function that lets us "slice" an array however we please.</p>
<p>The first argument to <code>ixmap</code> is the bounds of the new
array. These bounds can be of a different dimension than the source
array. In <code>row</code>, for example, we're extracting a
one-dimensional array from a two-dimensional array.</p>
<p>The second argument is a <em>projection</em> function. This takes an
index from the new array and returns an index into the source array. The
value at that projected index then becomes the value in the new array at
the original index. For example, if we pass <code>2</code> into the
projection function and it returns <code>(2,2)</code>, the element at
index <code>2</code> of the new array will be taken from element
<code>(2,2)</code> of the source array.</p>
<h1 data-number="12" id="pulling-it-all-together"><span
class="header-section-number">12</span> Pulling it all together</h1>
<p>Our <code>candidateDigits</code> function gives an empty result
unless we call it at the beginning of a barcode sequence. We can easily
scan across a row until we get a match as follows.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb65"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findMatch ::</span> [(<span class="dt">Run</span>, <span class="dt">Bit</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [[<span class="dt">Digit</span>]]</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>findMatch <span class="ot">=</span> listToMaybe</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>)</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> <span class="fu">map</span> (solve <span class="op">.</span> candidateDigits)</span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>          <span class="op">.</span> tails</span></code></pre></div>
</div>
<p>Here, we're taking advantage of lazy evaluation. The call to
<code>map</code> over <code>tails</code> will only be evaluated until it
results in a non-empty list.</p>
<p>Next, we choose a row from an image, and try to find a barcode in
it.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">findEAN13 ::</span> <span class="dt">Pixmap</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Digit</span>]</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>findEAN13 pixmap <span class="ot">=</span> withRow center pixmap (<span class="fu">fmap</span> <span class="fu">head</span> <span class="op">.</span> findMatch)</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> (_, (maxX, _)) <span class="ot">=</span> bounds pixmap</span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>        center <span class="ot">=</span> (maxX <span class="op">+</span> <span class="dv">1</span>) <span class="ot">`div`</span> <span class="dv">2</span></span></code></pre></div>
</div>
<p>Finally, here's a very simple wrapper that prints barcodes from
whatever netpbm image files we pass into our program on the command
line.</p>
<div class="captioned-content">
<div class="caption">
Barcode.hs
</div>
<div class="sourceCode" id="cb67"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>  forM_ args <span class="op">$</span> \arg <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>    e <span class="ot">&lt;-</span> parse parseRawPPM <span class="op">&lt;$&gt;</span> L.readFile arg</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> e <span class="kw">of</span></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Left</span> err <span class="ot">-&gt;</span>     <span class="fu">print</span> <span class="op">$</span> <span class="st">&quot;error: &quot;</span> <span class="op">++</span> err</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Right</span> pixmap <span class="ot">-&gt;</span> <span class="fu">print</span> <span class="op">$</span> findEAN13 pixmap</span></code></pre></div>
</div>
<p>Notice that, of the more than thirty functions we've defined in this
chapter, <code>main</code> is the only one that lives in
<code>IO</code>.</p>
<h1 data-number="13" id="a-few-comments-on-development-style"><span
class="header-section-number">13</span> A few comments on development
style</h1>
<p>You may have noticed that many of the functions we presented in this
chapter were short functions at the top level of the source file. This
is no accident. As we mentioned earlier, when we started on this
chapter, we didn't know what form our solution was going to take.</p>
<p>Quite often, then, we had to explore a problem space in order to
figure out where we were going. To do this, we spent a lot of time
fiddling about in <code>ghci</code>, performing tiny experiments on
individual functions. This kind of exploration requires that a function
be declared at the top level of a source file, as otherwise
<code>ghci</code> won't be able to see it.</p>
<p>Once we were satisfied that individual functions were behaving
themselves, we started to glue them together, again investigating the
consequences in <code>ghci</code>. This is where our devotion to writing
type signatures paid back, as we immediately discovered when a
particular composition of functions couldn't possibly work.</p>
<p>At the end of this process, we were left with a large number of very
small top-level functions, each with a type signature. This isn't the
most compact representation possible; we could have hoisted many of
those functions into <code>let</code> or <code>where</code> blocks when
we were done with them. However, we find that the added vertical space,
small function bodies, and type signatures make the code far more
readable, so we generally avoided "golfing" functions after we wrote
them<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>.</p>
<p>Working in a language with strong, static typing does not at all
interfere with incrementally and fluidly developing a solution to a
problem. We find the turnaround between writing a function and getting
useful feedback from <code>ghci</code> to be very rapid; it greatly
assists us in writing good code quickly.</p>
<h1 data-number="14" id="footnotes"><span
class="header-section-number">14</span> Footnotes</h1>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>The formula originates in ITU-R
Recommendation 601.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Our use of the word "golf" comes from
a game originally played by Perl hackers, in which programmers try to
create the smallest piece of code for some purpose. The code with the
fewest (key)strokes wins.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
