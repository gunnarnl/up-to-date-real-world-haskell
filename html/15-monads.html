<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 14. Monads</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 14. Monads</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#introduction"><span class="toc-section-number">1</span>
Introduction</a></li>
<li><a href="#revisiting-earlier-code-examples"><span
class="toc-section-number">2</span> Revisiting earlier code examples</a>
<ul>
<li><a href="#maybe-chaining"><span
class="toc-section-number">2.1</span> Maybe chaining</a></li>
<li><a href="#implicit-state"><span
class="toc-section-number">2.2</span> Implicit state</a></li>
</ul></li>
<li><a href="#looking-for-shared-patterns"><span
class="toc-section-number">3</span> Looking for shared patterns</a></li>
<li><a href="#the-monad-type-class"><span
class="toc-section-number">4</span> The Monad type class</a></li>
<li><a href="#and-now-a-jargon-moment"><span
class="toc-section-number">5</span> And now, a jargon moment</a></li>
<li><a href="#using-a-new-monad-show-your-work"><span
class="toc-section-number">6</span> Using a new monad: show your
work!</a>
<ul>
<li><a href="#information-hiding"><span
class="toc-section-number">6.1</span> Information hiding</a></li>
<li><a href="#controlled-escape"><span
class="toc-section-number">6.2</span> Controlled escape</a></li>
<li><a href="#leaving-a-trace"><span
class="toc-section-number">6.3</span> Leaving a trace</a></li>
<li><a href="#using-the-logger-monad"><span
class="toc-section-number">6.4</span> Using the <code>Logger</code>
monad</a></li>
</ul></li>
<li><a href="#mixing-pure-and-monadic-code"><span
class="toc-section-number">7</span> Mixing pure and monadic
code</a></li>
<li><a href="#putting-a-few-misconceptions-to-rest"><span
class="toc-section-number">8</span> Putting a few misconceptions to
rest</a></li>
<li><a href="#building-the-logger-monad"><span
class="toc-section-number">9</span> Building the <code>Logger</code>
monad</a>
<ul>
<li><a href="#sequential-logging-not-sequential-evaluation"><span
class="toc-section-number">9.1</span> Sequential logging, not sequential
evaluation</a></li>
<li><a href="#the-writer-monad"><span
class="toc-section-number">9.2</span> The writer monad</a></li>
</ul></li>
<li><a href="#the-maybe-monad"><span
class="toc-section-number">10</span> The Maybe monad</a>
<ul>
<li><a href="#executing-the-maybe-monad"><span
class="toc-section-number">10.1</span> Executing the Maybe
monad</a></li>
<li><a href="#maybe-at-work"><span
class="toc-section-number">10.2</span> Maybe at work</a></li>
</ul></li>
<li><a href="#the-list-monad"><span class="toc-section-number">11</span>
The list monad</a>
<ul>
<li><a href="#understanding-the-list-monad"><span
class="toc-section-number">11.1</span> Understanding the list
monad</a></li>
<li><a href="#putting-the-list-monad-to-work"><span
class="toc-section-number">11.2</span> Putting the list monad to
work</a></li>
</ul></li>
<li><a href="#desugaring-of-do-blocks"><span
class="toc-section-number">12</span> Desugaring of do blocks</a>
<ul>
<li><a href="#monads-as-a-programmable-semicolon"><span
class="toc-section-number">12.1</span> Monads as a programmable
semicolon</a></li>
<li><a href="#why-go-sugar-free"><span
class="toc-section-number">12.2</span> Why go sugar-free?</a></li>
</ul></li>
<li><a href="#the-state-monad"><span
class="toc-section-number">13</span> The state monad</a>
<ul>
<li><a href="#almost-a-state-monad"><span
class="toc-section-number">13.1</span> Almost a state monad</a></li>
<li><a href="#reading-and-modifying-the-state"><span
class="toc-section-number">13.2</span> Reading and modifying the
state</a></li>
<li><a href="#will-the-real-state-monad-please-stand-up"><span
class="toc-section-number">13.3</span> Will the real state monad please
stand up?</a></li>
<li><a href="#using-the-state-monad-generating-random-values"><span
class="toc-section-number">13.4</span> Using the <code>State</code>
monad: generating random values</a></li>
<li><a href="#a-first-attempt-at-purity"><span
class="toc-section-number">13.5</span> A first attempt at
purity</a></li>
<li><a href="#random-values-in-the-state-monad"><span
class="toc-section-number">13.6</span> Random values in the
<code>State</code> monad</a></li>
<li><a href="#running-the-state-monad"><span
class="toc-section-number">13.7</span> Running the state monad</a></li>
<li><a href="#what-about-a-bit-more-state"><span
class="toc-section-number">13.8</span> What about a bit more
state?</a></li>
</ul></li>
<li><a href="#another-way-of-looking-at-monads"><span
class="toc-section-number">14</span> Another way of looking at
monads</a></li>
<li><a href="#the-monad-laws-and-good-coding-style"><span
class="toc-section-number">15</span> The monad laws, and good coding
style</a></li>
</ul>
</nav>
<h1 data-number="1" id="introduction"><span
class="header-section-number">1</span> Introduction</h1>
<p>In <a href="7-io.org">Chapter 7, <em>I/O</em></a> and <a
href="14-using-parsec.org">Chapter 14, Using Parsec</a> we talked about
the <code>IO</code> and <code>GenParser</code> monads respectively, but
we intentionally kept the discussion narrowly focused on how to use
them. We didn't discuss what a monad <em>is</em>.</p>
<p>When we had practical problems to solve in earlier chapters, we
introduced structures that, as we will soon see, are actually monads. We
aim to show you that a monad is often an <em>obvious</em> and
<em>useful</em> tool to help solve a problem. We'll define a few monads
in this chapter, to show how easy it is.</p>
<h1 data-number="2" id="revisiting-earlier-code-examples"><span
class="header-section-number">2</span> Revisiting earlier code
examples</h1>
<h2 data-number="2.1" id="maybe-chaining"><span
class="header-section-number">2.1</span> Maybe chaining</h2>
<p>Let's take another look at the <code>parseP5</code> function that we
wrote in <a href="10-parsing-a-binary-data-format.org">Chapter 10,
<em>Code case study: parsing a binary data format</em></a>.</p>
<div class="captioned-content">
<div class="caption">
PNM.hs
</div>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">matchHeader ::</span> <span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">L.ByteString</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- &quot;nat&quot; here is short for &quot;natural number&quot;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ot">getNat ::</span> <span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Int</span>, <span class="dt">L.ByteString</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ot">getBytes ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">L.ByteString</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>         <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">L.ByteString</span>, <span class="dt">L.ByteString</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>parseP5 s <span class="ot">=</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> matchHeader (L8.pack <span class="st">&quot;P5&quot;</span>) s <span class="kw">of</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> s1 <span class="ot">-&gt;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> getNat s1 <span class="kw">of</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> (width, s2) <span class="ot">-&gt;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> getNat (L8.dropWhile <span class="fu">isSpace</span> s2) <span class="kw">of</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (height, s3) <span class="ot">-&gt;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> getNat (L8.dropWhile <span class="fu">isSpace</span> s3) <span class="kw">of</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (maxGrey, s4)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> maxGrey <span class="op">&gt;</span> <span class="dv">255</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                      <span class="kw">case</span> getBytes <span class="dv">1</span> s4 <span class="kw">of</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Just</span> (_, s5) <span class="ot">-&gt;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                          <span class="kw">case</span> getBytes (width <span class="op">*</span> height) s5 <span class="kw">of</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                            <span class="dt">Just</span> (bitmap, s6) <span class="ot">-&gt;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>                              <span class="dt">Just</span> (<span class="dt">Greymap</span> width height maxGrey bitmap, s6)</span></code></pre></div>
</div>
<p>When we introduced this function, it threatened to march off the
right side of the page if it got much more complicated. We brought the
staircasing under control using the <code>(&gt;&gt;?)</code>
function.</p>
<div class="captioned-content">
<div class="caption">
PNM.hs
</div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;?) ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Nothing</span> <span class="op">&gt;&gt;?</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Just</span> v  <span class="op">&gt;&gt;?</span> f <span class="ot">=</span> f v</span></code></pre></div>
</div>
<p>We carefully chose the type of <code>(&gt;&gt;?)</code> to let us
chain together functions that return a <code>Maybe</code> value. So long
as the result type of one function matches the parameter of the next, we
can chain functions returning <code>Maybe</code> together indefinitely.
The body of <code>(&gt;&gt;?)</code> hides the details of whether the
chain of functions we build is short-circuited somewhere, due to one
returning <code>Nothing</code>, or completely evaluated.</p>
<h2 data-number="2.2" id="implicit-state"><span
class="header-section-number">2.2</span> Implicit state</h2>
<p>Useful as <code>(&gt;&gt;?)</code> was for cleaning up the structure
of <code>parseP5</code>, we had to incrementally consume pieces of a
string as we parsed it. This forced us to pass the current value of the
string down our chain of ~Maybe~s, wrapped up in a tuple. Each function
in the chain put a result into one element of the tuple, and the
unconsumed remainder of the string into the other.</p>
<div class="captioned-content">
<div class="caption">
PNM.hs
</div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parseP5_take2 ::</span> <span class="dt">L.ByteString</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Greymap</span>, <span class="dt">L.ByteString</span>)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>parseP5_take2 s <span class="ot">=</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    matchHeader (L8.pack <span class="st">&quot;P5&quot;</span>) s      <span class="op">&gt;&gt;?</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    \s <span class="ot">-&gt;</span> skipSpace ((), s)           <span class="op">&gt;&gt;?</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    (getNat <span class="op">.</span> <span class="fu">snd</span>)                    <span class="op">&gt;&gt;?</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    skipSpace                         <span class="op">&gt;&gt;?</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    \(width, s) <span class="ot">-&gt;</span>   getNat s         <span class="op">&gt;&gt;?</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    skipSpace                         <span class="op">&gt;&gt;?</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    \(height, s) <span class="ot">-&gt;</span>  getNat s         <span class="op">&gt;&gt;?</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    \(maxGrey, s) <span class="ot">-&gt;</span> getBytes <span class="dv">1</span> s     <span class="op">&gt;&gt;?</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    (getBytes (width <span class="op">*</span> height) <span class="op">.</span> <span class="fu">snd</span>) <span class="op">&gt;&gt;?</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    \(bitmap, s) <span class="ot">-&gt;</span> <span class="dt">Just</span> (<span class="dt">Greymap</span> width height maxGrey bitmap, s)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="ot">skipSpace ::</span> (a, <span class="dt">L.ByteString</span>) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">L.ByteString</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>skipSpace (a, s) <span class="ot">=</span> <span class="dt">Just</span> (a, L8.dropWhile <span class="fu">isSpace</span> s)</span></code></pre></div>
</div>
<p>Once again, we were faced with a pattern of repeated behaviour:
consume some string, return a result, and return the remaining string
for the next function to consume. However, this pattern was more
insidious: if we wanted to pass another piece of information down the
chain, we'd have to modify nearly every element of the chain, turning
each two-tuple into a three-tuple!</p>
<p>We addressed this by moving the responsibility for managing the
current piece of string out of the individual functions in the chain,
and into the function that we used to chain them together.</p>
<div class="captioned-content">
<div class="caption">
Parse.hs
</div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(==&gt;) ::</span> <span class="dt">Parse</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Parse</span> b) <span class="ot">-&gt;</span> <span class="dt">Parse</span> b</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>firstParser <span class="op">==&gt;</span> secondParser <span class="ot">=</span> <span class="dt">Parse</span> chainedParser</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> chainedParser initState <span class="ot">=</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> runParse firstParser initState <span class="kw">of</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Left</span> errMessage <span class="ot">-&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Left</span> errMessage</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Right</span> (firstResult, newState) <span class="ot">-&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                runParse (secondParser firstResult) newState</span></code></pre></div>
</div>
<p>We also hid the details of the parsing state in the
<code>ParseState</code> type. Even the <code>getState</code> and
<code>putState</code> functions don't inspect the parsing state, so any
modification to <code>ParseState</code> will have no effect on any
existing code.</p>
<h1 data-number="3" id="looking-for-shared-patterns"><span
class="header-section-number">3</span> Looking for shared patterns</h1>
<p>When we look at the above examples in detail, they don't seem to have
much in common. Obviously, they're both concerned with chaining
functions together, and with hiding details to let us write tidier code.
However, let's take a step back and consider them in <em>less</em>
detail.</p>
<p>First, let's look at the type definitions.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Maybe</span> a <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>             <span class="op">|</span> <span class="dt">Just</span> a</span></code></pre></div>
<div class="captioned-content">
<div class="caption">
Parse.hs
</div>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Parse</span> a <span class="ot">=</span> <span class="dt">Parse</span> {</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    runParse ::</span> <span class="dt">ParseState</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> (a, <span class="dt">ParseState</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<p>The common feature of these two types is that each has a single type
parameter on the left of the definition, which appears somewhere on the
right. These are thus generic types, which know nothing about their
payloads.</p>
<p>Next, we'll examine the chaining functions that we wrote for the two
types.</p>
<pre class="screen"><code>ghci&gt; :l Parse.hs
[1 of 2] Compiling PNM              ( PNM.hs, interpreted )
[2 of 2] Compiling Parse            ( Parse.hs, interpreted )
Ok, two modules loaded.
ghci&gt; :type (&gt;&gt;?)
(&gt;&gt;?) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
ghci&gt; :type (==&gt;)
(==&gt;) :: Parse a -&gt; (a -&gt; Parse b) -&gt; Parse b
</code></pre>
<p>These functions have strikingly similar types. If we were to turn
those type constructors into a type variable, we'd end up with a single
more abstract type.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chain ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span></code></pre></div>
<p>Finally, in each case we have a function that takes a "plain" value,
and "injects" it into the target type. For <code>Maybe</code>, this
function is simply the value constructor <code>Just</code>, but the
injector for <code>Parse</code> is more complicated.</p>
<div class="captioned-content">
<div class="caption">
Parse.hs
</div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ot">identity ::</span> a <span class="ot">-&gt;</span> <span class="dt">Parse</span> a</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>identity a <span class="ot">=</span> <span class="dt">Parse</span> (\s <span class="ot">-&gt;</span> <span class="dt">Right</span> (a, s))</span></code></pre></div>
</div>
<p>Again, it's not the details or complexity that we're interested in,
it's the fact that each of these types has an "injector" function, which
looks like this.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">inject ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>It is <em>exactly</em> these three properties, and a few rules about
how we can use them together, that define a monad in Haskell. Let's
revisit the above list in condensed form.</p>
<ul>
<li>A type constructor <code>m</code>.</li>
<li>A function of type <code>m a -&gt; (a -&gt; m b) -&gt; m b</code>
for chaining the output of one function into the input of another.</li>
<li>A function of type <code>a -&gt; m a</code> for injecting a normal
value into the chain, i.e. it wraps a type a with the type constructor
<code>m</code>.</li>
</ul>
<p>The properties that make the <code>Maybe</code> type a monad are its
type constructor <code>Maybe a</code>, our chaining function
<code>(&gt;&gt;?)</code>, and the injector function
<code>Just</code>.</p>
<p>For <code>Parse</code>, the corresponding properties are the type
constructor <code>Parse a</code>, the chaining function
<code>(==&gt;)</code>, and the injector function
<code>identity</code>.</p>
<p>We have intentionally said nothing about how the chaining and
injection functions of a monad should behave, and that's because this
almost doesn't matter. In fact, monads are ubiquitous in Haskell code
precisely because they are so simple. Many common programming patterns
have a monadic structure: passing around implicit data, or
short-circuiting a chain of evaluations if one fails, to choose but
two.</p>
<h1 data-number="4" id="the-monad-type-class"><span
class="header-section-number">4</span> The Monad type class</h1>
<p>We can capture the notions of chaining and injection, and the types
that we want them to have, in a Haskell type class. The standard
<code>Prelude</code> already defines just such a type class, named
<code>Monad</code>.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">Monad</span> m <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- chain</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="ot">    (&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- inject</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>As you can see every monad is also an applicative functor in the same
way that every functor is an applicative functor. These terms as well as
their relationship are borrowed from a branch of mathematics called
category theory which is a source of inspiration for a lot of Haskell
design since Phillip Wadler, one of its authors, suggested in his paper
<a
href="https://www.cambridge.org/core/journals/mathematical-structures-in-computer-science/article/div-classtitlecomprehending-monadsa-hreffn01-ref-typefnspan-classsupspanadiv/8678CDA48EB1DF29B9C2C9943AF6BC29">Comprehending
monads</a> to follow Eugenio Moggi's idea of using monads to structure
programs.</p>
<p>Here, <code>(&gt;&gt;=)</code> is our chaining function. We've
already been introduced to it in <a href="7-io.org::*Sequencing">the
section called "Sequencing"</a> referred to as "bind", as it binds the
result of the computation on the left to the parameter of the one on the
right.</p>
<p>Our injection function is <code>return</code>. As we noted in <a
href="7-io.org::*The True Nature of Return">the section called "The True
Nature of Return"</a> name <code>return</code> is a little unfortunate.
That name is widely used in imperative languages, where it has a fairly
well understood meaning. In Haskell, its behaviour is much less
constrained. In particular, calling <code>return</code> in the middle of
a chain of functions won't cause the chain to exit early. A useful way
to link its behavior to its name is that it <em>returns</em> a pure
value (of type <code>a</code>) into a monad (of type
<code>m a</code>).</p>
<p>While <code>(&gt;&gt;=)</code> and <code>return</code> are the core
functions of the <code>Monad</code> type class, it also defines two
other functions. The first is <code>(&gt;&gt;)</code>. Like
<code>(&gt;&gt;=)</code>, it performs chaining, but it ignores the value
on the left.</p>
<div class="captioned-content">
<div class="caption">
Maybe.hs
</div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;) ::</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">&gt;&gt;</span> f <span class="ot">=</span> a <span class="op">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span> f</span></code></pre></div>
</div>
<p>We use this function when we want to perform actions in a certain
order, but don't care what the result of one is. This might seem
pointless: why would we not care what a function's return value is?
Recall, though, that we defined a <code>(==&gt;&amp;)</code> combinator
earlier to express exactly this. Alternatively, consider a function like
<code>print</code>, which provides a placeholder result that we do not
need to inspect.</p>
<pre class="screen"><code>ghci&gt; :type print &quot;foo&quot;
print &quot;foo&quot; :: IO ()
</code></pre>
<p>If we use plain <code>(&gt;&gt;=)</code>, we have to provide as its
right hand side a function that ignores its argument.</p>
<pre class="screen"><code>ghci&gt; print &quot;foo&quot; &gt;&gt;= \_ -&gt; print &quot;bar&quot;
&quot;foo&quot;
&quot;bar&quot;
</code></pre>
<p>But if we use <code>(&gt;&gt;)</code>, we can omit the needless
function.</p>
<pre class="screen"><code>ghci&gt; print &quot;baz&quot; &gt;&gt; print &quot;quux&quot;
&quot;baz&quot;
&quot;quux&quot;
</code></pre>
<p>As we showed above, the default implementation of
<code>(&gt;&gt;)</code> is defined in terms of
<code>(&gt;&gt;=)</code>.</p>
<p>The second non-core <code>Monad</code> function is <code>fail</code>,
which takes an error message and does something to make the chain of
functions fail.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fail</span><span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fail</span> <span class="ot">=</span> <span class="fu">error</span></span></code></pre></div>
<div class="WARNING">
<p>Beware of fail</p>
<p>Many <code>Monad</code> instances don't override the default
implementation of <code>fail</code> that we show here, so in those
monads, <code>fail</code> uses <code>error</code>. Calling
<code>error</code> is usually highly undesirable, since it throws an
exception that callers either cannot catch or will not expect.</p>
<p>Even if you know that right now you're executing in a monad that has
<code>fail</code> do something more sensible, we still recommend
avoiding it. It's far too easy to cause yourself a problem later when
you refactor your code and forget that a previously safe use of
<code>fail</code> might be dangerous in its new context.</p>
</div>
<p>To revisit the parser that we developed in <a
href="10-parsing-a-binary-data-format.org">Chapter 10, <em>Code case
study: parsing a binary data format</em></a>, here is its
<code>Monad</code> instance.</p>
<div class="captioned-content">
<div class="caption">
Parse.hs
</div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Parse</span> <span class="kw">where</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Parse</span> <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> identity</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Parse</span> <span class="kw">where</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&gt;&gt;=</span>) <span class="ot">=</span> (<span class="op">==&gt;</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> <span class="ot">=</span> bail</span></code></pre></div>
</div>
<p>We are going to see <code>liftM</code> in <a
href="15-monads.org::*Mixing pure and monadic code">the section called
"Mixing pure and monadic code"</a> <a
href="16-programming-with-monads.org::*Generalised lifting">the section
called "Generalised lifting"</a> they are "aliases" to known
functions.</p>
<p>Notice that <code>pure</code> is defined as our <code>identity</code>
function and <code>return</code> is defined as <code>pure</code>. You
can actually get rid of the <code>return</code> definition and use
<code>pure</code> instead but there's enough code in the wild using
<code>return</code> to cover it here.</p>
<h1 data-number="5" id="and-now-a-jargon-moment"><span
class="header-section-number">5</span> And now, a jargon moment</h1>
<p>There are a few terms of jargon around monads that you may not be
familiar with. These aren't formal terms, but they're in common use, so
it's helpful to know about them.</p>
<ul>
<li>"Monadic" simply means "pertaining to monads". A monadic
<em>type</em> is an instance of the <code>Monad</code> type class; a
monadic <em>value</em> has a monadic type.</li>
<li>When we say that a type "is a monad", this is really a shorthand way
of saying that it's an instance of the <code>Monad</code> type class.
Being an instance of <code>Monad</code> gives us the necessary monadic
triple of type constructor, injection function, and chaining
function.</li>
<li>In the same way, a reference to "the Foo monad" implies that we're
talking about the type named <code>Foo</code>, and that it's an instance
of <code>Monad</code>.</li>
<li>An "action" is another name for a monadic value. This use of the
word probably originated with the introduction of monads for I/O, where
a monadic value like <code>print "foo"</code> can have an observable
side effect. A function with a monadic return type might also be
referred to as an action, though this is a little less common.</li>
</ul>
<h1 data-number="6" id="using-a-new-monad-show-your-work"><span
class="header-section-number">6</span> Using a new monad: show your
work!</h1>
<p>In our introduction to monads, we showed how some pre-existing code
was already monadic in form. Now that we are beginning to grasp what a
monad is, and we've seen the <code>Monad</code> type class, let's build
a monad with foreknowledge of what we're doing. We'll start out by
defining its interface, then we'll put it to use. Once we have those out
of the way, we'll finally build it.</p>
<p>Pure Haskell code is wonderfully clean to write, but of course it
can't perform I/O. Sometimes, we'd like to have a record of decisions we
made, without writing log information to a file. Let's develop a small
library to help with this.</p>
<p>Recall the <code>globToRegex</code> function that we developed in <a
href="8-efficient-file-processing-regular-expressions-and-file-name-matching.org::*Translating a glob pattern into a regular expression">the
section called "Translating a glob pattern into a regular
expression"</a> We will modify it so that it keeps a record of each of
the special pattern sequences that it translates. We are revisiting
familiar territory for a reason: it lets us compare non-monadic and
monadic versions of the same code.</p>
<p>To start off, we'll wrap our result type with a <code>Logger</code>
type constructor.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">globToRegex ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span> <span class="dt">String</span></span></code></pre></div>
</div>
<h2 data-number="6.1" id="information-hiding"><span
class="header-section-number">6.1</span> Information hiding</h2>
<p>We'll intentionally keep the internals of the <code>Logger</code>
module abstract.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Logger</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Logger</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">Log</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    , runLogger</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>    , record</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">where</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (ap)</span></code></pre></div>
</div>
<p>Hiding the details like this has two benefits: it grants us
considerable flexibility in how we implement our monad, and more
importantly, it gives users a simple interface.</p>
<p>Our <code>Logger</code> type is purely a <em>type</em> constructor.
We don't export the <em>value</em> constructor that a user would need to
create a value of this type. All they can use <code>Logger</code> for is
writing type signatures.</p>
<p>The <code>Log</code> type is just a synonym for a list of strings, to
make a few signatures more readable. We use a list of strings to keep
the implementation simple.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Log</span> <span class="ot">=</span> [<span class="dt">String</span>]</span></code></pre></div>
</div>
<p>Instead of giving our users a value constructor, we provide them with
a function, <code>runLogger</code>, that evaluates a logged action. This
returns both the result of an action and whatever was logged while the
result was being computed.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runLogger ::</span> <span class="dt">Logger</span> a <span class="ot">-&gt;</span> (a, <span class="dt">Log</span>)</span></code></pre></div>
</div>
<h2 data-number="6.2" id="controlled-escape"><span
class="header-section-number">6.2</span> Controlled escape</h2>
<p>The <code>Monad</code> type class doesn't provide any means for
values to escape their monadic shackles. We can inject a value into a
monad using <code>return</code>. We can extract a value from a monad
using <code>(&gt;&gt;=)</code> but the function on the right, which can
see an unwrapped value, has to wrap its own result back up again.</p>
<p>Most monads have one or more <code>runLogger</code>-like functions.
The notable exception is of course <code>IO</code>, which we usually
only escape from by exiting a program.</p>
<p>A monad execution function runs the code inside the monad and unwraps
its result. Such functions are usually the only means provided for a
value to escape from its monadic wrapper. The author of a monad thus has
complete control over how whatever happens inside the monad gets
out.</p>
<p>Some monads have several execution functions. In our case, we can
imagine a few alternatives to <code>runLogger</code>: one might only
return the log messages, while another might return just the result and
drop the log messages.</p>
<h2 data-number="6.3" id="leaving-a-trace"><span
class="header-section-number">6.3</span> Leaving a trace</h2>
<p>When executing inside a <code>Logger</code> action, user code calls
<code>record</code> to record something.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">record ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span> ()</span></code></pre></div>
</div>
<p>Since recording occurs in the plumbing of our monad, our action's
result supplies no information.</p>
<p>Usually, a monad will provide one or more helper functions like our
<code>record</code>. These are our means for accessing the special
behaviors of that monad.</p>
<p>Our module also defines the <code>Monad</code> instance for the
<code>Logger</code> type. These definitions are all that a client module
needs in order to be able to use this monad.</p>
<p>Here is a preview, in <code>ghci</code>, of how our monad will
behave.</p>
<pre class="screen"><code>ghci&gt; simple = return True :: Logger Bool
ghci&gt; runLogger simple
(True,[])
</code></pre>
<p>When we run the logged action using <code>runLogger</code>, we get
back a pair. The first element is the result of our code; the second is
the list of items logged while the action executed. We haven't logged
anything, so the list is empty. Let's fix that.</p>
<pre class="screen"><code>ghci&gt; runLogger (record &quot;hi mom!&quot; &gt;&gt; return 3.1337)
(3.1337,[&quot;hi mom!&quot;])
</code></pre>
<h2 data-number="6.4" id="using-the-logger-monad"><span
class="header-section-number">6.4</span> Using the <code>Logger</code>
monad</h2>
<p>Here's how we kick off our glob-to-regexp conversion inside the
<code>Logger</code> monad.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>globToRegex cs <span class="ot">=</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    globToRegex&#39; cs <span class="op">&gt;&gt;=</span> \ds <span class="ot">-&gt;</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="ch">&#39;^&#39;</span><span class="op">:</span>ds)</span></code></pre></div>
</div>
<p>There are a few coding style issues worth mentioning here. The body
of the function starts on the line after its name. By doing this, we
gain some horizontal white space. We've also "hung" the parameter of the
anonymous function at the end of the line. This is common practice in
monadic code.</p>
<p>Remember the type of <code>(&gt;&gt;=)</code>: it extracts the value
on the left from its <code>Logger</code> wrapper, and passes the
unwrapped value to the function on the right. The function on the right
must, in turn, wrap <em>its</em> result with the <code>Logger</code>
wrapper. This is exactly what <code>return</code> does: it takes a pure
value, and wraps it in the monad's type constructor.</p>
<pre class="screen"><code>ghci&gt; :type (&gt;&gt;=)
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
ghci&gt; :type (globToRegex &quot;&quot; &gt;&gt;=)
(globToRegex &quot;&quot; &gt;&gt;=) :: (String -&gt; Logger b) -&gt; Logger b
</code></pre>
<p>Even when we write a function that does almost nothing, we must call
<code>return</code> to wrap the result with the correct type.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">globToRegex&#39; ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span> <span class="dt">String</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; <span class="st">&quot;&quot;</span> <span class="ot">=</span> <span class="fu">return</span> <span class="st">&quot;$&quot;</span></span></code></pre></div>
</div>
<p>When we call <code>record</code> to save a log entry, we use
<code>(&gt;&gt;)</code> instead of <code>(&gt;&gt;=)</code> to chain it
with the following action.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; (<span class="ch">&#39;?&#39;</span><span class="op">:</span>cs) <span class="ot">=</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    record <span class="st">&quot;any&quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    globToRegex&#39; cs <span class="op">&gt;&gt;=</span> \ds <span class="ot">-&gt;</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="ch">&#39;.&#39;</span><span class="op">:</span>ds)</span></code></pre></div>
</div>
<p>Recall that this is a variant of <code>(&gt;&gt;=)</code> that
ignores the result on the left. We know that the result of
<code>record</code> will always be <code>()</code>, so there's no point
in capturing it.</p>
<p>We can use <code>do</code> notation, which we first encountered in <a
href="7-io.org::*Sequencing">the section called "Sequencing"</a></p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; (<span class="ch">&#39;*&#39;</span><span class="op">:</span>cs) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>    record <span class="st">&quot;kleene star&quot;</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    ds <span class="ot">&lt;-</span> globToRegex&#39; cs</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="st">&quot;.*&quot;</span> <span class="op">++</span> ds)</span></code></pre></div>
</div>
<p>The choice of <code>do</code> notation versus explicit
<code>(&gt;&gt;=)</code> with anonymous functions is mostly a matter of
taste, though almost everyone's taste is to use <code>do</code> notation
for anything longer than about two lines. There is one significant
difference between the two styles, though, which we'll return to in <a
href="15-monads.org::*Desugaring of do blocks">the section called
"Desugaring of do blocks"</a></p>
<p>Parsing a character class mostly follows the same pattern that we've
already seen.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; (<span class="ch">&#39;[&#39;</span><span class="op">:</span><span class="ch">&#39;!&#39;</span><span class="op">:</span>c<span class="op">:</span>cs) <span class="ot">=</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    record <span class="st">&quot;character class, negative&quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    charClass cs <span class="op">&gt;&gt;=</span> \ds <span class="ot">-&gt;</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="st">&quot;[^&quot;</span> <span class="op">++</span> c <span class="op">:</span> ds)</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; (<span class="ch">&#39;[&#39;</span><span class="op">:</span>c<span class="op">:</span>cs) <span class="ot">=</span></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>    record <span class="st">&quot;character class&quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>    charClass cs <span class="op">&gt;&gt;=</span> \ds <span class="ot">-&gt;</span></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="st">&quot;[&quot;</span> <span class="op">++</span> c <span class="op">:</span> ds)</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; (<span class="ch">&#39;[&#39;</span><span class="op">:</span>_) <span class="ot">=</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> <span class="st">&quot;unterminated character class&quot;</span></span></code></pre></div>
</div>
<h1 data-number="7" id="mixing-pure-and-monadic-code"><span
class="header-section-number">7</span> Mixing pure and monadic code</h1>
<p>Based on the code we've seen so far, monads seem to have a
substantial shortcoming: the type constructor that wraps a monadic value
makes it tricky to use a normal, pure function on a value trapped inside
a monadic wrapper. Here's a simple illustration of the apparent problem.
Let's say we have a trivial piece of code that runs in the
<code>Logger</code> monad and returns a string.</p>
<pre class="screen"><code>ghci&gt; m = return &quot;foo&quot; :: Logger String
</code></pre>
<p>If we want to find out the length of that string, we can't simply
call <code>length</code>: the string is wrapped, so the types don't
match up.</p>
<pre class="screen"><code>ghci&gt; length m

&lt;interactive&gt;:1:7: error:
    • No instance for (Foldable Logger) arising from a use of ‘length’
    • In the expression: length m
      In an equation for ‘it’: it = length m
</code></pre>
<p>What we've done so far to work around this is something like the
following.</p>
<pre class="screen"><code>ghci&gt; :type m &gt;&gt;= \s -&gt; return (length s)
m &gt;&gt;= \s -&gt; return (length s) :: Logger Int
</code></pre>
<p>We use <code>(&gt;&gt;=)</code> to unwrap the string, then write a
small anonymous function that calls <code>length</code> and rewraps the
result using <code>return</code>.</p>
<p>This need crops up often in Haskell code. We won't be surprised to
learn that a shorthand already exists: we use the <em>lifting</em>
technique that we introduced for functors in <a
href="10-parsing-a-binary-data-format.org::*Introducing functors">the
section called "Introducing functors"</a> into a functor usually
involves unwrapping the value inside the functor, calling the function
on it, and rewrapping the result with the same constructor.</p>
<p>We do exactly the same thing with a monad. Because the
<code>Monad</code> type class already provides the
<code>(&gt;&gt;=)</code> and <code>return</code> functions that know how
to unwrap and wrap a value, the <code>liftM</code> function doesn't need
to know any details of a monad's implementation.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>liftM f m <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> \i <span class="ot">-&gt;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> (f i)</span></code></pre></div>
</div>
<p>When we declare a type to be an instance of the <code>Functor</code>
type class, we have to write our own version of <code>fmap</code>
specially tailored to that type. By contrast, <code>liftM</code> doesn't
need to know anything of a monad's internals, because they're abstracted
by <code>(&gt;&gt;=)</code> and <code>return</code>. We only need to
write it once, with the appropriate type constraint.</p>
<p>The <code>liftM</code> function is predefined for us in the standard
<code>Control.Monad</code> module.</p>
<p>To see how <code>liftM</code> can help readability, we'll compare two
otherwise identical pieces of code. First, the familiar kind that does
not use <code>liftM</code>.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>charClass_wordy (<span class="ch">&#39;]&#39;</span><span class="op">:</span>cs) <span class="ot">=</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    globToRegex&#39; cs <span class="op">&gt;&gt;=</span> \ds <span class="ot">-&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="ch">&#39;]&#39;</span><span class="op">:</span>ds)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>charClass_wordy (c<span class="op">:</span>cs) <span class="ot">=</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    charClass_wordy cs <span class="op">&gt;&gt;=</span> \ds <span class="ot">-&gt;</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (c<span class="op">:</span>ds)</span></code></pre></div>
</div>
<p>Now we can eliminate the <code>(&gt;&gt;=)</code> and anonymous
function cruft with <code>liftM</code>.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>charClass (<span class="ch">&#39;]&#39;</span><span class="op">:</span>cs) <span class="ot">=</span> (<span class="ch">&#39;]&#39;</span><span class="op">:</span>) <span class="ot">`liftM`</span> globToRegex&#39; cs</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>charClass (c<span class="op">:</span>cs) <span class="ot">=</span> (c<span class="op">:</span>) <span class="ot">`liftM`</span> charClass cs</span></code></pre></div>
</div>
<p>As with <code>fmap</code>, we often use <code>liftM</code> in infix
form. An easy way to read such an expression is "apply the pure function
on the left to the result of the monadic action on the right".</p>
<p>The <code>liftM</code> function is so useful that
<code>Control.Monad</code> defines several variants, which combine
longer chains of actions. We can see one in the last clause of our
<code>globToRegex'</code> function.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>globToRegex&#39; (c<span class="op">:</span>cs) <span class="ot">=</span> liftM2 (<span class="op">++</span>) (escape c) (globToRegex&#39; cs)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ot">escape ::</span> <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Logger</span> <span class="dt">String</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>escape c</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> c <span class="ot">`elem`</span> regexChars <span class="ot">=</span> record <span class="st">&quot;escape&quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">return</span> [<span class="ch">&#39;\\&#39;</span>,c]</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> <span class="fu">return</span> [c]</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> regexChars <span class="ot">=</span> <span class="st">&quot;\\+()^$.{}]|&quot;</span></span></code></pre></div>
</div>
<p>The <code>liftM2</code> function that we use above is defined as
follows.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftM2 ::</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m c</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>liftM2 f m1 m2 <span class="ot">=</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    m1 <span class="op">&gt;&gt;=</span> \a <span class="ot">-&gt;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    m2 <span class="op">&gt;&gt;=</span> \b <span class="ot">-&gt;</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (f a b)</span></code></pre></div>
</div>
<p>It executes the first action, then the second, then combines their
results using the pure function <code>f</code>, and wraps that result.
In addition to <code>liftM2</code>, the variants in
<code>Control.Monad</code> go up to <code>liftM5</code>.</p>
<h1 data-number="8" id="putting-a-few-misconceptions-to-rest"><span
class="header-section-number">8</span> Putting a few misconceptions to
rest</h1>
<p>We've now seen enough examples of monads in action to have some feel
for what's going on. Before we continue, there are a few oft-repeated
myths about monads that we're going to address. You're bound to
encounter these assertions "in the wild", so you might as well be
prepared with a few good retorts.</p>
<ul>
<li><em>Monads can be hard to understand.</em> We've already shown that
monads "fall out naturally" from several problems. We've found that the
best key to understanding them is to explain several concrete examples,
then talk about what they have in common.</li>
<li><em>Monads are only useful for I/O and imperative coding.</em> While
we use monads for I/O in Haskell, they're valuable for many other
purposes besides. We've already used them for short-circuiting a chain
of computations, hiding complicated state, and logging. Even so, we've
barely scratched the surface.</li>
<li><em>Monads are unique to Haskell.</em> Haskell is probably the
language that makes the most explicit use of monads, but people write
them in other languages, too, ranging from C++ to OCaml. They happen to
be particularly tractable in Haskell, due to <code>do</code> notation,
the power and inference of the type system, and the language's
syntax.</li>
<li><em>Monads are for controlling the order of evaluation.</em></li>
</ul>
<h1 data-number="9" id="building-the-logger-monad"><span
class="header-section-number">9</span> Building the <code>Logger</code>
monad</h1>
<p>The definition of our <code>Logger</code> type is very simple.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb39"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Logger</span> a <span class="ot">=</span> <span class="dt">Logger</span> {<span class="ot"> execLogger ::</span> (a, <span class="dt">Log</span>) } <span class="kw">deriving</span> <span class="dt">Show</span></span></code></pre></div>
</div>
<p>It's a pair, where the first element is the result of an action, and
the second is a list of messages logged while that action was run.</p>
<p>We've wrapped the tuple in a <code>newtype</code> to make it a
distinct type. The <code>runLogger</code> function extracts the tuple
from its wrapper. The function that we're exporting to execute a logged
action, <code>runLogger</code>, is just a synonym for
<code>execLogger</code>.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>runLogger <span class="ot">=</span> execLogger</span></code></pre></div>
</div>
<p>Our <code>record</code> helper function creates a singleton list of
the message we pass it.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>record s <span class="ot">=</span> <span class="dt">Logger</span> ((), [s])</span></code></pre></div>
</div>
<p>The result of this action is <code>()</code>, so that's the value we
put in the result slot.</p>
<p>Let's begin our <code>Monad</code> instance with <code>return</code>,
which is trivial: it logs nothing, and stores its input in the result
slot of the tuple so it is equal to <code>pure</code>.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb42"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Logger</span> <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Logger</span> <span class="kw">where</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">Logger</span> (a, [])</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Logger</span> <span class="kw">where</span></span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="ot">=</span> <span class="fu">pure</span></span></code></pre></div>
</div>
<p>Slightly more interesting is <code>(&gt;&gt;=)</code>, which is the
heart of the monad. It combines an action and a monadic function to give
a new result and a new log.</p>
<div class="captioned-content">
<div class="caption">
Logger.hs
</div>
<div class="sourceCode" id="cb43"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- (&gt;&gt;=) :: Logger a -&gt; (a -&gt; Logger b) -&gt; Logger b</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="kw">let</span> (a, w) <span class="ot">=</span> execLogger m</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>              n      <span class="ot">=</span> k a</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>              (b, x) <span class="ot">=</span> execLogger n</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> <span class="dt">Logger</span> (b, w <span class="op">++</span> x)</span></code></pre></div>
</div>
<p>Let's spell out explicitly what is going on. We use
<code>runLogger</code> to extract the result <code>a</code> from the
action <code>m</code>, and we pass it to the monadic function
<code>k</code>. We extract the result <code>b</code> from that in turn,
and put it into the result slot of the final action. We concatenate the
logs <code>w</code> and <code>x</code> to give the new log.</p>
<h2 data-number="9.1"
id="sequential-logging-not-sequential-evaluation"><span
class="header-section-number">9.1</span> Sequential logging, not
sequential evaluation</h2>
<p>Our definition of <code>(&gt;&gt;=)</code> ensures that messages
logged on the left will appear in the new log before those on the right.
However, it says nothing about when the values <code>a</code> and
<code>b</code> are evaluated: <code>(&gt;&gt;=)</code> is lazy.</p>
<p>Like most other aspects of a monad's behaviour, strictness is under
the control of the monad's implementor. It is not a constant shared by
all monads. Indeed, some monads come in multiple flavours, each with
different levels of strictness.</p>
<h2 data-number="9.2" id="the-writer-monad"><span
class="header-section-number">9.2</span> The writer monad</h2>
<p>Our <code>Logger</code> monad is a specialised version of the
standard <code>Writer</code> monad, which can be found in the
<code>Control.Monad.Writer</code> module of the <code>mtl</code>
package. We will present a <code>Writer</code> example in <a
href="16-programming-with-monads.org::*Using type classes">the section
called "Using type classes"</a></p>
<h1 data-number="10" id="the-maybe-monad"><span
class="header-section-number">10</span> The Maybe monad</h1>
<p>The <code>Maybe</code> type is very nearly the simplest instance of
<code>Monad</code>. It represents a computation that might not produce a
result.</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> x <span class="ot">=</span> <span class="dt">Just</span> x</span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> x <span class="op">&gt;&gt;=</span> k  <span class="ot">=</span> k x</span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&gt;&gt;=</span> _ <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-11"><a href="#cb44-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> _ <span class="op">&gt;&gt;</span> k   <span class="ot">=</span> k</span>
<span id="cb44-12"><a href="#cb44-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="op">&gt;&gt;</span> _  <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb44-13"><a href="#cb44-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-14"><a href="#cb44-14" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span>        <span class="ot">=</span> <span class="fu">pure</span></span>
<span id="cb44-15"><a href="#cb44-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-16"><a href="#cb44-16" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fail</span> _        <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>When we chain together a number of computations over
<code>Maybe</code> using <code>(&gt;&gt;=)</code> or
<code>(&gt;&gt;)</code>, if any of them returns <code>Nothing</code>,
then we don't evaluate any of the remaining computations.</p>
<p>Note, though, that the chain is not completely short-circuited. Each
<code>(&gt;&gt;=)</code> or <code>(&gt;&gt;)</code> in the chain will
still match a <code>Nothing</code> on its left, and produce a
<code>Nothing</code> on its right, all the way to the end. It's easy to
forget this point: when a computation in the chain fails, the subsequent
production, chaining, and consumption of <code>Nothing</code> values is
cheap at runtime, but it's not free.</p>
<h2 data-number="10.1" id="executing-the-maybe-monad"><span
class="header-section-number">10.1</span> Executing the Maybe monad</h2>
<p>A function suitable for executing the <code>Maybe</code> monad is
<code>maybe</code>. (Remember that "executing" a monad involves
evaluating it and returning a result that's had the monad's type wrapper
removed.)</p>
<div class="captioned-content">
<div class="caption">
Maybe.hs
</div>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="fu">maybe</span><span class="ot"> ::</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a><span class="fu">maybe</span> n _ <span class="dt">Nothing</span>  <span class="ot">=</span> n</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="fu">maybe</span> _ f (<span class="dt">Just</span> x) <span class="ot">=</span> f x</span></code></pre></div>
</div>
<p>Its first parameter is the value to return if the result is
<code>Nothing</code>. The second is a function to apply to a result
wrapped in the <code>Just</code> constructor; the result of that
application is then returned.</p>
<p>Since the <code>Maybe</code> type is so simple, it's about as common
to simply pattern-match on a <code>Maybe</code> value as it is to call
<code>maybe</code>. Each one is more readable in different
circumstances.</p>
<h2 data-number="10.2" id="maybe-at-work"><span
class="header-section-number">10.2</span> Maybe at work</h2>
<p>Here's an example of <code>Maybe</code> in use as a monad. Given a
customer's name, we want to find the billing address of their mobile
phone carrier.</p>
<div class="captioned-content">
<div class="caption">
Carrier.hs
</div>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">PersonName</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">PhoneNumber</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">BillingAddress</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MobileCarrier</span> <span class="ot">=</span> <span class="dt">Honest_Bobs_Phone_Network</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="dt">Morrisas_Marvelous_Mobiles</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>                   <span class="op">|</span> <span class="dt">Petes_Plutocratic_Phones</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a><span class="ot">findCarrierBillingAddress ::</span> <span class="dt">PersonName</span></span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">PersonName</span> <span class="dt">PhoneNumber</span></span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">PhoneNumber</span> <span class="dt">MobileCarrier</span></span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">MobileCarrier</span> <span class="dt">BillingAddress</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a>                          <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">BillingAddress</span></span></code></pre></div>
</div>
<p>Our first version is the dreaded ladder of code marching off the
right of the screen, with many boilerplate <code>case</code>
expressions.</p>
<div class="captioned-content">
<div class="caption">
Carrier.hs
</div>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>variation1 person phoneMap carrierMap addressMap <span class="ot">=</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> M.lookup person phoneMap <span class="kw">of</span></span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> number <span class="ot">-&gt;</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> M.lookup number carrierMap <span class="kw">of</span></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> carrier <span class="ot">-&gt;</span> M.lookup carrier addressMap</span></code></pre></div>
</div>
<p>We can make more sensible use of <code>Maybe</code>'s status as a
monad.</p>
<div class="captioned-content">
<div class="caption">
Carrier.hs
</div>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>variation2 person phoneMap carrierMap addressMap <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>  number <span class="ot">&lt;-</span> M.lookup person phoneMap</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  carrier <span class="ot">&lt;-</span> M.lookup number carrierMap</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>  address <span class="ot">&lt;-</span> M.lookup carrier addressMap</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> address</span></code></pre></div>
</div>
<p>If any of these lookups fails, the definitions of
<code>(&gt;&gt;=)</code> and <code>(&gt;&gt;)</code> mean that the
result of the function as a whole will be <code>Nothing</code>, just as
it was for our first attempt that used <code>case</code> explicitly.</p>
<p>This version is much tidier, but the <code>return</code> isn't
necessary. Stylistically, it makes the code look more regular, and
perhaps more familiar to the eyes of an imperative programmer, but
behaviourally it's redundant. Here's an equivalent piece of code.</p>
<div class="captioned-content">
<div class="caption">
Carrier.hs
</div>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>variation2a person phoneMap carrierMap addressMap <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>  number <span class="ot">&lt;-</span> M.lookup person phoneMap</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>  carrier <span class="ot">&lt;-</span> M.lookup number carrierMap</span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>  M.lookup carrier addressMap</span></code></pre></div>
</div>
<p>When we introduced maps, we mentioned in <a
href="12-barcode-recognition.org::*Partial application awkwardness">the
section called "Partial application awkwardness"</a> signatures of
functions in the <code>Data.Map</code> module often make them awkward to
partially apply. The <code>lookup</code> function is a good example. If
we <code>flip</code> its arguments, we can write the function body as a
one-liner.</p>
<div class="captioned-content">
<div class="caption">
Carrier.hs
</div>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>variation3 person phoneMap carrierMap addressMap <span class="ot">=</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">lookup</span> phoneMap person <span class="op">&gt;&gt;=</span> <span class="fu">lookup</span> carrierMap <span class="op">&gt;&gt;=</span> <span class="fu">lookup</span> addressMap</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> <span class="fu">lookup</span> <span class="ot">=</span> <span class="fu">flip</span> M.lookup</span></code></pre></div>
</div>
<h1 data-number="11" id="the-list-monad"><span
class="header-section-number">11</span> The list monad</h1>
<p>While the <code>Maybe</code> type can represent either no value or
one, there are many situations where we might want to return some number
of results that we do not know in advance. Obviously, a list is well
suited to this purpose. The type of a list suggests that we might be
able to use it as a monad, because its type constructor has one free
variable. And sure enough, we can use a list as a monad.</p>
<p>Rather than simply present the <code>Prelude</code>'s
<code>Monad</code> instance for the list type, let's try to figure out
what an instance <em>ought</em> to look like. This is easy to do: we'll
look at the types of <code>(&gt;&gt;=)</code> and <code>return</code>,
and perform some substitutions, and see if we can use a few familiar
list functions.</p>
<p>The more obvious of the two functions is <code>return</code>. We know
that it takes a type <code>a</code>, and wraps it in a type constructor
<code>m</code> to give the type <code>m a</code>. We also know that the
type constructor here is <code>[]</code>. Substituting this type
constructor for the type variable <code>m</code> gives us the type
<code>[] a</code> (yes, this really is valid notation!), which we can
rewrite in more familiar form as <code>[a]</code>.</p>
<p>We now know that <code>return</code> for lists should have the type
<code>a -&gt; [a]</code>. There are only a few sensible possibilities
for an implementation of this function. It might return the empty list,
a singleton list, or an infinite list. The most appealing behaviour,
based on what we know so far about monads, is the singleton list: it
doesn't throw information away, nor does it repeat it infinitely.</p>
<div class="captioned-content">
<div class="caption">
ListMonad.hs
</div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">returnSingleton ::</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>returnSingleton x <span class="ot">=</span> [x]</span></code></pre></div>
</div>
<p>If we perform the same substitution trick on the type of
<code>(&gt;&gt;=)</code> as we did with <code>return</code>, we discover
that it should have the type
<code>[a] -&gt; (a -&gt; [b]) -&gt; [b]</code>. This seems close to the
type of <code>map</code>.</p>
<pre class="screen"><code>ghci&gt; :type (&gt;&gt;=)
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
ghci&gt; :type map
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
</code></pre>
<p>The ordering of the types in <code>map</code>'s arguments doesn't
match, but that's easy to fix.</p>
<pre class="screen"><code>ghci&gt; :type (&gt;&gt;=)
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
ghci&gt; :type flip map
flip map :: [a] -&gt; (a -&gt; b) -&gt; [b]
</code></pre>
<p>We've still got a problem: the second argument of
<code>flip map</code> has the type <code>a -&gt; b</code>, whereas the
second argument of <code>(&gt;&gt;=)</code> for lists has the type
<code>a -&gt; [b]</code>. What do we do about this?</p>
<p>Let's do a little more substitution and see what happens with the
types. The function <code>flip map</code> can return any type
<code>b</code> as its result. If we substitute <code>[b]</code> for
<code>b</code> in both places where it appears in
<code>flip map</code>'s type signature, its type signature reads as
<code>a -&gt; (a -&gt; [b]) -&gt; [[b]]</code>. In other words, if we
map a function that returns a list over a list, we get a list of lists
back.</p>
<pre class="screen"><code>ghci&gt; flip map [1,2,3] (\a -&gt; [a,a+100])
[[1,101],[2,102],[3,103]]
</code></pre>
<p>Interestingly, we haven't really changed how closely our type
signatures match. The type of <code>(&gt;&gt;=)</code> is
<code>[a] -&gt; (a -&gt; [b]) -&gt; [b]</code>, while that of
<code>flip map</code> when the mapped function returns a list is
<code>[a] -&gt; (a -&gt; [b]) -&gt; [[b]]</code>. There's still a
mismatch in one type term; we've just moved that term from the middle of
the type signature to the end. However, our juggling wasn't in vain: we
now need a function that takes a <code>[[b]]</code> and returns a
<code>[b]</code>, and one readily suggests itself in the form of
<code>concat</code>.</p>
<pre class="screen"><code>ghci&gt; :type concat
:: Foldable t =&gt; t [a] -&gt; [a]
</code></pre>
<p>A list is <code>Foldable</code>, i.e. it supports <code>foldr</code>
so we can interpret the type as <code>[[a]] -&gt; [a]</code>. It suggest
that we should flip the arguments to <code>map</code>, then
<code>concat</code> the results to give a single list.</p>
<pre class="screen"><code>ghci&gt; :type \xs f -&gt; concat (map f xs)
\xs f -&gt; concat (map f xs) :: [a1] -&gt; (a1 -&gt; [a2]) -&gt; [a2]
</code></pre>
<p>This is exactly the definition of <code>(&gt;&gt;=)</code> for
lists.</p>
<div class="captioned-content">
<div class="caption">
ListMonad.hs
</div>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> [x]</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">map</span> f xs)</span></code></pre></div>
</div>
<p>It applies <code>f</code> to every element in the list
<code>xs</code>, and concatenates the results to return a single
list.</p>
<p>With our two core <code>Monad</code> definitions in hand, the
implementations of the non-core definitions that remain,
<code>(&gt;&gt;)</code> and <code>fail</code>, ought to be obvious.</p>
<div class="captioned-content">
<div class="caption">
ListMonad.hs
</div>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>xs <span class="op">&gt;&gt;</span> f <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">map</span> (\_ <span class="ot">-&gt;</span> f) xs)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fail</span> _ <span class="ot">=</span> []</span></code></pre></div>
</div>
<h2 data-number="11.1" id="understanding-the-list-monad"><span
class="header-section-number">11.1</span> Understanding the list
monad</h2>
<p>The list monad is similar to a familiar Haskell tool, the list
comprehension. We can illustrate this similarity by computing the
Cartesian product of two lists. First, we'll write a list
comprehension.</p>
<div class="captioned-content">
<div class="caption">
CartesianProduct.hs
</div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>comprehensive xs ys <span class="ot">=</span> [(x,y) <span class="op">|</span> x <span class="ot">&lt;-</span> xs, y <span class="ot">&lt;-</span> ys]</span></code></pre></div>
</div>
<p>For once, we'll use bracketed notation for the monadic code instead
of layout notation. This will highlight how structurally similar the
monadic code is to the list comprehension.</p>
<div class="captioned-content">
<div class="caption">
CartesianProduct.hs
</div>
<div class="sourceCode" id="cb60"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>monadic xs ys <span class="ot">=</span> <span class="kw">do</span> { x <span class="ot">&lt;-</span> xs; y <span class="ot">&lt;-</span> ys; <span class="fu">return</span> (x,y) }</span></code></pre></div>
</div>
<p>The only real difference is that the value we're constructing comes
at the end of the sequence of expressions, instead of the beginning as
in the list comprehension. Also, the results of the two functions are
identical.</p>
<pre class="screen"><code>ghci&gt; comprehensive [1,2] &quot;bar&quot;
[(1,&#39;b&#39;),(1,&#39;a&#39;),(1,&#39;r&#39;),(2,&#39;b&#39;),(2,&#39;a&#39;),(2,&#39;r&#39;)]
ghci&gt; comprehensive [1,2] &quot;bar&quot; == monadic [1,2] &quot;bar&quot;
True
</code></pre>
<p>It's easy to be baffled by the list monad early on, so let's walk
through our monadic Cartesian product code again in more detail. This
time, we'll rearrange the function to use layout instead of
brackets.</p>
<div class="captioned-content">
<div class="caption">
CartesianProduct.hs
</div>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>blockyDo xs ys <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a>    x <span class="ot">&lt;-</span> xs</span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>    y <span class="ot">&lt;-</span> ys</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (x, y)</span></code></pre></div>
</div>
<p>For every element in the list <code>xs</code>, the rest of the
function is evaluated once, with <code>x</code> bound to a different
value from the list each time. Then for every element in the list
<code>ys</code>, the remainder of the function is evaluated once, with
<code>y</code> bound to a different value from the list each time.</p>
<p>What we really have here is a doubly nested loop! This highlights an
important fact about monads: you <em>cannot</em> predict how a block of
monadic code will behave unless you know what monad it will execute
in.</p>
<p>We'll now walk through the code even more explicitly, but first let's
get rid of the <code>do</code> notation, to make the underlying
structure clearer. We've indented the code a little unusually to make
the loop nesting more obvious.</p>
<div class="captioned-content">
<div class="caption">
CartesianProduct.hs
</div>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>blockyPlain xs ys <span class="ot">=</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">&gt;&gt;=</span></span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a>    \x <span class="ot">-&gt;</span> ys <span class="op">&gt;&gt;=</span></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>    \y <span class="ot">-&gt;</span> <span class="fu">return</span> (x, y)</span>
<span id="cb63-5"><a href="#cb63-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-6"><a href="#cb63-6" aria-hidden="true" tabindex="-1"></a>blockyPlain_reloaded xs ys <span class="ot">=</span></span>
<span id="cb63-7"><a href="#cb63-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">concat</span> (<span class="fu">map</span> (\x <span class="ot">-&gt;</span></span>
<span id="cb63-8"><a href="#cb63-8" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">concat</span> (<span class="fu">map</span> (\y <span class="ot">-&gt;</span></span>
<span id="cb63-9"><a href="#cb63-9" aria-hidden="true" tabindex="-1"></a>                              <span class="fu">return</span> (x, y))</span>
<span id="cb63-10"><a href="#cb63-10" aria-hidden="true" tabindex="-1"></a>                         ys))</span>
<span id="cb63-11"><a href="#cb63-11" aria-hidden="true" tabindex="-1"></a>            xs)</span></code></pre></div>
</div>
<p>If <code>xs</code> has the value <code>[1,2,3]</code>, the two lines
that follow are evaluated with <code>x</code> bound to <code>1</code>,
then to <code>2</code>, and finally to <code>3</code>. If
<code>ys</code> has the value <code>[True, False]</code>, the final line
is evaluated <em>six</em> times: once with <code>x</code> as
<code>1</code> and <code>y</code> as <code>True</code>; again with
<code>x</code> as <code>1</code> and <code>y</code> as
<code>False</code>; and so on. The <code>return</code> expression wraps
each tuple in a single-element list.</p>
<h2 data-number="11.2" id="putting-the-list-monad-to-work"><span
class="header-section-number">11.2</span> Putting the list monad to
work</h2>
<p>Here is a simple brute force constraint solver. Given an integer, it
finds all pairs of positive integers that, when multiplied, give that
value (this is the constraint being solved).</p>
<div class="captioned-content">
<div class="caption">
MultiplyTo.hs
</div>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">guarded ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>guarded <span class="dt">True</span>  xs <span class="ot">=</span> xs</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>guarded <span class="dt">False</span> _  <span class="ot">=</span> []</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a><span class="ot">multiplyTo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>multiplyTo n <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>  x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>n]</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> [x<span class="op">..</span>n]</span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>  guarded (x <span class="op">*</span> y <span class="op">==</span> n) <span class="op">$</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (x, y)</span></code></pre></div>
</div>
<p>Let's try this in <code>ghci</code>.</p>
<pre class="screen"><code>ghci&gt; multiplyTo 8
[(1,8),(2,4)]
ghci&gt; multiplyTo 100
[(1,100),(2,50),(4,25),(5,20),(10,10)]
ghci&gt; multiplyTo 891
[(1,891),(3,297),(9,99),(11,81),(27,33)]
</code></pre>
<h1 data-number="12" id="desugaring-of-do-blocks"><span
class="header-section-number">12</span> Desugaring of do blocks</h1>
<p>Haskell's <code>do</code> syntax is an example of <em>syntactic
sugar</em>: it provides an alternative way of writing monadic code,
without using <code>(&gt;&gt;=)</code> and anonymous functions.
<em>Desugaring</em> is the translation of syntactic sugar back to the
core language.</p>
<p>The rules for desugaring a <code>do</code> block are easy to follow.
We can think of a compiler as applying these rules mechanically and
repeatedly to a <code>do</code> block until no more <code>do</code>
keywords remain.</p>
<p>A <code>do</code> keyword followed by a single action is translated
to that action by itself.</p>
<table>
<tbody>
<tr class="odd">
<td>#+BEGIN<sub>SRC</sub> haskell</td>
<td>#+BEGIN<sub>SRC</sub> haskell</td>
</tr>
<tr class="even">
<td>doNotation1 =</td>
<td>translated1 =</td>
</tr>
<tr class="odd">
<td>do act</td>
<td>act</td>
</tr>
<tr class="even">
<td>#+END<sub>SRC</sub></td>
<td>#+END<sub>SRC</sub></td>
</tr>
</tbody>
</table>
<p>A <code>do</code> keyword followed by more than one action is
translated to the first action, then <code>(&gt;&gt;)</code>, followed
by a <code>do</code> keyword and the remaining actions. When we apply
this rule repeatedly, the entire <code>do</code> block ends up chained
together by applications of <code>(&gt;&gt;)</code>.</p>
<table>
<tbody>
<tr class="odd">
<td>#+BEGIN<sub>SRC</sub> haskell</td>
<td>#+BEGIN<sub>SRC</sub> haskell</td>
</tr>
<tr class="even">
<td>doNotation2 =</td>
<td>translated2 =</td>
</tr>
<tr class="odd">
<td>do act1</td>
<td>act1 &gt;&gt;</td>
</tr>
<tr class="even">
<td>act2</td>
<td>do act2</td>
</tr>
<tr class="odd">
<td>{- … etc. -}</td>
<td>{- … etc. -}</td>
</tr>
<tr class="even">
<td>actN</td>
<td>actN</td>
</tr>
<tr class="odd">
<td>#+END<sub>SRC</sub></td>
<td></td>
</tr>
<tr class="even">
<td></td>
<td>finalTranslation2 =</td>
</tr>
<tr class="odd">
<td></td>
<td>act1 &gt;&gt;</td>
</tr>
<tr class="even">
<td></td>
<td>act2 &gt;&gt;</td>
</tr>
<tr class="odd">
<td></td>
<td>{- … etc. -}</td>
</tr>
<tr class="even">
<td></td>
<td>actN</td>
</tr>
<tr class="odd">
<td></td>
<td>#+END<sub>SRC</sub></td>
</tr>
</tbody>
</table>
<p>The <code>&lt;-</code> notation has a translation that's worth paying
close attention to. On the left of the <code>&lt;-</code> is a normal
Haskell pattern. This can be a single variable or something more
complicated. A guard expression is not allowed.</p>
<table>
<tbody>
<tr class="odd">
<td>#+BEGIN<sub>SRC</sub> haskell</td>
<td>#+BEGIN<sub>SRC</sub> haskell</td>
</tr>
<tr class="even">
<td>doNotation3 =</td>
<td>translated3 =</td>
</tr>
<tr class="odd">
<td>do pattern &lt;- act1</td>
<td>let f pattern = do act2</td>
</tr>
<tr class="even">
<td>act2</td>
<td>{- … etc. -}</td>
</tr>
<tr class="odd">
<td>{- … etc. -}</td>
<td>actN</td>
</tr>
<tr class="even">
<td>actN</td>
<td>f _ = fail "…"</td>
</tr>
<tr class="odd">
<td>#+END<sub>SRC</sub></td>
<td>in act1 &gt;&gt;= f</td>
</tr>
<tr class="even">
<td></td>
<td>#+END<sub>SRC</sub></td>
</tr>
</tbody>
</table>
<p>This pattern is translated into a <code>let</code> binding that
declares a local function with a unique name (we're just using
<code>f</code> as an example above). The action on the right of the
<code>&lt;-</code> is then chained with this function using
<code>(&gt;&gt;=)</code>.</p>
<p>What's noteworthy about this translation is that if the pattern match
fails, the local function calls the monad's <code>fail</code>
implementation. Here's an example using the <code>Maybe</code>
monad.</p>
<div class="captioned-content">
<div class="caption">
Do.hs
</div>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">robust ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>robust xs <span class="ot">=</span> <span class="kw">do</span> (_<span class="op">:</span>x<span class="op">:</span>_) <span class="ot">&lt;-</span> <span class="dt">Just</span> xs</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>               <span class="fu">return</span> x</span></code></pre></div>
</div>
<p>The <code>fail</code> implementation in the <code>Maybe</code> monad
simply returns <code>Nothing</code>. If the pattern match in the above
function fails, we thus get <code>Nothing</code> as our result.</p>
<pre class="screen"><code>ghci&gt; robust [1,2,3]
Just 2
ghci&gt; robust [1]
Nothing
</code></pre>
<p>Finally, when we write a <code>let</code> expression in a
<code>do</code> block, we can omit the usual <code>in</code> keyword.
Subsequent actions in the block must be lined up with the
<code>let</code> keyword.</p>
<table>
<tbody>
<tr class="odd">
<td>#+BEGIN<sub>SRC</sub> haskell</td>
<td>#+BEGIN<sub>SRC</sub> haskell</td>
</tr>
<tr class="even">
<td>doNotation4 =</td>
<td>translated4 =</td>
</tr>
<tr class="odd">
<td>do let val1 = expr1</td>
<td>let val1 = expr1</td>
</tr>
<tr class="even">
<td>val2 = expr2</td>
<td>val2 = expr2</td>
</tr>
<tr class="odd">
<td>{- … etc. -}</td>
<td>valN = exprN</td>
</tr>
<tr class="even">
<td>valN = exprN</td>
<td>in do act1</td>
</tr>
<tr class="odd">
<td>act1</td>
<td>act2</td>
</tr>
<tr class="even">
<td>act2</td>
<td>{- … etc. -}</td>
</tr>
<tr class="odd">
<td>{- … etc. -}</td>
<td>actN</td>
</tr>
<tr class="even">
<td>actN</td>
<td>#+END<sub>SRC</sub></td>
</tr>
<tr class="odd">
<td>#+END<sub>SRC</sub></td>
<td></td>
</tr>
</tbody>
</table>
<h2 data-number="12.1" id="monads-as-a-programmable-semicolon"><span
class="header-section-number">12.1</span> Monads as a programmable
semicolon</h2>
<p>Back in <a
href="3-defining-types-streamlining-functions.org::*The offside rule is not mandatory">the
section called "The offside rule is not mandatory"</a> mentioned that
layout is the norm in Haskell, but it's not <em>required</em>. We can
write a <code>do</code> block using explicit structure instead of
layout.</p>
<table>
<tbody>
<tr class="odd">
<td>#+BEGIN<sub>SRC</sub> haskell</td>
<td>#+BEGIN<sub>SRC</sub> haskell</td>
</tr>
<tr class="even">
<td>semicolon = do</td>
<td>semicolonTranslated =</td>
</tr>
<tr class="odd">
<td>{</td>
<td>act1 &gt;&gt;</td>
</tr>
<tr class="even">
<td>act1;</td>
<td>let f val1 = let val2 = expr1</td>
</tr>
<tr class="odd">
<td>val1 &lt;- act2;</td>
<td>in actN</td>
</tr>
<tr class="even">
<td>let { val2 = expr1 };</td>
<td>f _ = fail "…"</td>
</tr>
<tr class="odd">
<td>actN;</td>
<td>in act2 &gt;&gt;= f</td>
</tr>
<tr class="even">
<td>}</td>
<td>#+END<sub>SRC</sub></td>
</tr>
<tr class="odd">
<td>#+END<sub>SRC</sub></td>
<td></td>
</tr>
</tbody>
</table>
<p>Even though this use of explicit structure is rare, the fact that it
uses semicolons to separate expressions has given rise to an apt slogan:
monads are a kind of "programmable semicolon", because the behaviours of
<code>(&gt;&gt;)</code> and <code>(&gt;&gt;=)</code> are different in
each monad.</p>
<h2 data-number="12.2" id="why-go-sugar-free"><span
class="header-section-number">12.2</span> Why go sugar-free?</h2>
<p>When we write <code>(&gt;&gt;=)</code> explicitly in our code, it
reminds us that we're stitching functions together using combinators,
not simply sequencing actions.</p>
<p>As long as you feel like a novice with monads, we think you should
prefer to explicitly write <code>(&gt;&gt;=)</code> over the syntactic
sugar of <code>do</code> notation. The repeated reinforcement of what's
really happening seems, for many programmers, to help to keep things
clear. (It can be easy for an imperative programmer to relax a little
too much from exposure to the <code>IO</code> monad, and assume that a
<code>do</code> block means nothing more than a simple sequence of
actions.)</p>
<p>Once you're feeling more familiar with monads, you can choose
whichever style seems more appropriate for writing a particular
function. Indeed, when you read other people's monadic code, you'll see
that it's unusual, but by no means rare, to mix <em>both</em>
<code>do</code> notation and <code>(&gt;&gt;=)</code> in a single
function.</p>
<p>The <code>(=&lt;&lt;)</code> function shows up frequently whether or
not we use <code>do</code> notation. It is a flipped version of
<code>(&gt;&gt;=)</code>.</p>
<pre class="screen"><code>ghci&gt; :type (&gt;&gt;=)
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
ghci&gt; :type (=&lt;&lt;)
(=&lt;&lt;) :: Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</code></pre>
<p>It comes in handy if we want to compose monadic functions in the
usual Haskell right-to-left style.</p>
<div class="captioned-content">
<div class="caption">
CartesianProduct.hs
</div>
<div class="sourceCode" id="cb69"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>wordCount <span class="ot">=</span> <span class="fu">print</span> <span class="op">.</span> <span class="fu">length</span> <span class="op">.</span> <span class="fu">words</span> <span class="op">=&lt;&lt;</span> <span class="fu">getContents</span></span></code></pre></div>
</div>
<h1 data-number="13" id="the-state-monad"><span
class="header-section-number">13</span> The state monad</h1>
<p>We discovered earlier in this chapter that the <code>Parse</code>
from <a href="10-parsing-a-binary-data-format.org">Chapter 10, <em>Code
case study: parsing a binary data format</em></a> was a monad. It has
two logically distinct aspects. One is the idea of a parse failing, and
providing a message with the details: we represented this using the
<code>Either</code> type. The other involves carrying around a piece of
implicit state, in our case the partially consumed
<code>ByteString</code>.</p>
<p>This need for a way to read and write state is common enough in
Haskell programs that the standard libraries provide a monad named
<code>State</code> that is dedicated to this purpose. This monad lives
in the <code>Control.Monad.State</code> module.</p>
<p>Where our <code>Parse</code> type carried around a
<code>ByteString</code> as its piece of state, the <code>State</code>
monad can carry any type of state. We'll refer to the state's unknown
type as <code>s</code>.</p>
<p>What's an obvious and general thing we might want to do with a state?
Given a state value, we inspect it, then produce a result and a new
state value. Let's say the result can be of any type <code>a</code>. A
type signature that captures this idea is <code>s -&gt; (a, s)</code>:
take a state <code>s</code>, do something with it, and return a result
<code>a</code> and possibly a new state <code>s</code>.</p>
<h2 data-number="13.1" id="almost-a-state-monad"><span
class="header-section-number">13.1</span> Almost a state monad</h2>
<p>Let's develop some simple code that's <em>almost</em> the
<code>State</code> monad, then we'll take a look at the real thing.
We'll start with our type definition, which has exactly the obvious type
we described above.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb70"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">SimpleState</span> s a <span class="ot">=</span> s <span class="ot">-&gt;</span> (a, s)</span></code></pre></div>
</div>
<p>Our monad is a function that transforms one state into another,
yielding a result when it does so. Because of this, the
<code>State</code> monad is sometimes called the <em>state transformer
monad</em>.</p>
<p>Yes, this is a type synonym, not a new type, and so we're cheating a
little. Bear with us for now; this simplifies the description that
follows.</p>
<p>Earlier in this chapter, we said that a monad has a type constructor
with a single type variable, and yet here we have a type with two
parameters. The key here is to understand that we can partially apply a
<em>type</em> just as we can partially apply a normal function. This is
easiest to follow with an example.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">StringState</span> a <span class="ot">=</span> <span class="dt">SimpleState</span> <span class="dt">String</span> a</span></code></pre></div>
</div>
<p>Here, we've bound the type variable <code>s</code> to
<code>String</code>. The type <code>StringState</code> still has a type
parameter <code>a</code>, though. It's now more obvious that we have a
suitable type constructor for a monad. In other words, our monad's type
constructor is <code>SimpleState s</code>, not <code>SimpleState</code>
alone.</p>
<p>The next ingredient we need to make a monad is a definition for the
<code>return</code> function.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb72"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">returnSt ::</span> a <span class="ot">-&gt;</span> <span class="dt">SimpleState</span> s a</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>returnSt a <span class="ot">=</span> \s <span class="ot">-&gt;</span> (a, s)</span></code></pre></div>
</div>
<p>All this does is take the result and the current state, and "tuple
them up". You may by now be used to the idea that a Haskell function
with multiple parameters is just a chain of single-parameter functions,
but just in case you're not, here's a more familiar way of writing
<code>returnSt</code> that makes it more obvious how simple this
function is.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb73"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a><span class="ot">returnAlt ::</span> a <span class="ot">-&gt;</span> <span class="dt">SimpleState</span> s a</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>returnAlt a s <span class="ot">=</span> (a, s)</span></code></pre></div>
</div>
<p>Our final piece of the monadic puzzle is a definition for
<code>(&gt;&gt;=)</code>. Here it is, using the actual variable names
from the standard library's definition of <code>(&gt;&gt;=)</code> for
<code>State</code>.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb74"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bindSt ::</span> (<span class="dt">SimpleState</span> s a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">SimpleState</span> s b) <span class="ot">-&gt;</span> <span class="dt">SimpleState</span> s b</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>bindSt m k <span class="ot">=</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> m s</span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>                   <span class="kw">in</span> (k a) s&#39;</span></code></pre></div>
</div>
<p>Those single-letter variable names aren't exactly a boon to
readability, so let's see if we can substitute some more meaningful
names.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb75"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- m == step</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a><span class="co">-- k == makeStep</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a><span class="co">-- s == oldState</span></span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a>bindAlt step makeStep oldState <span class="ot">=</span></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> (result, newState) <span class="ot">=</span> step oldState</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span>  (makeStep result) newState</span></code></pre></div>
</div>
<p>To understand this definition, remember that <code>step</code> is a
function with the type <code>s -&gt; (a, s)</code>. When we evaluate
this, we get a tuple, and we have to use this to return a new function
of type <code>s -&gt; (a, s)</code>. This is perhaps easier to follow if
we get rid of the <code>SimpleState</code> type synonyms from
<code>bindAlt</code>'s type signature, and examine the types of its
parameters and result.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb76"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bindAlt ::</span> (s <span class="ot">-&gt;</span> (a, s))        <span class="co">-- step</span></span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (b, s))   <span class="co">-- makeStep</span></span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a>        <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> (b, s))        <span class="co">-- (makeStep result) newState</span></span></code></pre></div>
</div>
<h2 data-number="13.2" id="reading-and-modifying-the-state"><span
class="header-section-number">13.2</span> Reading and modifying the
state</h2>
<p>The definitions of <code>(&gt;&gt;=)</code> and <code>return</code>
for the <code>State</code> monad simply act as plumbing: they move a
piece of state around, but they don't touch it in any way. We need a few
other simple functions to actually do useful work with the state.</p>
<div class="captioned-content">
<div class="caption">
SimpleState.hs
</div>
<div class="sourceCode" id="cb77"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getSt ::</span> <span class="dt">SimpleState</span> s s</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>getSt <span class="ot">=</span> \s <span class="ot">-&gt;</span> (s, s)</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="ot">putSt ::</span> s <span class="ot">-&gt;</span> <span class="dt">SimpleState</span> s ()</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a>putSt s <span class="ot">=</span> \_ <span class="ot">-&gt;</span> ((), s)</span></code></pre></div>
</div>
<p>The <code>getSt</code> function simply takes the current state and
returns it as the result, while <code>putSt</code> ignores the current
state and replaces it with a new state.</p>
<h2 data-number="13.3"
id="will-the-real-state-monad-please-stand-up"><span
class="header-section-number">13.3</span> Will the real state monad
please stand up?</h2>
<p>The only simplifying trick we played in the previous section was to
use a type synonym instead of a type definition for
<code>SimpleState</code>. If we had introduced a <code>newtype</code>
wrapper at the same time, the extra wrapping and unwrapping would have
made our code harder to follow.</p>
<p>In order to define a <code>Monad</code> instance, we have to provide
a proper type constructor as well as definitions for
<code>(&gt;&gt;=)</code> and <code>return</code>. This leads us to the
following definition of <code>State</code>.</p>
<div class="captioned-content">
<div class="caption">
State.hs
</div>
<div class="sourceCode" id="cb78"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> {</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    runState ::</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<p>All we've done is wrap our <code>s -&gt; (a, s)</code> type in a
<code>State</code> constructor. By using Haskell's record syntax to
define the type, we're automatically given a <code>runState</code>
function that will unwrap a <code>State</code> value from its
constructor. The type of <code>runState</code> is
<code>State s a -&gt; s -&gt; (a, s)</code>.</p>
<p>The definition of <code>return</code> is almost the same as for
<code>SimpleState</code>, except we wrap our function with a
<code>State</code> constructor.</p>
<div class="captioned-content">
<div class="caption">
State.hs
</div>
<div class="sourceCode" id="cb79"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a><span class="ot">returnState ::</span> a <span class="ot">-&gt;</span> <span class="dt">State</span> s a</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>returnState a <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (a, s)</span></code></pre></div>
</div>
<p>The definition of <code>(&gt;&gt;=)</code> is a little more
complicated, because it has to use <code>runState</code> to remove the
<code>State</code> wrappers.</p>
<div class="captioned-content">
<div class="caption">
State.hs
</div>
<div class="sourceCode" id="cb80"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bindState ::</span> <span class="dt">State</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">State</span> s b) <span class="ot">-&gt;</span> <span class="dt">State</span> s b</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>bindState m k <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> <span class="kw">let</span> (a, s&#39;) <span class="ot">=</span> runState m s</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>                              <span class="kw">in</span> runState (k a) s&#39;</span></code></pre></div>
</div>
<p>This function differs from our earlier <code>bindSt</code> only in
adding the wrapping and unwrapping of a few values. By separating the
"real work" from the bookkeeping, we've hopefully made it clearer what's
really happening.</p>
<p>We modify the functions for reading and modifying the state in the
same way, by adding a little wrapping.</p>
<div class="captioned-content">
<div class="caption">
State.hs
</div>
<div class="sourceCode" id="cb81"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a><span class="ot">get ::</span> <span class="dt">State</span> s s</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>get <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \s <span class="ot">-&gt;</span> (s, s)</span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a><span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">State</span> s ()</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>put s <span class="ot">=</span> <span class="dt">State</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> ((), s)</span></code></pre></div>
</div>
<h2 data-number="13.4"
id="using-the-state-monad-generating-random-values"><span
class="header-section-number">13.4</span> Using the <code>State</code>
monad: generating random values</h2>
<p>We've already used <code>Parse</code>, our precursor to the
<code>State</code> monad, to parse binary data. In that case, we wired
the type of the state we were manipulating directly into the
<code>Parse</code> type.</p>
<p>The <code>State</code> monad, by contrast, accepts any type of state
as a parameter. We supply the type of the state, to give e.g.
<code>State</code> <code>ByteString</code>.</p>
<p>The <code>State</code> monad will probably feel more familiar to you
than many other monads if you have a background in imperative languages.
After all, imperative languages are all about carrying around some
implicit state, reading some parts, and modifying others through
assignment, and this is just what the <code>State</code> monad is
for.</p>
<p>So instead of unnecessarily cheerleading for the idea of using the
<code>State</code> monad, we'll begin by demonstrating how to use it for
something simple: pseudorandom value generation. In an imperative
language, there's usually an easily available source of uniformly
distributed pseudorandom numbers. For example, in C, there's a standard
<code>rand</code> function that generates a pseudorandom number, using a
global state that it updates.</p>
<p>Haskell's standard random value generation module is named
<code>System.Random</code> and is located in the <code>random</code>
package. It allows the generation of random values of any type, not just
numbers. The module contains several handy functions that live in the
<code>IO</code> monad. For example, a rough equivalent of C's
<code>rand</code> function would be the following:</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb82"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a><span class="ot">rand ::</span> <span class="dt">IO</span> <span class="dt">Int</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>rand <span class="ot">=</span> getStdRandom (randomR (<span class="dv">0</span>, <span class="fu">maxBound</span>))</span></code></pre></div>
</div>
<p>(The <code>randomR</code> function takes an inclusive range within
which the generated random value should lie.)</p>
<p>The <code>System.Random</code> module provides a type class,
<code>RandomGen</code>, that lets us define new sources of random
<code>Int</code> values. The type <code>StdGen</code> is the standard
<code>RandomGen</code> instance. It generates pseudorandom values. If we
had an external source of truly random data, we could make it an
instance of <code>RandomGen</code> and get truly random, instead of
merely pseudorandom, values.</p>
<p>Another type class, <code>Random</code>, indicates how to generate
random values of a particular type. The module defines
<code>Random</code> instances for all of the usual simple types.</p>
<p>Incidentally, the definition of <code>rand</code> above reads and
modifies a built-in global random generator that inhabits the
<code>IO</code> monad.</p>
<h2 data-number="13.5" id="a-first-attempt-at-purity"><span
class="header-section-number">13.5</span> A first attempt at purity</h2>
<p>After all of our emphasis so far on avoiding the <code>IO</code>
monad wherever possible, it would be a shame if we were dragged back
into it just to generate some random values. Indeed,
<code>System.Random</code> contains pure random number generation
functions.</p>
<p>The traditional downside of purity is that we have to get or create a
random number generator, then ship it from the point we created it to
the place where it's needed. When we finally call it, it returns a
<em>new</em> random number generator: we're in pure code, remember, so
we can't modify the state of the existing generator.</p>
<p>If we forget about immutability and reuse the same generator within a
function, we get back exactly the same "random" number every time.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb83"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twoBadRandoms ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>twoBadRandoms gen <span class="ot">=</span> (<span class="fu">fst</span> <span class="op">$</span> random gen, <span class="fu">fst</span> <span class="op">$</span> random gen)</span></code></pre></div>
</div>
<p>Needless to say, this has unpleasant consequences.</p>
<pre class="screen"><code>ghci&gt; twoBadRandoms `fmap` getStdGen
(945769311181683171,945769311181683171)
</code></pre>
<p>The <code>random</code> function uses an implicit range instead of
the user-supplied range used by <code>randomR</code>. The
<code>getStdGen</code> function retrieves the current value of the
global standard number generator from the <code>IO</code> monad.</p>
<p>Unfortunately, correctly passing around and using successive versions
of the generator does not make for palatable reading. Here's a simple
example.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb85"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a><span class="ot">twoGoodRandoms ::</span> <span class="dt">RandomGen</span> g <span class="ot">=&gt;</span> g <span class="ot">-&gt;</span> ((<span class="dt">Int</span>, <span class="dt">Int</span>), g)</span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>twoGoodRandoms gen <span class="ot">=</span> <span class="kw">let</span> (a, gen&#39;) <span class="ot">=</span> random gen</span>
<span id="cb85-3"><a href="#cb85-3" aria-hidden="true" tabindex="-1"></a>                         (b, gen&#39;&#39;) <span class="ot">=</span> random gen&#39;</span>
<span id="cb85-4"><a href="#cb85-4" aria-hidden="true" tabindex="-1"></a>                     <span class="kw">in</span> ((a, b), gen&#39;&#39;)</span></code></pre></div>
</div>
<p>Now that we know about the <code>State</code> monad, though, it looks
like a fine candidate to hide the generator. The <code>State</code>
monad lets us manage our mutable state tidily, while guaranteeing that
our code will be free of other unexpected side effects, such as
modifying files or making network connections. This makes it easier to
reason about the behavior of our code.</p>
<h2 data-number="13.6" id="random-values-in-the-state-monad"><span
class="header-section-number">13.6</span> Random values in the
<code>State</code> monad</h2>
<p>Here's a state monad that carries around a <code>StdGen</code> as its
piece of state.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb86"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- import Control.Mand.State at the beginning</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">RandomState</span> a <span class="ot">=</span> <span class="dt">State</span> <span class="dt">StdGen</span> a</span></code></pre></div>
</div>
<p>The type synonym is of course not necessary, but it's handy. It saves
a little keyboarding, and if we wanted to swap another random generator
for <code>StdGen</code>, it would reduce the number of type signatures
we'd need to change.</p>
<p>Generating a random value is now a matter of fetching the current
generator, using it, then modifying the state to replace it with the new
generator.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb87"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getRandom ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">RandomState</span> a</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a>getRandom <span class="ot">=</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a>  get <span class="op">&gt;&gt;=</span> \gen <span class="ot">-&gt;</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (val, gen&#39;) <span class="ot">=</span> random gen <span class="kw">in</span></span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a>  put gen&#39; <span class="op">&gt;&gt;</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> val</span></code></pre></div>
</div>
<p>We can now use some of the monadic machinery that we saw earlier to
write a much more concise function for giving us a pair of random
numbers.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb88"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getTwoRandoms ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">RandomState</span> (a, a)</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>getTwoRandoms <span class="ot">=</span> liftM2 (,) getRandom getRandom</span></code></pre></div>
</div>
<ol>
<li><p>Exercises</p>
<ol>
<li>Rewrite <code>getRandom</code> to use do notation.</li>
</ol></li>
</ol>
<h2 data-number="13.7" id="running-the-state-monad"><span
class="header-section-number">13.7</span> Running the state monad</h2>
<p>As we've already mentioned, each monad has its own specialised
evaluation functions. In the case of the <code>State</code> monad, we
have several to choose from.</p>
<ul>
<li><code>runState</code> returns both the result and the final
state.</li>
<li><code>evalState</code> returns only the result, throwing away the
final state.</li>
<li><code>execState</code> throws the result away, returning only the
final state.</li>
</ul>
<p>The <code>evalState</code> and <code>execState</code> functions are
simply compositions of <code>fst</code> and <code>snd</code> with
<code>runState</code>, respectively. Thus, of the three,
<code>runState</code> is the one most worth remembering.</p>
<p>Here's a complete example of how to implement our
<code>getTwoRandoms</code> function.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb89"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runTwoRandoms ::</span> <span class="dt">IO</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>runTwoRandoms <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>  oldState <span class="ot">&lt;-</span> getStdGen</span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (result, newState) <span class="ot">=</span> runState getTwoRandoms oldState</span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>  setStdGen newState</span>
<span id="cb89-6"><a href="#cb89-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> result</span></code></pre></div>
</div>
<p>The call to <code>runState</code> follows a standard pattern: we pass
it a function in the <code>State</code> monad and an initial state. It
returns the result of the function and the final state.</p>
<p>The code surrounding the call to <code>runState</code> merely obtains
the current global <code>StdGen</code> value, then replaces it
afterwards so that subsequent calls to <code>runTwoRandoms</code> or
other random generation functions will pick up the updated state.</p>
<h2 data-number="13.8" id="what-about-a-bit-more-state"><span
class="header-section-number">13.8</span> What about a bit more
state?</h2>
<p>It's a little hard to imagine writing much interesting code in which
there's only a single state value to pass around. When we want to track
multiple pieces of state at once, the usual trick is to maintain them in
a data type. Here's an example: keeping track of the number of random
numbers we are handing out.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb90"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">CountedRandom</span> <span class="ot">=</span> <span class="dt">CountedRandom</span> {</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="ot">      crGen ::</span> <span class="dt">StdGen</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> crCount ::</span> <span class="dt">Int</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">CRState</span> <span class="ot">=</span> <span class="dt">State</span> <span class="dt">CountedRandom</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a><span class="ot">getCountedRandom ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">CRState</span> a</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>getCountedRandom <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>  st <span class="ot">&lt;-</span> get</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> (val, gen&#39;) <span class="ot">=</span> random (crGen st)</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>  put <span class="dt">CountedRandom</span> { crGen <span class="ot">=</span> gen&#39;, crCount <span class="ot">=</span> crCount st <span class="op">+</span> <span class="dv">1</span> }</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> val</span></code></pre></div>
</div>
<p>This example happens to consume both elements of the state, and
construct a completely new state, every time we call into it. More
frequently, we're likely to read or modify only part of a state. This
function gets the number of random values generated so far.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb91"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a><span class="ot">getCount ::</span> <span class="dt">CRState</span> <span class="dt">Int</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>getCount <span class="ot">=</span> crCount <span class="ot">`liftM`</span> get</span></code></pre></div>
</div>
<p>This example illustrates why we used record syntax to define our
<code>CountedRandom</code> state. It gives us accessor functions that we
can glue together with <code>get</code> to read specific pieces of the
state.</p>
<p>If we want to partially update a state, the code doesn't come out
quite so appealingly.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb92"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putCount ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CRState</span> ()</span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>putCount a <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a>  st <span class="ot">&lt;-</span> get</span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>  put st { crCount <span class="ot">=</span> a }</span></code></pre></div>
</div>
<p>Here, instead of a function, we're using record update syntax. The
expression <code>st { crCount ~ a }</code> creates a new value that's an
identical copy of <code>st</code>, except in its <code>crCount</code>
field, which is given the value <code>a</code>. Because this is a
syntactic hack, we don't get the same kind of flexibility as with a
function. Record syntax may not exhibit Haskell's usual elegance, but it
at least gets the job done.</p>
<p>There exists a function named <code>modify</code> that combines the
<code>get</code> and <code>put</code> steps. It takes as argument a
state transformation function, but it's hardly more satisfactory: we
still can't escape from the clumsiness of record update syntax.</p>
<div class="captioned-content">
<div class="caption">
Random.hs
</div>
<div class="sourceCode" id="cb93"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a><span class="ot">putCountModify ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">CRState</span> ()</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>putCountModify a <span class="ot">=</span> modify <span class="op">$</span> \st <span class="ot">-&gt;</span> st { crCount <span class="ot">=</span> a }</span></code></pre></div>
</div>
<h1 data-number="14" id="another-way-of-looking-at-monads"><span
class="header-section-number">14</span> Another way of looking at
monads</h1>
<p>Now that we know enough about monads structure we can look back at
the list monad and see something interesting. Specifically, take a look
at the definition of <code>(&gt;&gt;=)</code> for lists.</p>
<div class="captioned-content">
<div class="caption">
ListMonad.hs
</div>
<div class="sourceCode" id="cb94"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> [] <span class="kw">where</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> x <span class="ot">=</span> [x]</span>
<span id="cb94-3"><a href="#cb94-3" aria-hidden="true" tabindex="-1"></a>    xs <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> <span class="fu">concat</span> (<span class="fu">map</span> f xs)</span></code></pre></div>
</div>
<p>Recall that <code>f</code> has type <code>a -&gt; [a]</code>. When we
call <code>map f xs</code>, we get back a value of type
<code>[[a]]</code>, which we have to "flatten" using
<code>concat</code>.</p>
<p>Since <code>fmap</code> for lists is defined to be <code>map</code>,
we could replace <code>map</code> with <code>fmap</code> in the
definition of <code>(&gt;&gt;=)</code>. This is not very interesting by
itself, but suppose we could go further.</p>
<p>The <code>concat</code> function is of type
<code>[[a]] -&gt; [a]</code>: as we mentioned, it flattens the nesting
of lists. We could generalise this type signature from lists to monads,
giving us the "remove a level of nesting" type
<code>m (m a) -&gt; m a</code>. The function that has this type is
conventionally named <code>join</code>.</p>
<p>If we had definitions of <code>join</code> and <code>fmap</code>, we
wouldn't need to write a definition of <code>(&gt;&gt;=)</code> for
every monad, because it would be completely generic. Here's what an
alternative definition of the <code>Monad</code> type class might look
like, along with a definition of <code>(&gt;&gt;=)</code>.</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> ((&gt;&gt;=), return)</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Applicative</span> m <span class="ot">=&gt;</span> <span class="dt">AltMonad</span> m <span class="kw">where</span></span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a><span class="ot">    join ::</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="ot">    return ::</span> a <span class="ot">-&gt;</span> m a <span class="co">-- Or simply pure</span></span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">AltMonad</span> m <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>xs <span class="op">&gt;&gt;=</span> f <span class="ot">=</span> join (<span class="fu">fmap</span> f xs)</span></code></pre></div>
<p>Neither definition of a monad is "better", since if we have
<code>join</code> we can write <code>(&gt;&gt;=)</code>, and vice versa,
but the different perspectives can be refreshing.</p>
<p>Removing a layer of monadic wrapping can, in fact, be useful in
realistic circumstances. We can find a generic definition of
<code>join</code> in the <code>Control.Monad</code> module.</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a><span class="ot">join ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> m (m a) <span class="ot">-&gt;</span> m a</span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>join x <span class="ot">=</span> x <span class="op">&gt;&gt;=</span> <span class="fu">id</span></span></code></pre></div>
<p>Here are some examples of what it does.</p>
<pre class="screen"><code>ghci&gt; join (Just (Just 1))
Just 1
ghci&gt; join Nothing
Nothing
ghci&gt; join [[1],[2,3]]
[1,2,3]
</code></pre>
<h1 data-number="15" id="the-monad-laws-and-good-coding-style"><span
class="header-section-number">15</span> The monad laws, and good coding
style</h1>
<p>In <a
href="10-parsing-a-binary-data-format.org::*Thinking more about functors">the
section called "Thinking more about functors"</a> introduced two rules
for how functors should always behave.</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> <span class="fu">id</span> <span class="op">==</span> <span class="fu">id</span></span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="fu">fmap</span> (f <span class="op">.</span> g) <span class="op">==</span> <span class="fu">fmap</span> f <span class="op">.</span> <span class="fu">fmap</span> g</span></code></pre></div>
<p>There are also rules for how monads ought to behave. The three laws
below are referred to as the monad laws. A Haskell implementation
doesn't enforce these laws: it's up to the author of a
<code>Monad</code> instance to follow them.</p>
<p>The monad laws are simply formal ways of saying "a monad shouldn't
surprise me". In principle, we could probably get away with skipping
over them entirely. It would be a shame if we did, however, because the
laws contain gems of wisdom that we might otherwise overlook.</p>
<div class="TIP">
<p>Reading the laws</p>
<p>You can read each law below as "the expression on the left of the
<code>==</code> is equivalent to that on the right."</p>
</div>
<p>The first law states that <code>return</code> is a <em>left
identity</em> for <code>(&gt;&gt;=)</code>.</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span> x <span class="op">&gt;&gt;=</span> f <span class="op">==</span> f x</span></code></pre></div>
<p>Another way to phrase this is that there's no reason to use
<code>return</code> to wrap up a pure value if all you're going to do is
unwrap it again with <code>(&gt;&gt;=)</code>. It's actually a common
style error among programmers new to monads to wrap a value with
<code>return</code>, then unwrap it with <code>(&gt;&gt;=)</code> a few
lines later in the same function. Here's the same law written with
<code>do</code> notation.</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> y <span class="ot">&lt;-</span> <span class="fu">return</span> x</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>   f y <span class="op">==</span> f x</span></code></pre></div>
<p>This law has practical consequences for our coding style: we don't
want to write unnecessary code, and the law lets us assume that the
terse code will be identical in its effect to the more verbose
version.</p>
<p>The second monad law states that <code>return</code> is a <em>right
identity</em> for <code>(&gt;&gt;=)</code>.</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> <span class="fu">return</span> <span class="op">==</span> m</span></code></pre></div>
<p>This law also has style consequences in real programs, particularly
if you're coming from an imperative language: there's no need to use
<code>return</code> if the last action in a block would otherwise be
returning the correct result. Let's look at this law in <code>do</code>
notation.</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a><span class="kw">do</span> y <span class="ot">&lt;-</span> m</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>   <span class="fu">return</span> y <span class="op">==</span> m</span></code></pre></div>
<p>Once again, if we assume that a monad obeys this law, we can write
the shorter code in the knowledge that it will have the same effect as
the longer code.</p>
<p>The final law is concerned with associativity.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> (\x <span class="ot">-&gt;</span> f x <span class="op">&gt;&gt;=</span> g) <span class="op">==</span> (m <span class="op">&gt;&gt;=</span> f) <span class="op">&gt;&gt;=</span> g</span></code></pre></div>
<p>This law can be a little more difficult to follow, so let's look at
the contents of the parentheses on each side of the equation. We can
rewrite the expression on the left as follows.</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> s</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> s x <span class="ot">=</span> f x <span class="op">&gt;&gt;=</span> g</span></code></pre></div>
<p>On the right, we can also rearrange things.</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">&gt;&gt;=</span> g</span>
<span id="cb105-2"><a href="#cb105-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> t <span class="ot">=</span> m <span class="op">&gt;&gt;=</span> f</span></code></pre></div>
<p>We're now claiming that the following two expressions are
equivalent.</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">&gt;&gt;=</span> s <span class="op">==</span> t <span class="op">&gt;&gt;=</span> g</span></code></pre></div>
<p>What this means is if we want to break up an action into smaller
pieces, it doesn't matter which sub-actions we hoist out to make new
actions with, provided we preserve their ordering. If we have three
actions chained together, we can substitute the first two and leave the
third in place, or we can replace the second two and leave the first in
place.</p>
<p>Even this more complicated law has a practical consequence. In the
terminology of software refactoring, the "extract method" technique is a
fancy term for snipping out a piece of inline code, turning it into a
function, and calling the function from the site of the snipped code.
This law essentially states that this technique can be applied to
monadic Haskell code.</p>
<p>We've now seen how each of the monad laws offers us an insight into
writing better monadic code. The first two laws show us how to avoid
unnecessary use of <code>return</code>. The third suggests that we can
safely refactor a complicated action into several simpler ones. We can
now safely let the details fade, in the knowledge that our "do what I
mean" intuitions won't be violated when we use properly written
monads.</p>
<p>Incidentally, a Haskell compiler cannot guarantee that a monad
actually follows the monad laws. It is the responsibility of a monad's
author to satisfy—or, preferably, prove to—themselves that their code
follows the laws.</p>
</body>
</html>
