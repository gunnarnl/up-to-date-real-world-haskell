<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 15. Programming with monads</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 15. Programming with monads</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#golfing-practice-association-lists"><span
class="toc-section-number">1</span> Golfing practice: association
lists</a></li>
<li><a href="#generalised-lifting"><span
class="toc-section-number">2</span> Generalised lifting</a></li>
<li><a href="#looking-for-alternatives"><span
class="toc-section-number">3</span> Looking for alternatives</a>
<ul>
<li><a href="#the-name-mplus-does-not-imply-addition"><span
class="toc-section-number">3.1</span> The name <code>mplus</code> does
not imply addition</a></li>
<li><a href="#rules-for-working-with-monadplus"><span
class="toc-section-number">3.2</span> Rules for working with
<code>MonadPlus</code></a></li>
<li><a href="#failing-safely-with-monadplus"><span
class="toc-section-number">3.3</span> Failing safely with
<code>MonadPlus</code></a></li>
</ul></li>
<li><a href="#adventures-in-hiding-the-plumbing"><span
class="toc-section-number">4</span> Adventures in hiding the
plumbing</a>
<ul>
<li><a href="#supplying-random-numbers"><span
class="toc-section-number">4.1</span> Supplying random numbers</a></li>
<li><a href="#another-round-of-golf"><span
class="toc-section-number">4.2</span> Another round of golf</a></li>
</ul></li>
<li><a href="#separating-interface-from-implementation"><span
class="toc-section-number">5</span> Separating interface from
implementation</a>
<ul>
<li><a href="#multi-parameter-type-classes"><span
class="toc-section-number">5.1</span> Multi-parameter type
classes</a></li>
<li><a href="#functional-dependencies"><span
class="toc-section-number">5.2</span> Functional dependencies</a></li>
<li><a href="#rounding-out-our-module"><span
class="toc-section-number">5.3</span> Rounding out our module</a></li>
<li><a href="#programming-to-a-monads-interface"><span
class="toc-section-number">5.4</span> Programming to a monad's
interface</a></li>
</ul></li>
<li><a href="#the-reader-monad"><span
class="toc-section-number">6</span> The reader monad</a></li>
<li><a href="#a-return-to-automated-deriving"><span
class="toc-section-number">7</span> A return to automated
deriving</a></li>
<li><a href="#hiding-the-io-monad"><span
class="toc-section-number">8</span> Hiding the <code>IO</code> monad</a>
<ul>
<li><a href="#using-a-newtype"><span
class="toc-section-number">8.1</span> Using a
<code>newtype</code></a></li>
<li><a href="#designing-for-unexpected-uses"><span
class="toc-section-number">8.2</span> Designing for unexpected
uses</a></li>
<li><a href="#using-type-classes"><span
class="toc-section-number">8.3</span> Using type classes</a></li>
<li><a href="#isolation-and-testing"><span
class="toc-section-number">8.4</span> Isolation and testing</a></li>
<li><a href="#the-writer-monad-and-lists"><span
class="toc-section-number">8.5</span> The writer monad and
lists</a></li>
<li><a href="#arbitrary-io-revisited"><span
class="toc-section-number">8.6</span> Arbitrary I/O revisited</a></li>
<li><a href="#exercises"><span class="toc-section-number">8.7</span>
Exercises</a></li>
</ul></li>
</ul>
</nav>
<h1 data-number="1" id="golfing-practice-association-lists"><span
class="header-section-number">1</span> Golfing practice: association
lists</h1>
<p>Web clients and servers often pass information around as a simple
textual list of key-value pairs.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>name<span class="ot">=</span><span class="dt">Attila</span><span class="op">+%</span>42The<span class="op">+</span><span class="dt">Hun</span><span class="op">%</span><span class="dv">42</span><span class="op">&amp;</span>occupation<span class="ot">=</span><span class="dt">Khan</span></span></code></pre></div>
<p>The encoding is named <code>application/x-www-form-urlencoded</code>,
and it's easy to understand. Each key-value pair is separated by an
<code>&amp;</code> character. Within a pair, a key is a series of
characters, followed by an <code>=</code>, followed by a value.</p>
<p>We can obviously represent a key as a <code>String</code>, but the
HTTP specification is not clear about whether a key must be followed by
a value. We can capture this ambiguity by representing a value as a
<code>Maybe String</code>. If we use <code>Nothing</code> for a value,
then there was no value present. If we wrap a string in
<code>Just</code>, then there was a value. Using <code>Maybe</code> lets
us distinguish between "no value" and "empty value".</p>
<p>Haskell programmers use the name <em>association list</em> for the
type <code>[(a, b)]</code>, where we can think of each element as an
association between a key and a value. The name originates in the Lisp
community, where it's usually abbreviated as an <em>alist</em>. We could
thus represent the above string as the following Haskell value.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>[(<span class="st">&quot;name&quot;</span>,       <span class="dt">Just</span> <span class="st">&quot;Attila \&quot;The Hun\&quot;&quot;</span>),</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a> (<span class="st">&quot;occupation&quot;</span>, <span class="dt">Just</span> <span class="st">&quot;Khan&quot;</span>)]</span></code></pre></div>
<p>In <a
href="14-using-parsec.org::*Parsing an URL-encoded query string">the
section called "Parsing an URL-encoded query string"</a> parsed an
<code>application/x-www-form-urlencoded</code> string, and represented
the result as an alist of <code>[(String, Maybe String)]</code>. Let's
say we want to use one of these alists to fill out a data structure.</p>
<div class="captioned-content">
<div class="caption">
MovieReview.hs
</div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">MovieReview</span> <span class="ot">=</span> <span class="dt">MovieReview</span> {</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="ot">      revTitle ::</span> <span class="dt">String</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> revUser ::</span> <span class="dt">String</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> revReview ::</span> <span class="dt">String</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    }</span></code></pre></div>
</div>
<p>We'll begin by belabouring the obvious with a naive function.</p>
<div class="captioned-content">
<div class="caption">
MovieReview.hs
</div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleReview ::</span> [(<span class="dt">String</span>, <span class="dt">Maybe</span> <span class="dt">String</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">MovieReview</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>simpleReview alist <span class="ot">=</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> <span class="fu">lookup</span> <span class="st">&quot;title&quot;</span> alist <span class="kw">of</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> (<span class="dt">Just</span> title<span class="op">@</span>(_<span class="op">:</span>_)) <span class="ot">-&gt;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> <span class="fu">lookup</span> <span class="st">&quot;user&quot;</span> alist <span class="kw">of</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> (<span class="dt">Just</span> user<span class="op">@</span>(_<span class="op">:</span>_)) <span class="ot">-&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">case</span> <span class="fu">lookup</span> <span class="st">&quot;review&quot;</span> alist <span class="kw">of</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">Just</span> (<span class="dt">Just</span> review<span class="op">@</span>(_<span class="op">:</span>_)) <span class="ot">-&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                <span class="dt">Just</span> (<span class="dt">MovieReview</span> title user review)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span> <span class="co">-- no review</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span> <span class="co">-- no user</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span> <span class="co">-- no title</span></span></code></pre></div>
</div>
<p>It only returns a <code>MovieReview</code> if the alist contains all
of the necessary values, and they're all non-empty strings. However, the
fact that it validates its inputs is its only merit: it suffers badly
from the "staircasing" that we've learned to be wary of, and it knows
the intimate details of the representation of an alist.</p>
<p>Since we're now well acquainted with the <code>Maybe</code> monad, we
can tidy up the staircasing.</p>
<div class="captioned-content">
<div class="caption">
MovieReview.hs
</div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>maybeReview alist <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    title <span class="ot">&lt;-</span> lookup1 <span class="st">&quot;title&quot;</span> alist</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    user <span class="ot">&lt;-</span> lookup1 <span class="st">&quot;user&quot;</span> alist</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    review <span class="ot">&lt;-</span> lookup1 <span class="st">&quot;review&quot;</span> alist</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="dt">MovieReview</span> title user review)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>lookup1 key alist <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> key alist <span class="kw">of</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Just</span> (<span class="dt">Just</span> s<span class="op">@</span>(_<span class="op">:</span>_)) <span class="ot">-&gt;</span> <span class="dt">Just</span> s</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                      _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span></code></pre></div>
</div>
<p>Although this is much tidier, we're still repeating ourselves. We can
take advantage of the fact that the <code>MovieReview</code> constructor
acts as a normal, pure function by <em>lifting</em> it into the monad,
as we discussed in <a
href="15-monads.org::*Mixing pure and monadic code">the section called
"Mixing pure and monadic code"</a></p>
<div class="captioned-content">
<div class="caption">
MovieReview.hs
</div>
<div class="sourceCode" id="cb6"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>liftedReview alist <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    liftM3 <span class="dt">MovieReview</span> (lookup1 <span class="st">&quot;title&quot;</span> alist)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>                       (lookup1 <span class="st">&quot;user&quot;</span> alist)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>                       (lookup1 <span class="st">&quot;review&quot;</span> alist)</span></code></pre></div>
</div>
<p>We still have some repetition here, but it is dramatically reduced,
and also more difficult to remove.</p>
<h1 data-number="2" id="generalised-lifting"><span
class="header-section-number">2</span> Generalised lifting</h1>
<p>Although using <code>liftM3</code> tidies up our code, we can't use a
<code>liftM</code>-family function to solve this sort of problem in
general, because they're only defined up to <code>liftM5</code> by the
standard libraries. We could write variants up to whatever number we
pleased, but that would amount to drudgery.</p>
<p>If we had a constructor or pure function that took, say, ten
parameters, and decided to stick with the standard libraries you might
think we'd be out of luck.</p>
<p>Of course, our toolbox isn't yet empty. In
<code>Control.Monad</code>, there's a function named <code>ap</code>
with an interesting type signature.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Monad
ghci&gt; :type ap
ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</code></pre>
<p>You might wonder who would put a single-argument pure function inside
a monad, and why. Recall, however, that <em>all</em> Haskell functions
really take only one argument, and you'll begin to see how this might
relate to the <code>MovieReview</code> constructor.</p>
<pre class="screen"><code>ghci&gt; :type MovieReview
MovieReview :: String -&gt; String -&gt; String -&gt; MovieReview
</code></pre>
<p>We can just as easily write that type as
<code>String -&gt; (String -&gt; (String -&gt; MovieReview))</code>. If
we use plain old <code>liftM</code> to lift <code>MovieReview</code>
into the <code>Maybe</code> monad, we'll have a value of type
<code>Maybe (String -&gt; (String -&gt; (String -&gt; MovieReview)))</code>.
We can now see that this type is suitable as an argument for
<code>ap</code>, in which case the result type will be
<code>Maybe (String -&gt; (String -&gt; MovieReview))</code>. We can
pass this, in turn, to <code>ap</code>, and continue to chain until we
end up with this definition.</p>
<div class="captioned-content">
<div class="caption">
MovieReview.hs
</div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>apReview alist <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MovieReview</span> <span class="ot">`liftM`</span> lookup1 <span class="st">&quot;title&quot;</span> alist</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">`ap`</span> lookup1 <span class="st">&quot;user&quot;</span> alist</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>                   <span class="ot">`ap`</span> lookup1 <span class="st">&quot;review&quot;</span> alist</span></code></pre></div>
</div>
<p>We can chain applications of <code>ap</code> like this as many times
as we need to, thereby bypassing the <code>liftM</code> family of
functions.</p>
<p>Another helpful way to look at <code>ap</code> is that it's the
monadic equivalent of the familiar <code>(&lt;*&gt;)</code> operator:
think of pronouncing <code>ap</code> as <em>apply</em>. We can see this
clearly when we compare the type signatures of the two functions.</p>
<pre class="screen"><code>ghci&gt; :type (&lt;*&gt;)
(&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b
ghci&gt; :type ap
ap :: Monad m =&gt; m (a -&gt; b) -&gt; m a -&gt; m b
</code></pre>
<p>And that's why, as we saw in <a href="15-monads.org">Chapter 15,
Monads</a>, they are synonyms.</p>
<h1 data-number="3" id="looking-for-alternatives"><span
class="header-section-number">3</span> Looking for alternatives</h1>
<p>Here's a simple representation of a person's phone numbers.</p>
<div class="captioned-content">
<div class="caption">
VCard.hs
</div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Context</span> <span class="ot">=</span> <span class="dt">Home</span> <span class="op">|</span> <span class="dt">Mobile</span> <span class="op">|</span> <span class="dt">Business</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>               <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Phone</span> <span class="ot">=</span> <span class="dt">String</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>albulena <span class="ot">=</span> [(<span class="dt">Home</span>, <span class="st">&quot;+355-652-55512&quot;</span>)]</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>nils <span class="ot">=</span> [(<span class="dt">Mobile</span>, <span class="st">&quot;+47-922-55-512&quot;</span>), (<span class="dt">Business</span>, <span class="st">&quot;+47-922-12-121&quot;</span>),</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">Home</span>, <span class="st">&quot;+47-925-55-121&quot;</span>), (<span class="dt">Business</span>, <span class="st">&quot;+47-922-25-551&quot;</span>)]</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>twalumba <span class="ot">=</span> [(<span class="dt">Business</span>, <span class="st">&quot;+260-02-55-5121&quot;</span>)]</span></code></pre></div>
</div>
<p>Suppose we want to get in touch with someone to make a personal call.
We don't want their business number, and we'd prefer to use their home
number (if they have one) instead of their mobile number.</p>
<div class="captioned-content">
<div class="caption">
VCard.hs
</div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">onePersonalPhone ::</span> [(<span class="dt">Context</span>, <span class="dt">Phone</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Phone</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>onePersonalPhone ps <span class="ot">=</span> <span class="kw">case</span> <span class="fu">lookup</span> <span class="dt">Home</span> ps <span class="kw">of</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">lookup</span> <span class="dt">Mobile</span> ps</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">Just</span> n <span class="ot">-&gt;</span> <span class="dt">Just</span> n</span></code></pre></div>
</div>
<p>Of course, if we use <code>Maybe</code> as the result type, we can't
accommodate the possibility that someone might have more than one number
that meet our criteria. For that, we switch to a list.</p>
<div class="captioned-content">
<div class="caption">
VCard.hs
</div>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">allBusinessPhones ::</span> [(<span class="dt">Context</span>, <span class="dt">Phone</span>)] <span class="ot">-&gt;</span> [<span class="dt">Phone</span>]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>allBusinessPhones ps <span class="ot">=</span> <span class="fu">map</span> <span class="fu">snd</span> numbers</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> numbers <span class="ot">=</span> <span class="kw">case</span> <span class="fu">filter</span> (contextIs <span class="dt">Business</span>) ps <span class="kw">of</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>                      [] <span class="ot">-&gt;</span> <span class="fu">filter</span> (contextIs <span class="dt">Mobile</span>) ps</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>                      ns <span class="ot">-&gt;</span> ns</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>contextIs a (b, _) <span class="ot">=</span> a <span class="op">==</span> b</span></code></pre></div>
</div>
<p>Notice that these two functions structure their <code>case</code>
expressions similarly: one alternative handles the case where the first
lookup returns an empty result, while the other handles the non-empty
case.</p>
<pre class="screen"><code>ghci&gt; onePersonalPhone twalumba
Nothing
ghci&gt; onePersonalPhone albulena
Just &quot;+355-652-55512&quot;
ghci&gt; allBusinessPhones nils
[&quot;+47-922-12-121&quot;,&quot;+47-922-25-551&quot;]
</code></pre>
<p>Haskell's <code>Control.Monad</code> module defines a type class,
<code>MonadPlus</code>, that lets us abstract the common pattern out of
our <code>case</code> expressions.</p>
<div class="captioned-content">
<div class="caption">
MonadPlus.hs
</div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadPlus</span> m <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="ot">   mzero ::</span> m a</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="ot">   mplus ::</span> m a <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> m a</span></code></pre></div>
</div>
<p>The value <code>mzero</code> represents an empty result, while
<code>mplus</code> combines two results into one. Here are the standard
definitions of <code>mzero</code> and <code>mplus</code> for
<code>Maybe</code> and lists.</p>
<div class="captioned-content">
<div class="caption">
MonadPlus.hs
</div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadPlus</span> [] <span class="kw">where</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>   mzero <span class="ot">=</span> []</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>   mplus <span class="ot">=</span> (<span class="op">++</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadPlus</span> <span class="dt">Maybe</span> <span class="kw">where</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>   mzero <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>   <span class="dt">Nothing</span> <span class="ot">`mplus`</span> ys  <span class="ot">=</span> ys</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>   xs      <span class="ot">`mplus`</span> _ <span class="ot">=</span> xs</span></code></pre></div>
</div>
<p>We can now use <code>mplus</code> to get rid of our <code>case</code>
expressions entirely. For variety, let's fetch one business and all
personal phone numbers.</p>
<div class="captioned-content">
<div class="caption">
VCard.hs
</div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">oneBusinessPhone ::</span> [(<span class="dt">Context</span>, <span class="dt">Phone</span>)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Phone</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>oneBusinessPhone ps <span class="ot">=</span> <span class="fu">lookup</span> <span class="dt">Business</span> ps <span class="ot">`mplus`</span> <span class="fu">lookup</span> <span class="dt">Mobile</span> ps</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="ot">allPersonalPhones ::</span> [(<span class="dt">Context</span>, <span class="dt">Phone</span>)] <span class="ot">-&gt;</span> [<span class="dt">Phone</span>]</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>allPersonalPhones ps <span class="ot">=</span> <span class="fu">map</span> <span class="fu">snd</span> <span class="op">$</span> <span class="fu">filter</span> (contextIs <span class="dt">Home</span>) ps <span class="ot">`mplus`</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>                                 <span class="fu">filter</span> (contextIs <span class="dt">Mobile</span>) ps</span></code></pre></div>
</div>
<p>In these functions, because we know that <code>lookup</code> returns
a value of type <code>Maybe</code>, and <code>filter</code> returns a
list, it's obvious which version of <code>mplus</code> is going to be
used in each case.</p>
<p>What's more interesting is that we can use <code>mzero</code> and
<code>mplus</code> to write functions that will be useful for
<em>any</em> <code>MonadPlus</code> instance. As an example, here's the
standard <code>lookup</code> function, which returns a value of type
<code>Maybe</code>.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span><span class="ot"> ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [(a, b)] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> _ []                      <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="fu">lookup</span> k ((x,y)<span class="op">:</span>xys) <span class="op">|</span> x <span class="op">==</span> k    <span class="ot">=</span> <span class="dt">Just</span> y</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>                     <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">lookup</span> k xys</span></code></pre></div>
<p>We can easily generalise the result type to any instance of
<code>MonadPlus</code> as follows.</p>
<div class="captioned-content">
<div class="caption">
VCard.hs
</div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lookupM ::</span> (<span class="dt">MonadPlus</span> m, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> [(a, b)] <span class="ot">-&gt;</span> m b</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>lookupM _ []    <span class="ot">=</span> mzero</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>lookupM k ((x,y)<span class="op">:</span>xys)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> x <span class="op">==</span> k    <span class="ot">=</span> <span class="fu">return</span> y <span class="ot">`mplus`</span> lookupM k xys</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> lookupM k xys</span></code></pre></div>
</div>
<p>This lets us get either no result or one, if our result type is
<code>Maybe</code>; all results, if our result type is a list; or
something more appropriate for some other exotic instance of
<code>MonadPlus</code>.</p>
<p>For small functions, such as those we present above, there's little
benefit to using <code>mplus</code>. The advantage lies in more complex
code and in code that is independent of the monad in which it executes.
Even if you don't find yourself needing <code>MonadPlus</code> for your
own code, you are likely to encounter it in other people's projects.</p>
<h2 data-number="3.1" id="the-name-mplus-does-not-imply-addition"><span
class="header-section-number">3.1</span> The name <code>mplus</code>
does not imply addition</h2>
<p>Even though the <code>mplus</code> function contains the text "plus",
you should not think of it as necessarily implying that we're trying to
add two values.</p>
<p>Depending on the monad we're working in, <code>mplus</code>
<em>may</em> implement an operation that looks like addition. For
example, <code>mplus</code> in the list monad is implemented as the
<code>(++)</code> operator.</p>
<pre class="screen"><code>ghci&gt; [1,2,3] `mplus` [4,5,6]
[1,2,3,4,5,6]
</code></pre>
<p>However, if we switch to another monad, the obvious similarity to
addition falls away.</p>
<pre class="screen"><code>ghci&gt; Just 1 `mplus` Just 2
Just 1
</code></pre>
<h2 data-number="3.2" id="rules-for-working-with-monadplus"><span
class="header-section-number">3.2</span> Rules for working with
<code>MonadPlus</code></h2>
<p>Instances of the <code>MonadPlus</code> type class must follow a few
simple rules, in addition to the usual monad rules.</p>
<p>An instance must <em>short circuit</em> if <code>mzero</code> appears
on the left of a bind expression. In other words, an expression
<code>mzero &gt;&gt;= f</code> must evaluate to the same result as
<code>mzero</code> alone.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>mzero <span class="op">&gt;&gt;=</span> f <span class="op">==</span> mzero</span></code></pre></div>
<p>An instance must short circuit if <code>mzero</code> appears on the
<em>right</em> of a sequence expression.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">&gt;&gt;</span> mzero <span class="op">==</span> mzero</span></code></pre></div>
<h2 data-number="3.3" id="failing-safely-with-monadplus"><span
class="header-section-number">3.3</span> Failing safely with
<code>MonadPlus</code></h2>
<p>When we introduced the <code>fail</code> function in <a
href="15-monads.org::*The Monad type class">the section called "The
Monad type class"</a> warn against its use: in many monads, it's
implemented as a call to <code>error</code>, which has unpleasant
consequences.</p>
<p>The <code>MonadPlus</code> type class gives us a gentler way to fail
a computation, without <code>fail</code> or <code>error</code> blowing
up in our faces. The rules that we introduced above allow us to
introduce an <code>mzero</code> into our code wherever we need to, and
computation will short circuit at that point.</p>
<p>In the <code>Control.Monad</code> module, the standard function
<code>guard</code> packages up this idea in a convenient form.</p>
<div class="captioned-content">
<div class="caption">
MonadPlus.hs
</div>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ot">guard        ::</span> (<span class="dt">MonadPlus</span> m) <span class="ot">=&gt;</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">True</span>   <span class="ot">=</span>  <span class="fu">return</span> ()</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>guard <span class="dt">False</span>  <span class="ot">=</span>  mzero</span></code></pre></div>
</div>
<p>As a simple example, here's a function that takes a number
<code>x</code> and computes its value modulo some other number
<code>n</code>. If the result is zero, it returns <code>x</code>,
otherwise the current monad's <code>mzero</code>.</p>
<div class="captioned-content">
<div class="caption">
MonadPlus.hs
</div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>x <span class="ot">`zeroMod`</span> n <span class="ot">=</span> guard ((x <span class="ot">`mod`</span> n) <span class="op">==</span> <span class="dv">0</span>) <span class="op">&gt;&gt;</span> <span class="fu">return</span> x</span></code></pre></div>
</div>
<h1 data-number="4" id="adventures-in-hiding-the-plumbing"><span
class="header-section-number">4</span> Adventures in hiding the
plumbing</h1>
<p>In <a
href="15-monads.org::*Using the state monad: generating random values">the
section called "Using the state monad: generating random values"</a> we
showed how to use the <code>State</code> monad to give ourselves access
to random numbers in a way that is easy to use.</p>
<p>A drawback of the code we developed is that it's <em>leaky</em>:
someone who uses it knows that they're executing inside the
<code>State</code> monad. This means that they can inspect and modify
the state of the random number generator just as easily as we, the
authors, can.</p>
<p>Human nature dictates that if we leave our internal workings exposed,
someone will surely come along and monkey with them. For a sufficiently
small program, this may be fine, but in a larger software project, when
one consumer of a library modifies its internals in a way that other
consumers are not prepared for, the resulting bugs can be among the
hardest of all to track down. These bugs occur at a level where we're
unlikely to question our basic assumptions about a library until long
after we've exhausted all other avenues of inquiry.</p>
<p>Even worse, once we leave our implementation exposed for a while, and
some well-intentioned person inevitably bypasses our APIs and uses the
implementation directly, we create a nasty quandary for ourselves if we
need to fix a bug or make an enhancement. Either we can modify our
internals, and break code that depends on them; or we're stuck with our
existing internals, and must try to find some other way to make the
change we need.</p>
<p>How can we revise our random number monad so that the fact that we're
using the <code>State</code> monad is hidden? We need to somehow prevent
our users from being able to call <code>get</code> or <code>put</code>.
This is not difficult to do, and it introduces some tricks that we'll
reuse often in day-to-day Haskell programming.</p>
<p>To widen our scope, we'll move beyond random numbers, and implement a
monad that supplies unique values of <em>any</em> kind. The name we'll
give to our monad is <code>Supply</code>. We'll provide the execution
function, <code>runSupply</code>, with a list of values; it will be up
to us to ensure that each one is unique.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb26"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runSupply ::</span> <span class="dt">Supply</span> s a <span class="ot">-&gt;</span> [s] <span class="ot">-&gt;</span> (a, [s])</span></code></pre></div>
</div>
<p>The monad won't care what the values are: they might be random
numbers, or names for temporary files, or identifiers for HTTP
cookies.</p>
<p>Within the monad, every time a consumer asks for a value, the
<code>next</code> action will take the next one from the list and give
it to the consumer. Each value is wrapped in a <code>Maybe</code>
constructor in case the list isn't long enough to satisfy the
demand.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">next ::</span> <span class="dt">Supply</span> s (<span class="dt">Maybe</span> s)</span></code></pre></div>
</div>
<p>To hide our plumbing, in our module declaration we only export the
type constructor, the execution function, and the <code>next</code>
action.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Supply</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Supply</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>    , next</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    , runSupply</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">where</span></span></code></pre></div>
</div>
<p>Since a module that imports the library can't see the internals of
the monad, it can't manipulate them.</p>
<p>Our plumbing is exceedingly simple: we use a <code>newtype</code>
declaration to wrap the existing <code>State</code> monad.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Supply</span> s a <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">State</span> [s] a)</span></code></pre></div>
</div>
<p>The <code>s</code> parameter is the type of the unique values we are
going to supply, and <code>a</code> is the usual type parameter that we
must provide in order to make our type a monad.</p>
<p>Our use of <code>newtype</code> for the <code>Supply</code> type and
our module header join forces to prevent our clients from using the
<code>State</code> monad's <code>get</code> and <code>set</code>
actions. Because our module does not export the <code>s</code> data
constructor, clients have no programmatic way to see that we're wrapping
the <code>State</code> monad, or to access it.</p>
<p>At this point, we've got a type, <code>Supply</code>, that we need to
make an instance of the <code>Monad</code> type class. We could follow
the usual pattern of defining <code>(&gt;&gt;=)</code> and
<code>return</code>, but this would be pure boilerplate code. All we'd
be doing is wrapping and unwrapping the <code>State</code> monad's
versions of <code>(&gt;&gt;=)</code> and <code>return</code> using our
<code>s</code> value constructor. Here is how such code would look.</p>
<div class="captioned-content">
<div class="caption">
AltSupply.hs
</div>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.State</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Supply</span> s a <span class="ot">=</span> <span class="dt">S</span> (<span class="dt">State</span> [s] a)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a><span class="ot">unwrapS ::</span> <span class="dt">Supply</span> s a <span class="ot">-&gt;</span> <span class="dt">State</span> [s] a</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>unwrapS (<span class="dt">S</span> s) <span class="ot">=</span> s</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Supply</span> s) <span class="kw">where</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Supply</span> s) <span class="kw">where</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="dt">S</span> <span class="op">.</span> <span class="fu">pure</span></span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Supply</span> s) <span class="kw">where</span></span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true" tabindex="-1"></a>    s <span class="op">&gt;&gt;=</span> m <span class="ot">=</span> <span class="dt">S</span> (unwrapS s <span class="op">&gt;&gt;=</span> unwrapS <span class="op">.</span> m)</span></code></pre></div>
</div>
<p>Haskell programmers are not fond of boilerplate, and sure enough, GHC
has a lovely language extension that eliminates the work. To use it, we
add the following directive to the top of our source file, before the
module header.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span></code></pre></div>
</div>
<p>Usually, we can only automatically derive instances of a handful of
standard type classes, such as <code>Show</code> and <code>Eq</code>. As
its name suggests, the <code>GeneralizedNewtypeDeriving</code> extension
broadens our ability to derive type class instances, and it is specific
to <code>newtype</code> declarations. If the type we're wrapping is an
instance of any type class, the extensions can automatically make our
new type an instance of that type class as follows.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="kw">deriving</span> (<span class="dt">Monad</span>)</span></code></pre></div>
</div>
<p>This takes the underlying type's implementations of
<code>(&gt;&gt;=)</code> and <code>return</code>, adds the necessary
wrapping and unwrapping with our <code>s</code> data constructor, and
uses the new versions of those functions to derive a <code>Monad</code>
instance for us.</p>
<p>What we gain here is very useful beyond just this example. We can use
<code>newtype</code> to wrap any underlying type; we selectively expose
only those type class instances that we want; and we expend almost no
effort to create these narrower, more specialised types.</p>
<p>Sadly currently GHC is not able to automatically derive the required
functor and applicative instance of our monad so we still need a little
bit of boilerplate:</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb33"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Supply</span> s) <span class="kw">where</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Supply</span> s) <span class="kw">where</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span></code></pre></div>
</div>
<p>Now that we've seen the <code>GeneralizedNewtypeDeriving</code>
technique, all that remains is to provide definitions of
<code>next</code> and <code>runSupply</code>.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>next <span class="ot">=</span> <span class="dt">S</span> <span class="op">$</span> <span class="kw">do</span> st <span class="ot">&lt;-</span> get</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> st <span class="kw">of</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>                [] <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>                (x<span class="op">:</span>xs) <span class="ot">-&gt;</span> <span class="kw">do</span> put xs</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>                             <span class="fu">return</span> (<span class="dt">Just</span> x)</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>runSupply (<span class="dt">S</span> m) xs <span class="ot">=</span> runState m xs</span></code></pre></div>
</div>
<p>If we load our module into <code>ghci</code>, we can try it out in a
few simple ways.</p>
<pre class="screen"><code>ghci&gt; :load Supply
[1 of 1] Compiling Supply           ( Supply.hs, interpreted )
Ok, one module loaded.
ghci&gt; runSupply next [1,2,3]
(Just 1,[2,3])
ghci&gt; runSupply (liftM2 (,) next next) [1,2,3]
((Just 1,Just 2),[3])
ghci&gt; runSupply (liftM2 (,) next next) [1]
((Just 1,Nothing),[])
</code></pre>
<h2 data-number="4.1" id="supplying-random-numbers"><span
class="header-section-number">4.1</span> Supplying random numbers</h2>
<p>If we want to use our <code>Supply</code> monad as a source of random
numbers, we have a small difficulty to face. Ideally, we'd like to be
able to provide it with an infinite stream of random numbers. We can get
a <code>StdGen</code> in the <code>IO</code> monad, but we must "put
back" a different <code>StdGen</code> when we're done. If we don't, the
next piece of code to get a <code>StdGen</code> will get the same state
as we did. This means it will generate the same random numbers as we
did, which is potentially catastrophic.</p>
<p>From the parts of the <code>System.Random</code> module we've seen so
far, it's difficult to reconcile these demands. We can use
<code>getStdRandom</code>, whose type ensures that when we get a
<code>StdGen</code>, we put one back.</p>
<pre class="screen"><code>ghci&gt; :t System.Random.getStdRandom
System.Random.getStdRandom :: (StdGen -&gt; (a, StdGen)) -&gt; IO a
</code></pre>
<p>We can use <code>random</code> to get back a new <code>StdGen</code>
when they give us a random number. And we can use <code>randoms</code>
to get an infinite list of random numbers. But how do we get both an
infinite list of random numbers <em>and</em> a new
<code>StdGen</code>?</p>
<p>The answer lies with the <code>RandomGen</code> type class's
<code>split</code> function, which takes one random number generator,
and turns it into two generators. Splitting a random generator like this
is a most unusual thing to be able to do: it's obviously tremendously
useful in a pure functional setting, but essentially never either
necessary or provided by an impure language.</p>
<p>Using the <code>split</code> function, we can use one
<code>StdGen</code> to generate an infinite list of random numbers to
feed to <code>runSupply</code>, while we give the other back to the
<code>IO</code> monad.</p>
<div class="captioned-content">
<div class="caption">
RandomSupply.hs
</div>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">RandomSupply</span> <span class="kw">where</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Supply</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> <span class="kw">hiding</span> (next)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ot">randomsIO ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">IO</span> [a]</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>randomsIO <span class="ot">=</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    getStdRandom <span class="op">$</span> \g <span class="ot">-&gt;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (a, b) <span class="ot">=</span> split g</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>        <span class="kw">in</span> (randoms a, b)</span></code></pre></div>
</div>
<p>If we've written this function properly, our example ought to print a
different random number on each invocation.</p>
<pre class="screen"><code>ghci&gt; :load RandomSupply
[1 of 2] Compiling Supply           ( Supply.hs, interpreted )
[2 of 2] Compiling RandomSupply     ( RandomSupply.hs, interpreted )
Ok, two modules loaded.
ghci&gt; (fst . runSupply next) `fmap` randomsIO
Just 6077368651500926723
ghci&gt; (fst . runSupply next) `fmap` randomsIO
Just (-7180502226926150515)
</code></pre>
<p>Recall that our <code>runSupply</code> function returns both the
result of executing the monadic action and the unconsumed remainder of
the list. Since we passed it an infinite list of random numbers, we
compose with <code>fst</code> to ensure that we don't get drowned in
random numbers when <code>ghci</code> tries to print the result.</p>
<h2 data-number="4.2" id="another-round-of-golf"><span
class="header-section-number">4.2</span> Another round of golf</h2>
<p>The pattern of applying a function to one element of a pair, and
constructing a new pair with the other original element untouched, is
common enough in Haskell code that it has been turned into standard
code.</p>
<p>In the <code>Control.Arrow</code> module are two functions,
<code>first</code> and <code>second</code>, that perform this
operation.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Arrow
ghci&gt; first (+3) (1,2)
(4,2)
ghci&gt; second odd (&#39;a&#39;,1)
(&#39;a&#39;,True)
</code></pre>
<p>(Indeed, we already encountered <code>second</code>, in <a
href="6-using-typeclasses.org::*JSON type classes without overlapping instances">the
section called "JSON type classes without overlapping instances"</a> We
can use <code>first</code> to golf our definition of
<code>randomsIO</code>, turning it into a one-liner.</p>
<div class="captioned-content">
<div class="caption">
RandomGolf.hs
</div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Arrow</span> (first)</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="ot">randomsIO_golfed ::</span> <span class="dt">Random</span> a <span class="ot">=&gt;</span> <span class="dt">IO</span> [a]</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>randomsIO_golfed <span class="ot">=</span> getStdRandom (first randoms <span class="op">.</span> split)</span></code></pre></div>
</div>
<h1 data-number="5" id="separating-interface-from-implementation"><span
class="header-section-number">5</span> Separating interface from
implementation</h1>
<p>In the previous section, we saw how to hide the fact that we're using
a <code>State</code> monad to hold the state for our <code>Supply</code>
monad.</p>
<p>Another important way to make code more modular involves separating
its /interface/—what the code can do—from its /implementation/—how it
does it.</p>
<p>The standard random number generator in <code>System.Random</code> is
known to be quite slow. If we use our <code>randomsIO</code> function to
provide it with random numbers, then our <code>next</code> action will
not perform well.</p>
<p>One simple and effective way that we could deal with this is to
provide <code>Supply</code> with a better source of random numbers.
Let's set this idea aside, though, and consider an alternative approach,
one that is useful in many settings. We will separate the actions we can
perform with the monad from how it works using a type class.</p>
<div class="captioned-content">
<div class="caption">
SupplyClass.hs
</div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies #-}</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Supply</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadSupply</span> s m <span class="op">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    next ::</span> m (<span class="dt">Maybe</span> s)</span></code></pre></div>
</div>
<p>This type class defines the interface that any supply monad must
implement. It bears careful inspection, since it uses several unfamiliar
Haskell language extensions. We will cover each one in the sections that
follow.</p>
<h2 data-number="5.1" id="multi-parameter-type-classes"><span
class="header-section-number">5.1</span> Multi-parameter type
classes</h2>
<p>How should we read the snippet <code>MonadSupply s m</code> in the
type class? If we add parentheses, an equivalent expression is
<code>(MonadSupply s) m</code>, which is a little clearer. In other
words, given some type variable <code>m</code> that is a monad, we can
make it an instance of the type class <code>MonadSupply s</code>. unlike
a regular type class, this one has a <em>parameter</em>.</p>
<p>As this language extension allows a type class to have more than one
parameter, its name is <code>MultiParamTypeClasses</code>. The parameter
<code>s</code> serves the same purpose as the <code>Supply</code> type's
parameter of the same name: it represents the type of the values handed
out by the <code>next</code> function.</p>
<p>Notice that we don't need to mention <code>(&gt;&gt;=)</code> or
<code>return</code> in the definition of <code>MonadSupply s</code>,
since the type class's context (superclass) requires that a
<code>MonadSupply s</code> must already be a monad.</p>
<h2 data-number="5.2" id="functional-dependencies"><span
class="header-section-number">5.2</span> Functional dependencies</h2>
<p>To revisit a snippet that we ignored earlier,
<code>| m -&gt; s</code> is a <em>functional dependency</em>, often
called a <em>fundep</em>. We can read the vertical bar <code>|</code> as
"such that", and the arrow <code>-&gt;</code> as "uniquely determines".
Our functional dependency establishes a <em>relationship</em> between
<code>m</code> and <code>s</code>.</p>
<p>The availability of functional dependencies is governed by the
<code>FunctionalDependencies</code> language pragma.</p>
<p>The purpose behind us declaring a relationship is to help the type
checker. Recall that a Haskell type checker is essentially a theorem
prover, and that it is conservative in how it operates: it insists that
its proofs must terminate. A non-terminating proof results in the
compiler either giving up or getting stuck in an infinite loop.</p>
<p>With our functional dependency, we are telling the type checker that
every time it sees some monad <code>m</code> being used in the context
of a <code>MonadSupply s</code>, the type <code>s</code> is the only
acceptable type to use with it. If we were to omit the functional
dependency, the type checker would simply give up with an error
message.</p>
<p>It's hard to picture what the relationship between <code>m</code> and
<code>s</code> really means, so let's look at an instance of this type
class.</p>
<div class="captioned-content">
<div class="caption">
SupplyClass.hs
</div>
<div class="sourceCode" id="cb42"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadSupply</span> s (<span class="dt">S.Supply</span> s) <span class="kw">where</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>    next <span class="ot">=</span> S.next</span></code></pre></div>
</div>
<p>Here, the type variable <code>m</code> is replaced by the type
<code>S.Supply s</code>. Thanks to our functional dependency, the type
checker now knows that when it sees a type <code>S.Supply s</code>, the
type can be used as an instance of the type class
<code>MonadSupply s</code>.</p>
<p>If we didn't have a functional dependency, the type checker would not
be able to figure out the relationship between the type parameter of the
class <code>MonadSupply s</code> and that of the type
<code>Supply s</code>, and it would abort compilation with an error. The
definition itself would compile; the type error would not arise until
the first time we tried to use it.</p>
<p>To strip away one final layer of abstraction, consider the type
<code>S.Supply Int</code>. Without a functional dependency, we could
declare this an instance of <code>MonadSupply s</code>. However, if we
tried to write code using this instance, the compiler would not be able
to figure out that the type's <code>Int</code> parameter needs to be the
same as the type class's <code>s</code> parameter, and it would report
an error.</p>
<p>Functional dependencies can be tricky to understand, and once we move
beyond simple uses, they often prove difficult to work with in practice.
Fortunately, the most frequent use of functional dependencies is in
situations as simple as ours, where they cause little trouble.</p>
<h2 data-number="5.3" id="rounding-out-our-module"><span
class="header-section-number">5.3</span> Rounding out our module</h2>
<p>If we save our type class and instance in a source file named
<code>SupplyClass.hs</code>, we'll need to add a module header such as
the following.</p>
<div class="captioned-content">
<div class="caption">
SupplyClass.hs
</div>
<div class="sourceCode" id="cb43"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SupplyClass</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">MonadSupply</span>(<span class="op">..</span>)</span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">S.Supply</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    , S.runSupply</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">where</span></span></code></pre></div>
</div>
<p>Notice that we're re-exporting the <code>runSupply</code> and
<code>Supply</code> names from this module. It's perfectly legal to
export a name from one module even though it's defined in another. In
our case, it means that client code only needs to import the
<code>SupplyClass</code> module, without also importing the
<code>Supply</code> module. This reduces the number of "moving parts"
that a user of our code needs to keep in mind.</p>
<h2 data-number="5.4" id="programming-to-a-monads-interface"><span
class="header-section-number">5.4</span> Programming to a monad's
interface</h2>
<p>Here is a simple function that fetches two values from our
<code>Supply</code> monad, formats them as a string, and returns
them.</p>
<div class="captioned-content">
<div class="caption">
Supply.hs
</div>
<div class="sourceCode" id="cb44"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showTwo ::</span> (<span class="dt">Show</span> s) <span class="ot">=&gt;</span> <span class="dt">Supply</span> s <span class="dt">String</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>showTwo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> next</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> next</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">show</span> <span class="st">&quot;a: &quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;, b: &quot;</span> <span class="op">++</span> <span class="fu">show</span> b)</span></code></pre></div>
</div>
<p>This code is tied by its result type to our <code>Supply</code>
monad. We can easily generalize to any monad that implements our
<code>MonadSupply</code> interface by modifying our function's type.
Notice that the body of the function remains unchanged.</p>
<div class="captioned-content">
<div class="caption">
SupplyClass.hs
</div>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="ot">showTwo_class ::</span> (<span class="dt">Show</span> s, <span class="dt">Monad</span> m, <span class="dt">MonadSupply</span> s m) <span class="ot">=&gt;</span> m <span class="dt">String</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>showTwo_class <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> next</span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> next</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">show</span> <span class="st">&quot;a: &quot;</span> <span class="op">++</span> <span class="fu">show</span> a <span class="op">++</span> <span class="st">&quot;, b: &quot;</span> <span class="op">++</span> <span class="fu">show</span> b)</span></code></pre></div>
</div>
<h1 data-number="6" id="the-reader-monad"><span
class="header-section-number">6</span> The reader monad</h1>
<p>The <code>State</code> monad lets us plumb a piece of mutable state
through our code. Sometimes, we would like to be able to pass some
<em>immutable</em> state around, such as a program's configuration data.
We could use the <code>State</code> monad for this purpose, but we could
then find ourselves accidentally modifying data that should remain
unchanged.</p>
<p>Let's forget about monads for a moment and think about what a
<em>function</em> with our desired characteristics ought to do. It
should accept a value of some type <code>e</code> (for
<em>environment</em>) that represents the data that we're passing in,
and return a value of some other type <code>a</code> as its result. The
overall type we want is <code>e -&gt; a</code>.</p>
<p>To turn this type into a convenient <code>Monad</code> instance,
we'll wrap it in a <code>newtype</code>.</p>
<div class="captioned-content">
<div class="caption">
SupplyInstance.hs
</div>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses  #-}</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SupplyInstance</span> <span class="kw">where</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">SupplyClass</span></span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Reader</span> e a <span class="ot">=</span> <span class="dt">R</span> {<span class="ot"> runReader ::</span> e <span class="ot">-&gt;</span> a }</span></code></pre></div>
</div>
<p>Making this into a <code>Monad</code> instance doesn't take much
work.</p>
<div class="captioned-content">
<div class="caption">
SupplyInstance.hs
</div>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Reader</span> a) <span class="kw">where</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">Reader</span> a) <span class="kw">where</span></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> a <span class="ot">=</span> <span class="dt">R</span> <span class="op">$</span> \_ <span class="ot">-&gt;</span> a</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Monad</span> (<span class="dt">Reader</span> e) <span class="kw">where</span></span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>    m <span class="op">&gt;&gt;=</span> k <span class="ot">=</span> <span class="dt">R</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> runReader (k (runReader m r)) r</span></code></pre></div>
</div>
<p>We can think of our value of type <code>e</code> as an
<em>environment</em> in which we're evaluating some expression. The
<code>return</code> action should have the same effect no matter what
the environment is, so our version ignores its environment.</p>
<p>Our definition of <code>(&gt;&gt;=)</code> is a little more
complicated, but only because we have to make the environment—here the
variable ~r~—available both in the current computation and in the
computation we're chaining into.</p>
<p>How does a piece of code executing in this monad find out what's in
its environment? It simply has to <code>ask</code>.</p>
<div class="captioned-content">
<div class="caption">
SupplyInstance.hs
</div>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="ot">ask ::</span> <span class="dt">Reader</span> e e</span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>ask <span class="ot">=</span> <span class="dt">R</span> <span class="fu">id</span></span></code></pre></div>
</div>
<p>Within a given chain of actions, every invocation of <code>ask</code>
will return the same value, since the value stored in the environment
doesn't change. Our code is easy to test in <code>ghci</code>.</p>
<pre class="screen"><code>ghci&gt; :l SupplyInstance.hs
[1 of 1] Compiling Main             ( SupplyInstance.hs, interpreted )
Ok, one module loaded.
ghci&gt; runReader (ask &gt;&gt;= \x -&gt; return (x * 3)) 2
6
</code></pre>
<p>The <code>Reader</code> monad is included in the standard
<code>mtl</code> library, which is usually bundled with GHC. You can
find it in the <code>Control.Monad.Reader</code> module. The motivation
for this monad may initially seem a little thin, because it is most
often useful in complicated code. We'll often need to access a piece of
configuration information deep in the bowels of a program; passing that
information in as a normal parameter would require a painful
restructuring of our code. By hiding this information in our monad's
plumbing, intermediate functions that don't care about the configuration
information don't need to see it.</p>
<p>The clearest motivation for the <code>Reader</code> monad will come
in <a href="18-monad-transformers.org">Chapter 18, <em>Monad
transformers</em></a>, when we discuss combining several monads to build
a new monad. There, we'll see how to gain finer control over state, so
that our code can modify some values via the <code>State</code> monad,
while other values remain immutable, courtesy of the <code>Reader</code>
monad.</p>
<h1 data-number="7" id="a-return-to-automated-deriving"><span
class="header-section-number">7</span> A return to automated
deriving</h1>
<p>Now that we know about the <code>Reader</code> monad, let's use it to
create an instance of our <code>MonadSupply</code> type class. To keep
our example simple, we'll violate the spirit of <code>MonadSupply</code>
here: our <code>next</code> action will always return the same value,
instead of always returning a different value.</p>
<p>It would be a bad idea to directly make the <code>Reader</code> type
an instance of the <code>MonadSupply</code> class, because then
<em>any</em> <code>Reader</code> could act as a
<code>MonadSupply</code>. This would usually not make any sense.</p>
<p>Instead, we create a <code>newtype</code> based on
<code>Reader</code>. The <code>newtype</code> hides the fact that we're
using <code>Reader</code> internally. We must now make our type an
instance of both of the type classes we care about. With the
<code>GeneralizedNewtypeDeriving</code> extension enabled, GHC will do
most of the hard work for us.</p>
<div class="captioned-content">
<div class="caption">
SupplyInstance.hs
</div>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">MySupply</span> e a <span class="ot">=</span> <span class="dt">MySupply</span> {<span class="ot"> runMySupply ::</span> <span class="dt">Reader</span> e a }</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Monad</span>)</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">MySupply</span> a) <span class="kw">where</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> (<span class="dt">MySupply</span> a) <span class="kw">where</span></span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadSupply</span> e (<span class="dt">MySupply</span> e) <span class="kw">where</span></span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>    next <span class="ot">=</span> <span class="dt">MySupply</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>             v <span class="ot">&lt;-</span> ask</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>             <span class="fu">return</span> (<span class="dt">Just</span> v)</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- more concise:</span></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- next = MySupply (Just `liftM` ask)</span></span></code></pre></div>
</div>
<p>Notice that we must make our type an instance of
<code>MonadSupply e</code>, not <code>MonadSupply</code>. If we omit the
type variable, the compiler will complain.</p>
<p>To try out our <code>MySupply</code> type, we'll first create a
simple function that should work with any <code>MonadSupply</code>
instance.</p>
<div class="captioned-content">
<div class="caption">
SupplyInstance.hs
</div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">xy ::</span> (<span class="dt">Num</span> s, <span class="dt">MonadSupply</span> s m) <span class="ot">=&gt;</span> m s</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>xy <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> x <span class="ot">&lt;-</span> next</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>  <span class="dt">Just</span> y <span class="ot">&lt;-</span> next</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (x <span class="op">*</span> y)</span></code></pre></div>
</div>
<p>If we use this with our <code>Supply</code> monad and
<code>randomsIO</code> function, we get a different answer every time,
as we expect.</p>
<div class="captioned-content">
<div class="caption">
RandomSupplyInstance.hs
</div>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Supply</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">SupplyInstance</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RandomSupply</span></span></code></pre></div>
</div>
<pre class="screen"><code>ghci&gt; :l RandomSupplyInstance.hs
[1 of 5] Compiling Supply           ( Supply.hs, interpreted )
[2 of 5] Compiling RandomSupply     ( RandomSupply.hs, interpreted )
[3 of 5] Compiling SupplyClass      ( SupplyClass.hs, interpreted )
[4 of 5] Compiling SupplyInstance   ( SupplyInstance.hs, interpreted)
[5 of 5] Compiling Main             ( RandomSupplyInstance.hs, interp reted )
Ok, five modules loaded.
ghci&gt; (fst . runSupply xy) `fmap` randomsIO
-15697064270863081825448476392841917578
ghci&gt; (fst . runSupply xy) `fmap` randomsIO
17182983444616834494257398042360119726
</code></pre>
<p>Because our <code>MySupply</code> monad has two layers of
<code>newtype</code> wrapping, we can make it easier to use by writing a
custom execution function for it.</p>
<div class="captioned-content">
<div class="caption">
SupplyInstance.hs
</div>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runMS ::</span> <span class="dt">MySupply</span> i a <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> a</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>runMS <span class="ot">=</span> runReader <span class="op">.</span> runMySupply</span></code></pre></div>
</div>
<p>When we apply our <code>xy</code> action using this execution
function, we get the same answer every time. Our code remains the same,
but because we are executing it in a different implementation of
<code>MonadSupply</code>, its behavior has changed.</p>
<pre class="screen"><code>ghci&gt; :r
[4 of 5] Compiling SupplyInstance   ( SupplyInstance.hs, interpreted)
[5 of 5] Compiling Main             ( RandomSupplyInstance.hs, interp reted ) [SupplyInstance changed]
Ok, five modules loaded.
ghci&gt; runMS xy 2
4
ghci&gt; runMS xy 2
4
</code></pre>
<p>Like our <code>MonadSupply</code> type class and <code>Supply</code>
monad, almost all of the common Haskell monads are built with a split
between interface and implementation. For example, the <code>get</code>
and <code>put</code> functions that we introduced as "belonging to" the
<code>State</code> monad are actually methods of the
<code>MonadState</code> type class; the <code>State</code> type is an
instance of this class.</p>
<p>Similarly, the standard <code>Reader</code> monad is an instance of
the <code>MonadReader</code> type class, which specifies the
<code>ask</code> method.</p>
<p>While the separation of interface and implementation that we've
discussed above is appealing for its architectural cleanliness, it has
important practical applications that will become clearer later. When we
start combining monads in <a
href="18-monad-transformers.org">Chapter 18, <em>Monad
transformers</em></a>, we will save a lot of effort through the use of
<code>GeneralizedNewtypeDeriving</code> and type classes.</p>
<h1 data-number="8" id="hiding-the-io-monad"><span
class="header-section-number">8</span> Hiding the <code>IO</code>
monad</h1>
<p>The blessing and curse of the <code>IO</code> monad is that it is
extremely powerful. If we believe that careful use of types helps us to
avoid programming mistakes, then the <code>IO</code> monad should be a
great source of unease. Because the <code>IO</code> monad imposes no
restrictions on what we can do, it leaves us vulnerable to all kinds of
accidents.</p>
<p>How can we tame its power? Let's say that we would like to guarantee
to ourselves that a piece of code can read and write files on the local
file system, but that it will not access the network. We can't use the
plain <code>IO</code> monad, because it won't restrict us.</p>
<h2 data-number="8.1" id="using-a-newtype"><span
class="header-section-number">8.1</span> Using a
<code>newtype</code></h2>
<p>Let's create a module that provides a small set of functionality for
reading and writing files.</p>
<div class="captioned-content">
<div class="caption">
HandleIO.hs
</div>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">HandleIO</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">HandleIO</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">Handle</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">IOMode</span>(<span class="op">..</span>)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a>    , runHandleIO</span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a>    , openFile</span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>    , hClose</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>    , hPutStrLn</span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">where</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span></span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span> (<span class="dt">MonadIO</span>(..))</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span> (removeFile)</span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (<span class="dt">Handle</span>, <span class="dt">IOMode</span>(..))</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.IO</span></span></code></pre></div>
</div>
<p>Our first approach to creating a restricted version of
<code>IO</code> is to wrap it with a <code>newtype</code>.</p>
<div class="captioned-content">
<div class="caption">
HandleIO.hs
</div>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">HandleIO</span> a <span class="ot">=</span> <span class="dt">HandleIO</span> {<span class="ot"> runHandleIO ::</span> <span class="dt">IO</span> a }</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Monad</span>)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">HandleIO</span> <span class="kw">where</span></span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">HandleIO</span> <span class="kw">where</span></span>
<span id="cb57-8"><a href="#cb57-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb57-9"><a href="#cb57-9" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span></code></pre></div>
</div>
<p>We do the by-now familiar trick of exporting the type constructor and
the <code>runHandleIO</code> execution function from our module, but not
the data constructor. This will prevent code running within the
<code>HandleIO</code> monad from getting hold of the <code>IO</code>
monad that it wraps.</p>
<p>All that remains is for us to wrap each of the actions we want our
monad to allow. This is a simple matter of wrapping each <code>IO</code>
with a <code>HandleIO</code> data constructor.</p>
<div class="captioned-content">
<div class="caption">
HandleIO.hs
</div>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="ot">openFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IOMode</span> <span class="ot">-&gt;</span> <span class="dt">HandleIO</span> <span class="dt">Handle</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>openFile path mode <span class="ot">=</span> <span class="dt">HandleIO</span> (System.IO.openFile path mode)</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="ot">hClose ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">HandleIO</span> ()</span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a>hClose <span class="ot">=</span> <span class="dt">HandleIO</span> <span class="op">.</span> System.IO.hClose</span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="ot">hPutStrLn ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">HandleIO</span> ()</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a>hPutStrLn h s <span class="ot">=</span> <span class="dt">HandleIO</span> (System.IO.hPutStrLn h s)</span></code></pre></div>
</div>
<p>We can now use our restricted <code>HandleIO</code> monad to perform
I/O.</p>
<div class="captioned-content">
<div class="caption">
HandleIO.hs
</div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHello ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">HandleIO</span> ()</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>safeHello path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> openFile path <span class="dt">WriteMode</span></span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>  hPutStrLn h <span class="st">&quot;hello world&quot;</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  hClose h</span></code></pre></div>
</div>
<p>To run this action, we use <code>runHandleIO</code>.</p>
<pre class="screen"><code>ghci&gt; :load HandleIO
[1 of 1] Compiling HandleIO         ( HandleIO.hs, interpreted )
Ok, one module loaded.
ghci&gt; runHandleIO (safeHello &quot;hello_world_101.txt&quot;)
ghci&gt; :m +System.Directory
ghci&gt; removeFile &quot;hello_world_101.txt&quot;
</code></pre>
<p>If we try to sequence an action that runs in the
<code>HandleIO</code> monad with one that is not permitted, the type
system forbids it.</p>
<pre class="screen"><code>ghci&gt; runHandleIO (safeHello &quot;goodbye&quot; &gt;&gt; removeFile &quot;goodbye&quot;)

&lt;interactive&gt;:1:36: error:
    • Couldn&#39;t match type ‘IO’ with ‘HandleIO’
      Expected type: HandleIO ()
        Actual type: IO ()
    • In the second argument of ‘(&gt;&gt;)’, namely ‘removeFile &quot;goodbye&quot;’
      In the first argument of ‘runHandleIO’, namely
        ‘(safeHello &quot;goodbye&quot; &gt;&gt; removeFile &quot;goodbye&quot;)’
      In the expression:
        runHandleIO (safeHello &quot;goodbye&quot; &gt;&gt; removeFile &quot;goodbye&quot;)
</code></pre>
<h2 data-number="8.2" id="designing-for-unexpected-uses"><span
class="header-section-number">8.2</span> Designing for unexpected
uses</h2>
<p>There's one small, but significant, problem with our
<code>HandleIO</code> monad: it doesn't take into account the
possibility that we might occasionally need an escape hatch. If we
define a monad like this, it is likely that we will occasionally need to
perform an I/O action that isn't allowed for by the design of our
monad.</p>
<p>Our purpose in defining a monad like this is to make it easier for us
to write solid code in the common case, not to make corner cases
impossible. Let's thus give ourselves a way out.</p>
<p>The <code>Control.Monad.Trans</code> module defines a "standard
escape hatch", the <code>MonadIO</code> type class. This defines a
single function, <code>liftIO</code>, which lets us embed an
<code>IO</code> action in another monad.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Monad.Trans
ghci&gt; :info MonadIO
class Monad m =&gt; MonadIO (m :: * -&gt; *) where
  liftIO :: IO a -&gt; m a
  {-# MINIMAL liftIO #-}
        -- Defined in ‘Control.Monad.IO.Class’
instance [safe] MonadIO IO -- Defined in ‘Control.Monad.IO.Class’
</code></pre>
<p>Our implementation of this type class is trivial: we just wrap
<code>IO</code> with our data constructor.</p>
<div class="captioned-content">
<div class="caption">
HandleIO.hs
</div>
<div class="sourceCode" id="cb63"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadIO</span> <span class="dt">HandleIO</span> <span class="kw">where</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>    liftIO <span class="ot">=</span> <span class="dt">HandleIO</span></span></code></pre></div>
</div>
<p>With judicious use of <code>liftIO</code>, we can escape our shackles
and invoke <code>IO</code> actions where necessary.</p>
<div class="captioned-content">
<div class="caption">
HandleIO.hs
</div>
<div class="sourceCode" id="cb64"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tidyHello ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">HandleIO</span> ()</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>tidyHello path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>  safeHello path</span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>  liftIO (removeFile path)</span></code></pre></div>
</div>
<div class="TIP">
<p>Automatic derivation and <code>MonadIO</code></p>
<p>We could have had the compiler automatically derive an instance of
<code>MonadIO</code> for us by adding the type class to the
<code>deriving</code> clause of <code>HandleIO</code>. In fact, in
production code, this would be our usual strategy. We avoided that here
simply to separate the presentation of the earlier material from that of
<code>MonadIO</code>.</p>
</div>
<h2 data-number="8.3" id="using-type-classes"><span
class="header-section-number">8.3</span> Using type classes</h2>
<p>The disadvantage of hiding <code>IO</code> in another monad is that
we're still tied to a concrete implementation. If we want to swap
<code>HandleIO</code> for some other monad, we must change the type of
every action that uses <code>HandleIO</code>.</p>
<p>As an alternative, we can create a type class that specifies the
interface we want from a monad that manipulates files.</p>
<div class="captioned-content">
<div class="caption">
MonadHandle.hs
</div>
<div class="sourceCode" id="cb65"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies, MultiParamTypeClasses #-}</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">MonadHandle</span> (<span class="dt">MonadHandle</span>(<span class="op">..</span>)) <span class="kw">where</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (<span class="dt">IOMode</span>(..))</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadHandle</span> h m <span class="op">|</span> m <span class="ot">-&gt;</span> h <span class="kw">where</span></span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a><span class="ot">    openFile ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IOMode</span> <span class="ot">-&gt;</span> m h</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    hPutStr ::</span> h <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a><span class="ot">    hClose ::</span> h <span class="ot">-&gt;</span> m ()</span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="ot">    hGetContents ::</span> h <span class="ot">-&gt;</span> m <span class="dt">String</span></span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a><span class="ot">    hPutStrLn ::</span> h <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>    hPutStrLn h s <span class="ot">=</span> hPutStr h s <span class="op">&gt;&gt;</span> hPutStr h <span class="st">&quot;\n&quot;</span></span></code></pre></div>
</div>
<p>Here, we've chosen to abstract away both the type of the monad and
the type of a file handle. To satisfy the type checker, we've added a
functional dependency: for any instance of <code>MonadHandle</code>,
there is exactly one handle type that we can use. When we make the
<code>IO</code> monad an instance of this class, we use a regular
Handle.</p>
<div class="captioned-content">
<div class="caption">
MonadHandleIO.hs
</div>
<div class="sourceCode" id="cb66"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FunctionalDependencies, MultiParamTypeClasses #-}</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MonadHandle</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">System.IO</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span> (<span class="dt">IOMode</span>(..))</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Trans</span> (<span class="dt">MonadIO</span>(..), <span class="dt">MonadTrans</span>(..))</span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span> (removeFile)</span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">SafeHello</span></span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadHandle</span> <span class="dt">System.IO.Handle</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>    openFile <span class="ot">=</span> System.IO.openFile</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>    hPutStr <span class="ot">=</span> System.IO.hPutStr</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>    hClose <span class="ot">=</span> System.IO.hClose</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>    hGetContents <span class="ot">=</span> System.IO.hGetContents</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>    hPutStrLn <span class="ot">=</span> System.IO.hPutStrLn</span></code></pre></div>
</div>
<p>Because any <code>MonadHandle</code> must also be a
<code>Monad</code>, we can write code that manipulates files using
normal <code>do</code> notation, without caring what monad it will
finally execute in.</p>
<div class="captioned-content">
<div class="caption">
SafeHello.hs
</div>
<div class="sourceCode" id="cb67"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">SafeHello</span> <span class="kw">where</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MonadHandle</span></span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span>(<span class="dt">IOMode</span>(..))</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a><span class="ot">safeHello ::</span> <span class="dt">MonadHandle</span> h m <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>safeHello path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> openFile path <span class="dt">WriteMode</span></span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a>  hPutStrLn h <span class="st">&quot;hello world&quot;</span></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>  hClose h</span></code></pre></div>
</div>
<p>Because we made <code>IO</code> an instance of this type class, we
can execute this action from <code>ghci</code>.</p>
<pre class="screen"><code>ghci&gt; :l MonadHandleIo.hs
[1 of 3] Compiling MonadHandle      ( MonadHandle.hs, interpreted )
[2 of 3] Compiling SafeHello        ( SafeHello.hs, interpreted )
[3 of 3] Compiling Main             ( MonadHandleIo.hs, interpreted )
Ok, three modules loaded.
ghci&gt; safeHello &quot;hello to my fans in domestic surveillance&quot;
ghci&gt; removeFile &quot;hello to my fans in domestic surveillance&quot;
</code></pre>
<p>The beauty of the type class approach is that we can swap one
underlying monad for another without touching much code, as most of our
code doesn't know or care about the implementation. For instance, we
could replace <code>IO</code> with a monad that compresses files as it
writes them out.</p>
<p>Defining a monad's interface through a type class has a further
benefit. It lets other people hide our implementation in a
<code>newtype</code> wrapper, and automatically derive instances of just
the type classes they want to expose.</p>
<h2 data-number="8.4" id="isolation-and-testing"><span
class="header-section-number">8.4</span> Isolation and testing</h2>
<p>In fact, because our <code>safeHello</code> function doesn't use the
<code>IO</code> type, we can even use a monad that <em>can't</em>
perform I/O. This allows us to test code that would normally have side
effects in a completely pure, controlled environment.</p>
<p>To do this, we will create a monad that doesn't perform I/O, but
instead logs every file-related event for later processing.</p>
<div class="captioned-content">
<div class="caption">
WriterIO.hs
</div>
<div class="sourceCode" id="cb69"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span></span>
<span id="cb69-3"><a href="#cb69-3" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></span>
<span id="cb69-4"><a href="#cb69-4" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE TypeSynonymInstances #-}</span></span>
<span id="cb69-5"><a href="#cb69-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-6"><a href="#cb69-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad.Writer</span></span>
<span id="cb69-7"><a href="#cb69-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MonadHandle</span></span>
<span id="cb69-8"><a href="#cb69-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">SafeHello</span></span>
<span id="cb69-9"><a href="#cb69-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span>(<span class="dt">IOMode</span>(..))</span>
<span id="cb69-10"><a href="#cb69-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb69-11"><a href="#cb69-11" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Event</span> <span class="ot">=</span> <span class="dt">Open</span> <span class="dt">FilePath</span> <span class="dt">IOMode</span></span>
<span id="cb69-12"><a href="#cb69-12" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Put</span> <span class="dt">String</span> <span class="dt">String</span></span>
<span id="cb69-13"><a href="#cb69-13" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">Close</span> <span class="dt">String</span></span>
<span id="cb69-14"><a href="#cb69-14" aria-hidden="true" tabindex="-1"></a>           <span class="op">|</span> <span class="dt">GetContents</span> <span class="dt">String</span></span>
<span id="cb69-15"><a href="#cb69-15" aria-hidden="true" tabindex="-1"></a>             <span class="kw">deriving</span> (<span class="dt">Show</span>)</span></code></pre></div>
</div>
<p>Although we already developed a <code>Logger</code> type in <a
href="15-monads.org::*Using a new monad: show your work!">the section
called "Using a new monad: show your work!"</a> we'll use the standard,
and more general, <code>Writer</code> monad. Like other <code>mtl</code>
monads, the API provided by <code>Writer</code> is defined in a type
class, in this case <code>MonadWriter</code>. Its most useful method is
<code>tell</code>, which logs a value.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Monad.Writer
ghci&gt; :type tell
tell :: MonadWriter w m =&gt; w -&gt; m ()
</code></pre>
<p>The values we log can be of any <code>Monoid</code> type. Since the
list type is a <code>Monoid</code>, we'll log to a list of
<code>Event</code>.</p>
<p>We could make <code>Writer [Event]</code> an instance of
<code>MonadHandle</code>, but it's cheap, easy, and safer to make a
special-purpose monad.</p>
<div class="captioned-content">
<div class="caption">
WriterIO.hs
</div>
<div class="sourceCode" id="cb71"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">WriterIO</span> a <span class="ot">=</span> <span class="dt">W</span> {<span class="ot"> runW ::</span> <span class="dt">Writer</span> [<span class="dt">Event</span>] a }</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Monad</span>, <span class="dt">MonadWriter</span> [<span class="dt">Event</span>])</span></code></pre></div>
</div>
<p>Our execution function simply removes the <code>newtype</code>
wrapper we added, then calls the normal Writer monad's execution
function.</p>
<div class="captioned-content">
<div class="caption">
WriterIO.hs
</div>
<div class="sourceCode" id="cb72"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runWriterIO ::</span> <span class="dt">WriterIO</span> a <span class="ot">-&gt;</span> (a, [<span class="dt">Event</span>])</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>runWriterIO <span class="ot">=</span> runWriter <span class="op">.</span> runW</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">WriterIO</span> <span class="kw">where</span></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">fmap</span> <span class="ot">=</span> liftM</span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">WriterIO</span> <span class="kw">where</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> <span class="ot">=</span> <span class="fu">return</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a>    (<span class="op">&lt;*&gt;</span>) <span class="ot">=</span> ap</span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadHandle</span> <span class="dt">FilePath</span> <span class="dt">WriterIO</span> <span class="kw">where</span></span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>    openFile path mode <span class="ot">=</span> tell [<span class="dt">Open</span> path mode] <span class="op">&gt;&gt;</span> <span class="fu">return</span> path</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>    hPutStr h str <span class="ot">=</span> tell [<span class="dt">Put</span> h str]</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a>    hClose h <span class="ot">=</span> tell [<span class="dt">Close</span> h]</span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>    hGetContents h <span class="ot">=</span> tell [<span class="dt">GetContents</span> h] <span class="op">&gt;&gt;</span> <span class="fu">return</span> <span class="st">&quot;&quot;</span></span></code></pre></div>
</div>
<p>When we try this code out in <code>ghci</code>, it gives us a log of
the function's file activities.</p>
<pre class="screen"><code>ghci&gt; :load WriterIO
[1 of 3] Compiling MonadHandle      ( MonadHandle.hs, interpreted )
[2 of 3] Compiling SafeHello        ( SafeHello.hs, interpreted )
[3 of 3] Compiling Main             ( WriterIo.hs, interpreted )
Ok, three modules loaded.
ghci&gt; runWriterIO (safeHello &quot;foo&quot;)
((),[Open &quot;foo&quot; WriteMode,Put &quot;foo&quot; &quot;hello world&quot;,Put &quot;foo&quot; &quot;\n&quot;,Close &quot;foo&quot;])
</code></pre>
<h2 data-number="8.5" id="the-writer-monad-and-lists"><span
class="header-section-number">8.5</span> The writer monad and lists</h2>
<p>The writer monad uses the monoid's <code>mappend</code> function
every time we use <code>tell</code>. Because <code>mappend</code> for
lists is <code>(++)</code>, lists are not a good practical choice for
use with <code>Writer</code>: repeated appends are expensive. We use
lists above purely for simplicity.</p>
<p>In production code, if you want to use the <code>Writer</code> monad
and you need list-like behaviour, use a type with better append
characteristics. One such type is the difference list, which we
introduced in <a
href="13-data-structures.org::*Taking advantage of functions as data">the
section called "Taking advantage of functions as data"</a> You don't
need to roll your own difference list implementation: a well tuned
library is available for download from Hackage, the Haskell package
database. Alternatively, you can use the <code>Seq</code> type from the
<code>Data.Sequence</code> module, which we introduced in <a
href="13-data-structures.org::*General purpose sequences">the section
called "General purpose sequences"</a></p>
<h2 data-number="8.6" id="arbitrary-io-revisited"><span
class="header-section-number">8.6</span> Arbitrary I/O revisited</h2>
<p>If we use the type class approach to restricting <code>IO</code>, we
may still want to retain the ability to perform arbitrary I/O actions.
We might try adding <code>MonadIO</code> as a constraint on our type
class.</p>
<div class="captioned-content">
<div class="caption">
MonadHandleIO.hs
</div>
<div class="sourceCode" id="cb74"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">MonadHandle</span> h m, <span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadHandleIO</span> h m <span class="op">|</span> m <span class="ot">-&gt;</span> h</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadHandleIO</span> <span class="dt">System.IO.Handle</span> <span class="dt">IO</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a><span class="ot">tidierHello ::</span> (<span class="dt">MonadHandleIO</span> h m) <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>tidierHello path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>  safeHello path</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>  liftIO (removeFile path)</span></code></pre></div>
</div>
<p>This approach has a problem, though: the added <code>MonadIO</code>
constraint loses us the ability to test our code in a pure environment,
because we can no longer tell whether a test might have damaging side
effects. The alternative is to move this constraint from the type class,
where it "infects" all functions, to only those functions that really
need to perform I/O.</p>
<div class="captioned-content">
<div class="caption">
MonadHandleIO.hs
</div>
<div class="sourceCode" id="cb75"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="ot">tidyHello ::</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadHandle</span> h m) <span class="ot">=&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>tidyHello path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>  safeHello path</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>  liftIO (removeFile path)</span></code></pre></div>
</div>
<p>We can use pure property tests on the functions that lack
<code>MonadIO</code> constraints, and traditional unit tests on the
rest.</p>
<p>Unfortunately, we've substituted one problem for another: we can't
invoke code with both <code>MonadIO</code> and <code>MonadHandle</code>
constraints from code that has the <code>MonadHandle</code> constraint
alone. If we find that somewhere deep in our
<code>MonadHandle</code>-only code, we really need the
<code>MonadIO</code> constraint, we must add it to all the code paths
that lead to this point.</p>
<p>Allowing arbitrary I/O is risky, and has a profound effect on how we
develop and test our code. When we have to choose between being
permissive on the one hand, and easier reasoning and testing on the
other, we usually opt for the latter.</p>
<h2 data-number="8.7" id="exercises"><span
class="header-section-number">8.7</span> Exercises</h2>
<ol>
<li>Using QuickCheck, write a test for an action in the
<code>MonadHandle</code> monad, in order to see if it tries to write to
a file handle that is not open. Try it out on
<code>safeHello</code>.</li>
<li>Write an action that tries to write to a file handle that it has
closed. Does your test catch this bug?</li>
<li>In a form-encoded string, the same key may appear several times,
with or without values, e.g., <code>key&amp;key=1&amp;key=2</code>. What
type might you use to represent the values associated with a key in this
sort of string? Write a parser that correctly captures all of the
information.</li>
</ol>
</body>
</html>
