<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 9: I/O case study: a library for searching the filesystem</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 9: I/O case study: a library for searching the
filesystem</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#the-find-command"><span
class="toc-section-number">1</span> The find command</a></li>
<li><a href="#starting-simple-recursively-listing-a-directory"><span
class="toc-section-number">2</span> Starting simple: recursively listing
a directory</a>
<ul>
<li><a href="#revisiting-anonymous-and-named-functions"><span
class="toc-section-number">2.1</span> Revisiting anonymous and named
functions</a></li>
<li><a href="#why-provide-both-mapm-and-form"><span
class="toc-section-number">2.2</span> Why provide both <code>mapM</code>
and <code>forM</code>?</a></li>
</ul></li>
<li><a href="#a-naive-finding-function"><span
class="toc-section-number">3</span> A naive finding function</a></li>
<li><a
href="#predicates-from-poverty-to-riches-while-remaining-pure"><span
class="toc-section-number">4</span> Predicates: from poverty to riches,
while remaining pure</a></li>
<li><a href="#sizing-a-file-safely"><span
class="toc-section-number">5</span> Sizing a file safely</a>
<ul>
<li><a href="#the-acquire-use-release-cycle"><span
class="toc-section-number">5.1</span> The acquire-use-release
cycle</a></li>
</ul></li>
<li><a href="#a-domain-specific-language-for-predicates"><span
class="toc-section-number">6</span> A domain specific language for
predicates</a>
<ul>
<li><a href="#avoiding-boilerplate-with-lifting"><span
class="toc-section-number">6.1</span> Avoiding boilerplate with
lifting</a></li>
<li><a href="#gluing-predicates-together"><span
class="toc-section-number">6.2</span> Gluing predicates
together</a></li>
<li><a href="#defining-and-using-new-operators"><span
class="toc-section-number">6.3</span> Defining and using new
operators</a></li>
</ul></li>
<li><a href="#controlling-traversal"><span
class="toc-section-number">7</span> Controlling traversal</a>
<ul>
<li><a href="#exercises-1"><span class="toc-section-number">7.1</span>
Exercises</a></li>
</ul></li>
<li><a href="#density-readability-and-the-learning-process"><span
class="toc-section-number">8</span> Density, readability, and the
learning process</a></li>
<li><a href="#another-way-of-looking-at-traversal"><span
class="toc-section-number">9</span> Another way of looking at
traversal</a>
<ul>
<li><a href="#exercises-2"><span class="toc-section-number">9.1</span>
Exercises</a></li>
</ul></li>
<li><a href="#useful-coding-guidelines"><span
class="toc-section-number">10</span> Useful coding guidelines</a>
<ul>
<li><a href="#common-layout-styles"><span
class="toc-section-number">10.1</span> Common layout styles</a></li>
</ul></li>
<li><a href="#exercises-3"><span class="toc-section-number">11</span>
Exercises</a></li>
<li><a href="#footnotes"><span class="toc-section-number">12</span>
Footnotes</a></li>
</ul>
</nav>
<h1 data-number="1" id="the-find-command"><span
class="header-section-number">1</span> The find command</h1>
<p>If you don't use a Unix-like operating system, or you're not a heavy
shell user, it's quite possible you may not have heard of
<code>find</code>. Given a list of directories, it searches each one
recursively and prints the name of every entry that matches an
expression.</p>
<p>Individual expressions can take such forms as "name matches this glob
pattern", "entry is a plain file", "last modified before this date", and
many more. They can be stitched together into more complex expressions
using "and" and "or" operators.</p>
<h1 data-number="2"
id="starting-simple-recursively-listing-a-directory"><span
class="header-section-number">2</span> Starting simple: recursively
listing a directory</h1>
<p>Before we plunge into designing our library, let's solve a few
smaller problems. Our first problem is to recursively list the contents
of a directory and its subdirectories.</p>
<div class="captioned-content">
<div class="caption">
RecursiveContents.hs
</div>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">RecursiveContents</span> (getRecursiveContents) <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span> (doesDirectoryExist, getDirectoryContents)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.FilePath</span> ((&lt;/&gt;))</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="ot">getRecursiveContents ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">FilePath</span>]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>getRecursiveContents topdir <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>  names <span class="ot">&lt;-</span> getDirectoryContents topdir</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> properNames <span class="ot">=</span> <span class="fu">filter</span> (<span class="ot">`notElem`</span> [<span class="st">&quot;.&quot;</span>, <span class="st">&quot;..&quot;</span>]) names</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>  paths <span class="ot">&lt;-</span> forM properNames <span class="op">$</span> \name <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> path <span class="ot">=</span> topdir <span class="op">&lt;/&gt;</span> name</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    isDirectory <span class="ot">&lt;-</span> doesDirectoryExist path</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">if</span> isDirectory</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>      <span class="kw">then</span> getRecursiveContents path</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>      <span class="kw">else</span> <span class="fu">return</span> [path]</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">concat</span> paths)</span></code></pre></div>
</div>
<p>The <code>filter</code> expression ensures that a listing for a
single directory won't contain the special directory names
<code>.</code> or <code>..</code>, which refer to the current and parent
directory, respectively. If we forgot to filter these out, we'd recurse
endlessly.</p>
<p>We encountered <code>forM</code> in the previous chapter; it is
<code>mapM</code> with its arguments flipped.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Monad
ghci&gt; :type mapM
mapM :: (Monad m, Traversable t) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
ghci&gt; :type forM
forM :: (Monad m, Traversable t) =&gt; t a -&gt; (a -&gt; m b) -&gt; m (t b)
</code></pre>
<p>The body of the loop checks to see whether the current entry is a
directory. If it is, it recursively calls
<code>getRecursiveContents</code> to list that directory. Otherwise, it
returns a single-element list that is the name of the current entry.
(Don't forget that the <code>return</code> function has a unique meaning
in Haskell: it wraps a value with the monad's type constructor.)</p>
<p>Another thing worth pointing out is the use of the variable
<code>isDirectory</code>. In an imperative language such as Python, we'd
normally write <code>if os.path.isdir(path)</code>. However, the
<code>doesDirectoryExist</code> function is an <em>action</em>; its
return type is <code>IO Bool</code>, not <code>Bool</code>. Since an
<code>if</code> expression requires an expression of type
<code>Bool</code>, we have to use <code>&lt;-</code> to get the
<code>Bool</code> result of the action out of its <code>IO</code>
wrapper, so that we can use the plain, unwrapped <code>Bool</code> in
the <code>if</code>.</p>
<p>Each iteration of the loop body yields a list of names, so the result
of <code>forM</code> here is <code>IO [[FilePath]]</code>. We use
<code>concat</code> to flatten it into a single list.</p>
<h2 data-number="2.1"
id="revisiting-anonymous-and-named-functions"><span
class="header-section-number">2.1</span> Revisiting anonymous and named
functions</h2>
<p>In <a
href="4-functional-programming.org::*Anonymous (lambda) functions">the
section called "Anonymous (lambda) functions"</a> some reasons not to
use anonymous functions, and yet here we are, using one as the body of a
loop. This is one of the most common uses of anonymous functions in
Haskell.</p>
<p>We've already seen from their types that <code>forM</code> and
<code>mapM</code> take functions as arguments. Most loop bodies are
blocks of code that only appear once in a program. Since we're most
likely to use a loop body in only one place, why give it a name?</p>
<p>Of course, it sometimes happens that we need to deploy exactly the
same code in several different loops. Rather than cutting and pasting
the same anonymous function, it makes sense in such cases to give a name
to an existing anonymous function.</p>
<h2 data-number="2.2" id="why-provide-both-mapm-and-form"><span
class="header-section-number">2.2</span> Why provide both
<code>mapM</code> and <code>forM</code>?</h2>
<p>It might seem a bit odd that there exist two functions that are
identical but for the order in which they accept their arguments.
However, <code>mapM</code> and <code>forM</code> are convenient in
different circumstances.</p>
<p>Consider our example above, using an anonymous function as a loop
body. If we were to use <code>mapM</code> instead of <code>forM</code>,
we'd have to place the variable <code>properNames</code> after the body
of the function. In order to get the code to parse correctly, we'd have
to wrap the entire anonymous function in parentheses, or replace it with
a named function that would otherwise be unnecessary. Try it yourself:
copy the code above, replacing <code>forM</code> with <code>mapM</code>,
and see what this does to the readability of the code.</p>
<p>By contrast, if the body of the loop was already a named function,
and the list over which we were looping was computed by a complicated
expression, we'd have a good case for using <code>mapM</code>
instead.</p>
<p>The stylistic rule of thumb to follow here is to use whichever of
<code>mapM</code> or <code>forM</code> lets you write the tidiest code.
If the loop body and the expression computing the data over which you're
looping are both short, it doesn't matter which you use. If the loop is
short, but the data is long, use <code>mapM</code>. If the loop is long,
but the data short, use <code>forM</code>. And if both are long, use a
<code>let</code> or <code>where</code> clause to make one of them short.
With just a little practice, it will become obvious which of these
approaches is best in every instance.</p>
<h1 data-number="3" id="a-naive-finding-function"><span
class="header-section-number">3</span> A naive finding function</h1>
<p>We can use our <code>getRecursiveContents</code> function as the
basis for a simple-minded file finder.</p>
<div class="captioned-content">
<div class="caption">
SimpleFinder.hs
</div>
<div class="sourceCode" id="cb3"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RecursiveContents</span> (getRecursiveContents)</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleFind ::</span> (<span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">FilePath</span>]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>simpleFind p path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  names <span class="ot">&lt;-</span> getRecursiveContents path</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="fu">filter</span> p names)</span></code></pre></div>
</div>
<p>This function takes a predicate that we use to filter the names
returned by <code>getRecursiveContents</code>. Each name passed to the
predicate is a complete path, so how can we perform a common operation
like "find all files ending in the extension <code>.c</code>"?</p>
<p>The <code>System.FilePath</code> module contains numerous invaluable
functions that help us to manipulate file names. In this case, we want
<code>takeExtension</code>.</p>
<pre class="screen"><code>ghci&gt; :m +System.FilePath
ghci&gt; :type takeExtension
takeExtension :: FilePath -&gt; String
ghci&gt; takeExtension &quot;foo/bar.c&quot;
&quot;.c&quot;
ghci&gt; takeExtension &quot;quux&quot;
&quot;&quot;
</code></pre>
<p>This gives us a simple matter of writing a function that takes a
path, extracts its extension, and compares it with <code>.c</code>.</p>
<pre class="screen"><code>ghci&gt; :load SimpleFinder
[1 of 2] Compiling RecursiveContents ( RecursiveContents.hs, interpreted )
[2 of 2] Compiling Main             ( SimpleFinder.hs, interpreted )
Ok, two modules loaded.
ghci&gt; :type simpleFind (\p -&gt; takeExtension p == &quot;.c&quot;)
simpleFind (\p -&gt; takeExtension p == &quot;.c&quot;) :: FilePath -&gt; IO [FilePath]
</code></pre>
<p>While <code>simpleFind</code> works, it has a few glaring problems.
The first is that the predicate is not very expressive. It can only look
at the name of a directory entry; it cannot, for example, find out
whether it's a file or a directory. This means that our attempt to use
<code>simpleFind</code> will list directories ending in <code>.c</code>
as well as files with the same extension.</p>
<p>The second problem is that <code>simpleFind</code> gives us no
control over how it traverses the filesystem. To see why this is
significant, consider the problem of searching for a source file in a
tree managed by the Subversion revision control system. Subversion
maintains a private <code>.svn</code> directory in every directory that
it manages; each one contains many subdirectories and files that are of
no interest to us. While we can easily enough filter out any path
containing <code>.svn</code>, it's more efficient to simply avoid
traversing these directories in the first place. For example, one of us
has a Subversion source tree containing 45,000 files, 30,000 of which
are stored in 1,200 different <code>.svn</code> directories. It's
cheaper to avoid traversing those 1,200 directories than to filter out
the 30,000 files they contain.</p>
<p>Finally, <code>simpleFind</code> is strict, because it consists of a
series of actions executed in the IO monad. If we have a million files
to traverse, we encounter a long delay, then receive one huge result
containing a million names. This is bad for both resource usage and
responsiveness. We might prefer a lazy stream of results delivered as
they arrive.</p>
<p>In the sections that follow, we'll overcome each one of these
problems.</p>
<h1 data-number="4"
id="predicates-from-poverty-to-riches-while-remaining-pure"><span
class="header-section-number">4</span> Predicates: from poverty to
riches, while remaining pure</h1>
<p>Our predicates can only look at file names. This excludes a wide
variety of interesting behaviours: for instance, what if we'd like to
list files of greater than a given size?</p>
<p>An easy reaction to this is to reach for <code>IO</code>: instead of
our predicate being of type <code>FilePath -&gt; Bool</code>, why don't
we change it to <code>FilePath -&gt; IO Bool</code>? This would let us
perform arbitrary I/O as part of our predicate. As appealing as this
might seem, it's also potentially a problem: such a predicate could have
arbitrary side effects, since a function with return type
<code>IO</code> a can have whatever side effects it pleases.</p>
<p>Let's enlist the type system in our quest to write more predictable,
less buggy code: we'll keep predicates pure by avoiding the taint of
"IO". This will ensure that they can't have any nasty side effects.
We'll feed them more information, too, so that they can gain the
expressiveness we want without also becoming potentially dangerous.</p>
<p>Haskell's portable <code>System.Directory</code> module provides a
useful, albeit limited, set of file metadata.</p>
<pre class="screen"><code>ghci&gt; :m +System.Directory
</code></pre>
<ul>
<li><p>We can use <code>doesFileExist</code> and
<code>doesDirectoryExist</code> to determine whether a directory entry
is a file or a directory. There are not yet portable ways to query for
other file types that have become widely available in recent years, such
as named pipes, hard links and symbolic links.</p>
<pre class="screen"><code>ghci&gt; :type doesFileExist
doesFileExist :: FilePath -&gt; IO Bool
ghci&gt; doesFileExist &quot;.&quot;
False
ghci&gt; :type doesDirectoryExist
doesDirectoryExist :: FilePath -&gt; IO Bool
ghci&gt; doesDirectoryExist &quot;.&quot;
True
</code></pre></li>
<li><p>The <code>getPermissions</code> function lets us find out whether
certain operations on a file or directory are allowed.</p>
<pre class="screen"><code>ghci&gt; :type getPermissions
getPermissions :: FilePath -&gt; IO Permissions
ghci&gt; :info Permissions
data Permissions
  = System.Directory.Permissions {readable :: Bool,
                                  writable :: Bool,
                                  executable :: Bool,
                                  searchable :: Bool}
        -- Defined in ‘System.Directory’
instance [safe] Eq Permissions -- Defined in ‘System.Directory’
instance [safe] Ord Permissions -- Defined in ‘System.Directory’
instance [safe] Show Permissions -- Defined in ‘System.Directory’
instance [safe] Read Permissions -- Defined in ‘System.Directory’
ghci&gt; getPermissions &quot;.&quot;
Permissions {readable = True, writable = True, executable = False, searchable = True}
ghci&gt; :type searchable
searchable :: Permissions -&gt; Bool
ghci&gt; searchable it
True
</code></pre>
<p>(If you cannot recall the special <code>ghci</code> variable
<code>it</code>, take a look back at <a
href="1-getting-started.org::*First steps with types">the section called
"First steps with types"</a> A directory will be <code>searchable</code>
if we have permission to list its contents; files are never
<code>searchable</code>.</p></li>
<li><p>Finally, <code>getModificationTime</code> tells us when an entry
was last modified.</p>
<pre class="screen"><code>ghci&gt; :type getModificationTime
getModificationTime
  :: FilePath
     -&gt; IO time-1.8.0.2:Data.Time.Clock.Internal.UTCTime.UTCTime
ghci&gt; getModificationTime &quot;.&quot;
2018-05-20 22:59:06 UTC
</code></pre></li>
</ul>
<p>If we stick with portable, standard Haskell code, these functions are
all we have at our disposal. (We can also find a file's size using a
small hack; see below.) They're also quite enough to let us illustrate
the principles we're interested in, without letting us get carried away
with an example that's too expansive. If you need to write more
demanding code, the <code>System.Posix</code> and
<code>System.Win32</code> module families provide much more detailed
file metadata for the two major modern computing platforms. There also
exists a <code>unix-compat</code> package on Hackage, which provides a
Unix-like API on Windows.</p>
<p>How many pieces of data does our new, richer predicate need to see?
Since we can find out whether an entry is a file or a directory by
looking at its permissions, we don't need to pass in the results of
<code>doesFileExist</code> or <code>doesDirectoryExist</code>. We thus
have four pieces of data that a richer predicate needs to look at.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>  ( bracket</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>  , handle</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>  , <span class="dt">SomeException</span>(<span class="op">..</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (filterM)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">Permissions</span>(<span class="op">..</span>)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>  , getModificationTime</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>  , getPermissions</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.FilePath</span> (takeExtension)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>  ( <span class="dt">IOMode</span>(<span class="op">..</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>  , hClose</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>  , hFileSize</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>  , openFile</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time.Clock</span> (<span class="dt">UTCTime</span>(..))</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="co">-- the function we wrote earlier</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">RecursiveContents</span> (getRecursiveContents)</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Predicate</span> <span class="ot">=</span>  <span class="dt">FilePath</span>      <span class="co">-- path to directory entry</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">Permissions</span>   <span class="co">-- permissions</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Integer</span> <span class="co">-- file size (Nothing if not file)</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>       <span class="co">-- last modified</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>               <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
</div>
<p>Our <code>Predicate</code> type is just a synonym for a function of
four arguments. It will save us a little keyboard work and screen
space.</p>
<p>Notice that the return value of this predicate is <code>Bool</code>,
not <code>IO
Bool</code>: the predicate is pure, and cannot perform I/O. With this
type in hand, our more expressive finder function is still quite
trim.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- soon to be defined</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="ot">getFileSize ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Integer</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="ot">betterFind ::</span> <span class="dt">Predicate</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">FilePath</span>]</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>betterFind p path <span class="ot">=</span> getRecursiveContents path <span class="op">&gt;&gt;=</span> filterM check</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> check name <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            perms <span class="ot">&lt;-</span> getPermissions name</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            size <span class="ot">&lt;-</span> getFileSize name</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            modified <span class="ot">&lt;-</span> getModificationTime name</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="fu">return</span> (p name perms size modified)</span></code></pre></div>
</div>
<p>Let's walk through the code. We'll talk about
<code>getFileSize</code> in some detail soon, so let's skip over it for
now.</p>
<p>We can't use <code>filter</code> to call our predicate
<code>p</code>, as <code>p</code>'s purity means it cannot do the I/O
needed to gather the metadata it requires.</p>
<p>This leads us to the unfamiliar function <code>filterM</code>. It
behaves like the normal <code>filter</code> function, but in this case
it evaluates its predicate in the IO monad, allowing the predicate to
perform I/O.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Monad
ghci&gt; :type filterM
filterM :: Applicative m =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]
</code></pre>
<p>Our <code>check</code> predicate is an I/O-capable wrapper for our
pure predicate <code>p</code>. It does all the "dirty" work of I/O on
<code>p</code>'s behalf, so that we can keep <code>p</code> incapable of
unwanted side effects. After gathering the metadata, <code>check</code>
calls <code>p</code>, then uses <code>return</code> to wrap
<code>p</code>'s result with IO.</p>
<h1 data-number="5" id="sizing-a-file-safely"><span
class="header-section-number">5</span> Sizing a file safely</h1>
<p>Although <code>System.Directory</code> doesn't let us find out how
large a file is, we can use the similarly portable
<code>System.IO</code> module to do this. It contains a function named
<code>hFileSize</code>, which returns the size in bytes of an open file.
Here's a simple function that wraps it.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleFileSize ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Integer</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>simpleFileSize path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> openFile path <span class="dt">ReadMode</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>  size <span class="ot">&lt;-</span> hFileSize h</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>  hClose h</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> size</span></code></pre></div>
</div>
<p>While this function works, it's not yet suitable for us to use. In
<code>betterFind</code>, we call <code>getFileSize</code>
unconditionally on any directory entry; it should return
<code>Nothing</code> if an entry is not a plain file, or the size
wrapped by <code>Just</code> otherwise. This function instead throws an
exception if an entry is not a plain file or could not be opened
(perhaps due to insufficient permissions), and returns the size
unwrapped.</p>
<p>Here's a safer version of this function.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb14"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ot">saferFileSize ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Integer</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>saferFileSize path <span class="ot">=</span> handle (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span>) <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>  h <span class="ot">&lt;-</span> openFile path <span class="dt">ReadMode</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>  size <span class="ot">&lt;-</span> hFileSize h</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>  hClose h</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Just</span> size)</span></code></pre></div>
</div>
<p>The body of the function is almost identical, save for the
<code>handle</code> clause.</p>
<p>Our exception handler above ignores the exception it's passed, and
returns <code>Nothing</code>. The only change to the body that follows
is that it wraps the file size with <code>Just</code>.</p>
<p>The <code>saferFileSize</code> function now has the correct type
signature, and it won't throw any exceptions. But it's still not
completely well behaved. There are directory entries on which
<code>openFile</code> will succeed, but <code>hFileSize</code> will
throw an exception. This can happen with, for example, named pipes. Such
an exception will be caught by <code>handle</code>, but our call to
<code>hClose</code> will never occur.</p>
<p>A Haskell implementation will automatically close the file handle
when it notices that the handle is no longer being used. That will not
occur until the garbage collector runs, and the delay until the next
garbage collection pass is not predictable.</p>
<p>File handles are scarce resources. Their scarcity is enforced by the
underlying operating system. On Linux, for example, a process is by
default only allowed to have 1024 files open simultaneously.</p>
<p>It's not hard to imagine a scenario in which a program that called a
version of <code>betterFind</code> that used <code>saferFileSize</code>
could crash due to <code>betterFind</code> exhausting the supply of open
file handles before enough garbage file handles could be closed.</p>
<p>This is a particularly pernicious kind of bug: it has several aspects
that combine to make it incredibly difficult to track down. It will only
be triggered if <code>betterFind</code> visits a sufficiently large
number of non-files to hit the process's limit on open file handles, and
then returns to a caller that tries to open another file before any of
the accumulated garbage file handles is closed.</p>
<p>To make matters worse, any subsequent error will be caused by data
that is no longer reachable from within the program, and has yet to be
garbage collected. Such a bug is thus dependent on the structure of the
program, the contents of the filesystem, and how close the current run
of the program is to triggering the garbage collector.</p>
<p>This sort of problem is easy to overlook during development, and when
it later occurs in the field (as these awkward problems always seem to
do), it will be much harder to diagnose.</p>
<p>Fortunately, we can avoid this kind of error very easily, while also
making our function <em>shorter</em>.</p>
<h2 data-number="5.1" id="the-acquire-use-release-cycle"><span
class="header-section-number">5.1</span> The acquire-use-release
cycle</h2>
<p>We need <code>hClose</code> to always be called if
<code>openFile</code> succeeds. The <code>Control.Exception</code>
module provides the <code>bracket</code> function for exactly this
purpose.</p>
<pre class="screen"><code>ghci&gt; :type bracket
bracket :: IO a -&gt; (a -&gt; IO b) -&gt; (a -&gt; IO c) -&gt; IO c
</code></pre>
<p>The <code>bracket</code> function takes three actions as arguments.
The first action acquires a resource. The second releases the resource.
The third runs in between, while the resource is acquired; let's call
this the "use" action. If the "acquire" action succeeds, the "release"
action is <em>always</em> called. This guarantees that the resource will
always be released. The "use" and "release" actions are each passed the
resource acquired by the "acquire" action.</p>
<p>If an exception occurs while the "use" action is executing,
<code>bracket</code> calls the "release" action and rethrows the
exception. If the "use" action succeeds, <code>bracket</code> calls the
"release" action, and returns the value returned by the "use"
action.</p>
<p>We can now write a function that is completely safe: it will not
throw exceptions; neither will it accumulate garbage file handles that
could cause spurious failures elsewhere in our program.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb16"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>getFileSize path <span class="ot">=</span> handle ((\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span>)<span class="ot"> ::</span> <span class="dt">IOError</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">Integer</span>)) <span class="op">$</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  bracket (openFile path <span class="dt">ReadMode</span>) hClose <span class="op">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    size <span class="ot">&lt;-</span> hFileSize h</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="dt">Just</span> size)</span></code></pre></div>
</div>
<p>Look closely at the arguments of <code>bracket</code> above. The
first opens the file, and returns the open file handle. The second
closes the handle. The third simply calls <code>hFileSize</code> on the
handle and wraps the result in <code>Just</code>.</p>
<p>We need to use both <code>bracket</code> and <code>handle</code> for
this function to operate correctly. The former ensures that we don't
accumulate garbage file handles, while the latter gets rid of
exceptions.</p>
<ol>
<li><p>Exercises</p>
<ol>
<li>Is the order in which we call <code>bracket</code> and
<code>handle</code> important? Why?</li>
</ol></li>
</ol>
<h1 data-number="6" id="a-domain-specific-language-for-predicates"><span
class="header-section-number">6</span> A domain specific language for
predicates</h1>
<p>Let's take a stab at writing a predicate. Our predicate will check
for a C++ source file that is over 128KB in size.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>myTest path _ (<span class="dt">Just</span> size) _ <span class="ot">=</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    takeExtension path <span class="op">==</span> <span class="st">&quot;.cpp&quot;</span> <span class="op">&amp;&amp;</span> size <span class="op">&gt;</span> <span class="dv">131072</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>myTest _ _ _ _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
</div>
<p>This isn't especially pleasing. The predicate takes four arguments,
always ignores two of them, and requires two equations to define. Surely
we can do better. Let's create some code that will help us to write more
concise predicates.</p>
<p>Sometimes, this kind of library is referred to as an <em>embedded
domain specific language</em>: we use our programming language's native
facilities (hence <em>embedded</em>) to write code that lets us solve
some narrow problem (hence <em>domain specific</em>) particularly
elegantly.</p>
<p>Our first step is to write a function that returns one of its
arguments. This one extracts the path from the arguments passed to a
<code>Predicate</code>.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb18"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>pathP path _ _ _ <span class="ot">=</span> path</span></code></pre></div>
</div>
<p>If we don't provide a type signature, a Haskell implementation will
infer a very general type for this function. This can later lead to
error messages that are difficult to interpret, so let's give
<code>pathP</code> a type.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">InfoP</span> a <span class="ot">=</span>  <span class="dt">FilePath</span>        <span class="co">-- path to directory entry</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Permissions</span>     <span class="co">-- permissions</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Integer</span>   <span class="co">-- file size (Nothing if not file)</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> <span class="dt">UTCTime</span>         <span class="co">-- last modified</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>             <span class="ot">-&gt;</span> a</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="ot">pathP ::</span> <span class="dt">InfoP</span> <span class="dt">FilePath</span></span></code></pre></div>
</div>
<p>We've created a type synonym that we can use as shorthand for writing
other, similarly structured functions. Our type synonym accepts a type
parameter so that we can specify different result types.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ot">sizeP ::</span> <span class="dt">InfoP</span> <span class="dt">Integer</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>sizeP _ _ (<span class="dt">Just</span> size) _ <span class="ot">=</span> size</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>sizeP _ _ <span class="dt">Nothing</span>     _ <span class="ot">=</span> <span class="op">-</span><span class="dv">1</span></span></code></pre></div>
</div>
<p>(We're being a little sneaky here, and returning a size of -1 for
entries that are not files, or that we couldn't open.)</p>
<p>In fact, a quick glance shows that the <code>Predicate</code> type
that we defined near the beginning of this chapter is the same type as
<code>InfoP Bool</code>. (We could thus legitimately get rid of the
<code>Predicate</code> type.)</p>
<p>What use are <code>pathP</code> and <code>sizeP</code>? With a little
more glue, we can use them in a predicate (the <code>P</code> suffix on
each name is intended to suggest "predicate"). This is where things
start to get interesting.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ot">equalP ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>equalP f k <span class="ot">=</span> \w x y z <span class="ot">-&gt;</span> f w x y z <span class="op">==</span> k</span></code></pre></div>
</div>
<p>The type signature of <code>equalP</code> deserves a little
attention. It takes an <code>InfoP a</code>, which is compatible with
both <code>pathP</code> and <code>sizeP</code>. It takes an
<code>a</code>. And it returns an <code>InfoP Bool</code>, which we
already observed is a synonym for <code>Predicate</code>. In other
words, <code>equalP</code> constructs a predicate.</p>
<p>The <code>equalP</code> function works by returning an anonymous
function. That one takes the arguments accepted by a predicate, passes
them to <code>f</code>, and compares the result to <code>k</code>.</p>
<p>This equation for <code>equalP</code> emphasises the fact that we
think of it as taking two arguments. Since Haskell curries all
functions, writing <code>equalP</code> in this way is not actually
necessary. We can omit the anonymous function and rely on currying to
work on our behalf, letting us write a function that behaves
identically.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ot">equalP&#39; ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>equalP&#39; f k w x y z <span class="ot">=</span> f w x y z <span class="op">==</span> k</span></code></pre></div>
</div>
<p>Before we continue with our explorations, let's load our module into
<code>ghci</code>.</p>
<pre class="screen"><code>ghci&gt; :load BetterPredicate
[1 of 2] Compiling RecursiveContents ( RecursiveContents.hs, interpreted )
[2 of 2] Compiling Main             ( BetterPredicate.hs, interpreted )
Ok, two modules loaded.
</code></pre>
<p>Let's see if a simple predicate constructed from these functions will
work.</p>
<pre class="screen"><code>ghci&gt; :type betterFind (sizeP `equalP` 1024)
betterFind (sizeP `equalP` 1024) :: FilePath -&gt; IO [FilePath]
</code></pre>
<p>Notice that we're not actually calling <code>betterFind</code>, we're
merely making sure that our expression type-checks. We now have a more
expressive way to list all files that are exactly some size. Our success
gives us enough confidence to continue.</p>
<h2 data-number="6.1" id="avoiding-boilerplate-with-lifting"><span
class="header-section-number">6.1</span> Avoiding boilerplate with
lifting</h2>
<p>Besides <code>equalP</code>, we'd like to be able to write other
binary functions. We'd prefer not to write a complete definition of each
one, because that seems unnecessarily verbose.</p>
<p>To address this, let's put Haskell's powers of abstraction to use.
We'll take the definition of <code>equalP</code>, and instead of calling
<code>(==)</code> directly, we'll pass in as another argument the binary
function that we want to call.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftP ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">InfoP</span> c</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>liftP q f k w x y z <span class="ot">=</span> f w x y z <span class="ot">`q`</span> k</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>greaterP,<span class="ot"> lesserP ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>greaterP <span class="ot">=</span> liftP (<span class="op">&gt;</span>)</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>lesserP <span class="ot">=</span> liftP (<span class="op">&lt;</span>)</span></code></pre></div>
</div>
<p>This act of taking a function, such as <code>(&gt;)</code>, and
transforming it into another function that operates in a different
context, here <code>greaterP</code>, is referred to as <em>lifting</em>
it into that context. This explains the presence of <code>lift</code> in
the function's name. Lifting lets us reuse code and reduce boilerplate.
We'll be using it a lot, in different guises, throughout the rest of
this book.</p>
<p>When we lift a function, we'll often refer to its original and new
versions as <em>unlifted</em> and <em>lifted</em>, respectively.</p>
<p>By the way, our placement of <code>q</code> (the function to lift) as
the first argument to <code>liftP</code> was quite deliberate. This made
it possible for us to write such concise definitions of
<code>greaterP</code> and <code>lesserP</code>. Partial application
makes finding the "best" order for arguments a more important part of
API design in Haskell than in other languages. In languages without
partial application, argument ordering is a matter of taste and
convention. Put an argument in the wrong place in Haskell, however, and
we lose the concision that partial application gives.</p>
<p>We can recover some of that conciseness via combinators. For
instance, <code>forM</code> was not added to the
<code>Control.Monad</code> module until</p>
<ol>
<li>Prior to that, people wrote <code>flip mapM</code> instead.</li>
</ol>
<pre class="screen"><code>ghci&gt; :m +Control.Monad
ghci&gt; :t mapM
mapM :: (Monad m, Traversable t) =&gt; (a -&gt; m b) -&gt; t a -&gt; m (t b)
ghci&gt; :t forM
forM :: (Monad m, Traversable t) =&gt; t a -&gt; (a -&gt; m b) -&gt; m (t b)
ghci&gt; :t flip mapM
flip mapM :: (Monad m, Traversable t) =&gt; t a -&gt; (a -&gt; m b) -&gt; m (t b)
</code></pre>
<h2 data-number="6.2" id="gluing-predicates-together"><span
class="header-section-number">6.2</span> Gluing predicates together</h2>
<p>If we want to combine predicates, we can of course follow the obvious
path of doing so by hand.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ot">simpleAndP ::</span> <span class="dt">InfoP</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">InfoP</span> <span class="dt">Bool</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>simpleAndP f g w x y z <span class="ot">=</span> f w x y z <span class="op">&amp;&amp;</span> g w x y z</span></code></pre></div>
</div>
<p>Now that we know about lifting, it becomes more natural to reduce the
amount of code we must write by lifting our existing boolean
operators.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftP2 ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">InfoP</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> b <span class="ot">-&gt;</span> <span class="dt">InfoP</span> c</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>liftP2 q f g w x y z <span class="ot">=</span> f w x y z <span class="ot">`q`</span> g w x y z</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>andP <span class="ot">=</span> liftP2 (<span class="op">&amp;&amp;</span>)</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>orP <span class="ot">=</span> liftP2 (<span class="op">||</span>)</span></code></pre></div>
</div>
<p>Notice that <code>liftP2</code> is very similar to our earlier
<code>liftP</code>. In fact, it's more general, because we can write
<code>liftP</code> in terms of <code>liftP2</code>.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">constP ::</span> a <span class="ot">-&gt;</span> <span class="dt">InfoP</span> a</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>constP k _ _ _ _ <span class="ot">=</span> k</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>liftP&#39; q f k w x y z <span class="ot">=</span> f w x y z <span class="ot">`q`</span> constP k w x y z</span></code></pre></div>
</div>
<div class="TIP">
<p>Combinators</p>
<p>In Haskell, we refer to functions that take other functions as
arguments, returning new functions, as <em>combinators</em>.</p>
</div>
<p>Now that we have some helper functions in place, we can return to the
<code>myTest</code> function we defined earlier.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>myTest path _ (<span class="dt">Just</span> size) _ <span class="ot">=</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>    takeExtension path <span class="op">==</span> <span class="st">&quot;.cpp&quot;</span> <span class="op">&amp;&amp;</span> size <span class="op">&gt;</span> <span class="dv">131072</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>myTest _ _ _ _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
</div>
<p>How will this function look if we write it using our new
combinators?</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">liftPath ::</span> (<span class="dt">FilePath</span> <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">InfoP</span> a</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>liftPath f w _ _ _ <span class="ot">=</span> f w</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>myTest2 <span class="ot">=</span> (liftPath takeExtension <span class="ot">`equalP`</span> <span class="st">&quot;.cpp&quot;</span>) <span class="ot">`andP`</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>          (sizeP <span class="ot">`greaterP`</span> <span class="dv">131072</span>)</span></code></pre></div>
</div>
<p>We've added one final combinator, <code>liftPath</code>, since
manipulating file names is such a common activity.</p>
<h2 data-number="6.3" id="defining-and-using-new-operators"><span
class="header-section-number">6.3</span> Defining and using new
operators</h2>
<p>We can take our domain specific language further by defining new
infix operators.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb32"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>(<span class="op">==?</span>) <span class="ot">=</span> equalP</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>(<span class="op">&amp;&amp;?</span>) <span class="ot">=</span> andP</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>(<span class="op">&gt;?</span>) <span class="ot">=</span> greaterP</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>myTest3 <span class="ot">=</span> (liftPath takeExtension <span class="op">==?</span> <span class="st">&quot;.cpp&quot;</span>) <span class="op">&amp;&amp;?</span> (sizeP <span class="op">&gt;?</span> <span class="dv">131072</span>)</span></code></pre></div>
</div>
<p>We chose names like <code>(==?)</code> for the lifted functions
specifically for their visual similarity to their unlifted
counterparts.</p>
<p>The parentheses in our definition above are necessary, because we
haven't told Haskell about the precedence or associativity of our new
operators. The language specifies that operators without fixity
declarations should be treated as <code>infixl 9</code>, i.e. they are
evaluated from left to right at the highest precedence level. If we were
to omit the parentheses, the expression would thus be parsed as
<code>(((liftPath takeExtension) ==? ".cpp") &amp;&amp;? sizeP) &gt;? 131072</code>,
which is horribly wrong.</p>
<p>We can respond by writing fixity declarations for our new operators.
Our first step is to find out what the fixities of the unlifted
operators are, so that we can mimic them.</p>
<pre class="screen"><code>ghci&gt; :info ==
class Eq a where
  (==) :: a -&gt; a -&gt; Bool
  ...
        -- Defined in ‘GHC.Classes’
infix 4 ==
ghci&gt; :info &amp;&amp;
(&amp;&amp;) :: Bool -&gt; Bool -&gt; Bool -- Defined in ‘GHC.Classes’
infixr 3 &amp;&amp;
ghci&gt; :info &gt;
class Eq a =&gt; Ord a where
  ...
  (&gt;) :: a -&gt; a -&gt; Bool
  ...
        -- Defined in ‘GHC.Classes’
infix 4 &gt;
</code></pre>
<p>With these in hand, we can now write a parenthesis-free expression
that will be parsed identically to <code>myTest3</code>.</p>
<div class="captioned-content">
<div class="caption">
BetterPredicate.hs
</div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">==?</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="kw">infixr</span> <span class="dv">3</span> <span class="op">&amp;&amp;?</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>infix <span class="dv">4</span> <span class="op">&gt;?</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a>myTest4 <span class="ot">=</span> liftPath takeExtension <span class="op">==?</span> <span class="st">&quot;.cpp&quot;</span> <span class="op">&amp;&amp;?</span> sizeP <span class="op">&gt;?</span> <span class="dv">131072</span></span></code></pre></div>
</div>
<h1 data-number="7" id="controlling-traversal"><span
class="header-section-number">7</span> Controlling traversal</h1>
<p>When traversing the filesystem, we'd like to give ourselves more
control over which directories we enter, and when. An easy way in which
we can allow this is to pass in a function that takes a list of
subdirectories of a given directory, and returns another list. This list
can have elements removed, or it can be ordered differently than the
original list, or both. The simplest such control function is
<code>id</code>, which will return its input list unmodified.</p>
<p>For variety, we're going to change a few aspects of our
representation here. Instead of an elaborate function type
<code>InfoP a</code>, we'll use a normal algebraic data type to
represent substantially the same information.</p>
<div class="captioned-content">
<div class="caption">
ControlledVisit.hs
</div>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">ControlledVisit</span> <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM, liftM)</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time.Clock</span> (<span class="dt">UTCTime</span>(..))</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.FilePath</span> ((&lt;/&gt;))</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">Permissions</span>(<span class="op">..</span>)</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    , getModificationTime</span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a>    , getPermissions</span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>    , getDirectoryContents</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb35-12"><a href="#cb35-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span></span>
<span id="cb35-13"><a href="#cb35-13" aria-hidden="true" tabindex="-1"></a>    ( bracket</span>
<span id="cb35-14"><a href="#cb35-14" aria-hidden="true" tabindex="-1"></a>    , handle</span>
<span id="cb35-15"><a href="#cb35-15" aria-hidden="true" tabindex="-1"></a>    , <span class="dt">SomeException</span>(<span class="op">..</span>)</span>
<span id="cb35-16"><a href="#cb35-16" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb35-17"><a href="#cb35-17" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb35-18"><a href="#cb35-18" aria-hidden="true" tabindex="-1"></a>    ( <span class="dt">IOMode</span>(<span class="op">..</span>)</span>
<span id="cb35-19"><a href="#cb35-19" aria-hidden="true" tabindex="-1"></a>    , hClose</span>
<span id="cb35-20"><a href="#cb35-20" aria-hidden="true" tabindex="-1"></a>    , hFileSize</span>
<span id="cb35-21"><a href="#cb35-21" aria-hidden="true" tabindex="-1"></a>    , openFile</span>
<span id="cb35-22"><a href="#cb35-22" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb35-23"><a href="#cb35-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-24"><a href="#cb35-24" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Info</span> <span class="ot">=</span> <span class="dt">Info</span></span>
<span id="cb35-25"><a href="#cb35-25" aria-hidden="true" tabindex="-1"></a>    {<span class="ot"> infoPath ::</span> <span class="dt">FilePath</span></span>
<span id="cb35-26"><a href="#cb35-26" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> infoPerms ::</span> <span class="dt">Maybe</span> <span class="dt">Permissions</span></span>
<span id="cb35-27"><a href="#cb35-27" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> infoSize ::</span> <span class="dt">Maybe</span> <span class="dt">Integer</span></span>
<span id="cb35-28"><a href="#cb35-28" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> infoModTime ::</span> <span class="dt">Maybe</span> <span class="dt">UTCTime</span></span>
<span id="cb35-29"><a href="#cb35-29" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>)</span>
<span id="cb35-30"><a href="#cb35-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-31"><a href="#cb35-31" aria-hidden="true" tabindex="-1"></a><span class="ot">getInfo ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">Info</span></span></code></pre></div>
</div>
<p>We're using record syntax to give ourselves "free" accessor
functions, such as <code>infoPath</code>. The type of our
<code>traverseDirs</code> function is simple, as we proposed above. To
obtain <code>Info</code> about a file or directory, we call the
<code>getInfo</code> action.</p>
<div class="captioned-content">
<div class="caption">
ControlledVisit.hs
</div>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">traverseDirs ::</span> ([<span class="dt">Info</span>] <span class="ot">-&gt;</span> [<span class="dt">Info</span>]) <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">Info</span>]</span></code></pre></div>
</div>
<p>The definition of <code>traverseDirs</code> is short, but dense.</p>
<div class="captioned-content">
<div class="caption">
ControlledVisit.hs
</div>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>traverseDirs order path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>    names <span class="ot">&lt;-</span> getUsefulContents path</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>    contents <span class="ot">&lt;-</span> <span class="fu">mapM</span> getInfo (path <span class="op">:</span> <span class="fu">map</span> (path <span class="op">&lt;/&gt;</span>) names)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>    liftM <span class="fu">concat</span> <span class="op">$</span> forM (order contents) <span class="op">$</span> \info <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>      <span class="kw">if</span> isDirectory info <span class="op">&amp;&amp;</span> infoPath info <span class="op">/=</span> path</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">then</span> traverseDirs order (infoPath info)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">else</span> <span class="fu">return</span> [info]</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a><span class="ot">getUsefulContents ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">String</span>]</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>getUsefulContents path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>    names <span class="ot">&lt;-</span> getDirectoryContents path</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="fu">filter</span> (<span class="ot">`notElem`</span> [<span class="st">&quot;.&quot;</span>, <span class="st">&quot;..&quot;</span>]) names)</span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="ot">isDirectory ::</span> <span class="dt">Info</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>isDirectory <span class="ot">=</span> <span class="fu">maybe</span> <span class="dt">False</span> searchable <span class="op">.</span> infoPerms</span></code></pre></div>
</div>
<p>While we're not introducing any new techniques here, this is one of
the densest function definitions we've yet encountered. Let's walk
through it almost line by line, explaining what is going on. The first
couple of lines hold no mystery, as they're almost verbatim copies of
code we've already seen.</p>
<p>Things begin to get interesting when we assign to the variable
<code>contents</code>. Let's read this line from right to left. We
already know that <code>names</code> is a list of directory entries. We
make sure that the current directory is prepended to every element of
the list, and included in the list itself. We use <code>mapM</code> to
apply <code>getInfo</code> to the resulting paths.</p>
<p>The line that follows is even more dense. Again reading from right to
left, we see that the last element of the line begins the definition of
an anonymous function that continues to the end of the paragraph. Given
one <code>Info</code> value, this function either visits a directory
recursively (there's an extra check to make sure we don't visit
<code>path</code> again), or returns that value as a single-element list
(to match the result type of <code>traverseDirs</code>).</p>
<p>We use <code>forM</code> to apply this function to each element of
the list of <code>Info</code> values returned by <code>order</code>, the
user-supplied traversal control function.</p>
<p>At the beginning of the line, we use the technique of lifting in a
new context. The <code>liftM</code> function takes a regular function,
<code>concat</code>, and lifts it into the IO monad. In other words, it
takes the result of <code>forM</code> (of type <code>IO [[Info]]</code>)
out of the IO monad, applies <code>concat</code> to it (yielding a
result of type <code>[Info]</code>, which is what we need), and puts the
result back into the IO monad.</p>
<p>Finally, we mustn't forget to define our <code>getInfo</code>
function.</p>
<div class="captioned-content">
<div class="caption">
ControlledVisit.hs
</div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">maybeIO ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>maybeIO act <span class="ot">=</span> handle (\(<span class="dt">SomeException</span> _) <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span>) (<span class="dt">Just</span> <span class="ot">`liftM`</span> act)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>getInfo path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>  perms <span class="ot">&lt;-</span> maybeIO (getPermissions path)</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  size <span class="ot">&lt;-</span> maybeIO (bracket (openFile path <span class="dt">ReadMode</span>) hClose hFileSize)</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  modified <span class="ot">&lt;-</span> maybeIO (getModificationTime path)</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> (<span class="dt">Info</span> path perms size modified)</span></code></pre></div>
</div>
<p>The only noteworthy thing here is a useful combinator,
<code>maybeIO</code>, which turns an I/O action that might throw an
exception into one that wraps its result in <code>Maybe</code>.</p>
<h2 data-number="7.1" id="exercises-1"><span
class="header-section-number">7.1</span> Exercises</h2>
<ol>
<li>What should you pass to <code>traverseDirs</code> to traverse a
directory tree in reverse alphabetic order?</li>
<li>Using <code>id</code> as a control function,
<code>traverse id</code> performs a <em>preorder</em> traversal of a
tree: it returns a parent directory before its children. Write a control
function that makes <code>traverseDirs</code> perform a
<em>postorder</em> traversal, in which it returns children before their
parent.</li>
<li>Take the predicates and combinators from <a
href="9-a-library-for-searching-the-file-system.org::*Gluing predicates together">the
section called "Gluing predicates together"</a> work with our new
<code>Info</code> type.</li>
<li>Write a wrapper for <code>traverseDirs</code> that lets you control
traversal using one predicate, and filter results using another.</li>
</ol>
<h1 data-number="8"
id="density-readability-and-the-learning-process"><span
class="header-section-number">8</span> Density, readability, and the
learning process</h1>
<p>Code as dense as <code>traverseDirs</code> is not unusual in Haskell.
The gain in expressiveness is significant, and it requires a relatively
small amount of practice to be able to fluently read and write code in
this style.</p>
<p>For comparison, here's a less dense presentation of the same code.
This might be more typical of a less experienced Haskell programmer.</p>
<div class="captioned-content">
<div class="caption">
ControlledVisit.hs
</div>
<div class="sourceCode" id="cb39"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>traverseVerbose order path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    names <span class="ot">&lt;-</span> getDirectoryContents path</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> usefulNames <span class="ot">=</span> <span class="fu">filter</span> (<span class="ot">`notElem`</span> [<span class="st">&quot;.&quot;</span>, <span class="st">&quot;..&quot;</span>]) names</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    contents <span class="ot">&lt;-</span> <span class="fu">mapM</span> getEntryName (<span class="st">&quot;&quot;</span> <span class="op">:</span> usefulNames)</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    recursiveContents <span class="ot">&lt;-</span> <span class="fu">mapM</span> recurse (order contents)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (<span class="fu">concat</span> recursiveContents)</span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> getEntryName name <span class="ot">=</span> getInfo (path <span class="op">&lt;/&gt;</span> name)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true" tabindex="-1"></a>        isDirectory info <span class="ot">=</span> <span class="kw">case</span> infoPerms info <span class="kw">of</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></span>
<span id="cb39-10"><a href="#cb39-10" aria-hidden="true" tabindex="-1"></a>                             <span class="dt">Just</span> perms <span class="ot">-&gt;</span> searchable perms</span>
<span id="cb39-11"><a href="#cb39-11" aria-hidden="true" tabindex="-1"></a>        recurse info <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb39-12"><a href="#cb39-12" aria-hidden="true" tabindex="-1"></a>            <span class="kw">if</span> isDirectory info <span class="op">&amp;&amp;</span> infoPath info <span class="op">/=</span> path</span>
<span id="cb39-13"><a href="#cb39-13" aria-hidden="true" tabindex="-1"></a>                <span class="kw">then</span> traverseVerbose order (infoPath info)</span>
<span id="cb39-14"><a href="#cb39-14" aria-hidden="true" tabindex="-1"></a>                <span class="kw">else</span> <span class="fu">return</span> [info]</span></code></pre></div>
</div>
<p>All we've done here is make a few substitutions. Instead of liberally
using partial application and function composition, we've defined some
local functions in a <code>where</code> block. In place of the
<code>maybe</code> combinator, we're using a <code>case</code>
expression. And instead of using <code>liftM</code>, we're manually
lifting <code>concat</code> ourselves.</p>
<p>This is not to say that density is a uniformly good property. Each
line of the original <code>traverseDirs</code> function is short. We
introduce a local variable (<code>usefulNames</code>) and a local
function (<code>isDirectory</code>) specifically to keep the lines short
and the code clearer. Our names are descriptive. While we use function
composition and pipelining, the longest pipeline contains only three
elements.</p>
<p>The key to writing maintainable Haskell code is to find a balance
between density and readability. Where your code falls on this continuum
is likely to be influenced by your level of experience.</p>
<ul>
<li>As a beginning Haskell programmer, Andrew doesn't know his way
around the standard libraries very well. As a result, he unwittingly
duplicates a lot of existing code.</li>
<li>Zack has been programming for a few months, and has mastered the use
of <code>(.)</code> to compose long pipelines of code. Every time the
needs of his program change slightly, he has to construct a new pipeline
from scratch: he can't understand the existing pipeline any longer, and
it is in any case too fragile to change.</li>
<li>Monica has been coding for a while. She's familiar enough with
Haskell libraries and idioms to write tight code, but she avoids a
hyperdense style. Her code is maintainable, and she finds it easy to
refactor when faced with changing requirements.</li>
</ul>
<h1 data-number="9" id="another-way-of-looking-at-traversal"><span
class="header-section-number">9</span> Another way of looking at
traversal</h1>
<p>While the <code>traverseDirs</code> function gives us more control
than our original <code>betterFind</code> function, it still has a
significant failing: we can avoid recursing into directories, but we
can't filter other names until after we've generated the entire list of
names in a tree. If we are traversing a directory containing 100,000
files of which we care about three, we'll allocate a 100,000-element
list before we have a chance to trim it down to the three we really
want.</p>
<p>One approach would be to provide a filter function as a new argument
to <code>traverseDirs</code>, which we would apply to the list of names
as we generate it. This would allow us to allocate a list of only as
many elements as we need.</p>
<p>However, this approach also has a weakness: say we know that we want
at most three entries from our list, and that those three entries happen
to be the first three of the 100,000 that we traverse. In this case,
we'll needlessly visit 99,997 other entries. This is not by any means a
contrived example: for example, the Maildir mailbox format stores a
folder of email messages as a directory of individual files. It's common
for a single directory representing a mailbox to contain tens of
thousands of files.</p>
<p>We can address the weaknesses of our two prior traversal functions by
taking a different perspective: what if we think of filesystem traversal
as a <em>fold</em> over the directory hierarchy?</p>
<p>The familiar folds, <code>foldr</code> and <code>foldl'</code>,
neatly generalise the idea of traversing a list while accumulating a
result. It's hardly a stretch to extend the idea of folding from lists
to directory trees, but we'd like to add an element of <em>control</em>
to our fold. We'll represent this control as an algebraic data type.</p>
<div class="captioned-content">
<div class="caption">
FoldDir.hs
</div>
<div class="sourceCode" id="cb40"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">ControlledVisit</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span> (toLower)</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time.Clock</span> (<span class="dt">UTCTime</span>(..))</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span> (<span class="dt">Permissions</span>(..))</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.FilePath</span> ((&lt;/&gt;), takeExtension, takeFileName)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Iterate</span> seed <span class="ot">=</span> <span class="dt">Done</span>     {<span class="ot"> unwrap ::</span> seed }</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">Skip</span>     {<span class="ot"> unwrap ::</span> seed }</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">Continue</span> {<span class="ot"> unwrap ::</span> seed }</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">deriving</span> (<span class="dt">Show</span>)</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Iterator</span> seed <span class="ot">=</span> seed <span class="ot">-&gt;</span> <span class="dt">Info</span> <span class="ot">-&gt;</span> <span class="dt">Iterate</span> seed</span></code></pre></div>
</div>
<p>The <code>Iterator</code> type gives us a convenient alias for the
function that we fold with. It takes a seed and an <code>Info</code>
value representing a directory entry, and returns both a new seed and an
instruction for our fold function, where the instructions are
represented as the constructors of the <code>Iterate</code> type.</p>
<ul>
<li>If the instruction is <code>Done</code>, traversal should cease
immediately. The value wrapped by <code>Done</code> should be returned
as the result.</li>
<li>If the instruction is <code>Skip</code> and the current
<code>Info</code> represents a directory, traversal will not recurse
into that directory.</li>
<li>Otherwise, the traversal should continue, using the wrapped value as
the input to the next call to the fold function.</li>
</ul>
<p>Our fold is logically a kind of left fold, because we start folding
from the first entry we encounter, and the seed for each step is the
result of the prior step.</p>
<div class="captioned-content">
<div class="caption">
FoldDir.hs
</div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ot">foldTree ::</span> <span class="dt">Iterator</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>foldTree iter initSeed path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>    endSeed <span class="ot">&lt;-</span> fold initSeed path</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (unwrap endSeed)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>    fold seed subpath <span class="ot">=</span> getUsefulContents subpath <span class="op">&gt;&gt;=</span> walk seed</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>    walk seed (name <span class="op">:</span> names) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>      <span class="kw">let</span> path&#39; <span class="ot">=</span> path <span class="op">&lt;/&gt;</span> name</span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>      info <span class="ot">&lt;-</span> getInfo path&#39;</span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>      <span class="kw">case</span> iter seed info <span class="kw">of</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>        done <span class="op">@</span> (<span class="dt">Done</span> _) <span class="ot">-&gt;</span> <span class="fu">return</span> done</span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Skip</span> seed  &#39;    <span class="ot">-&gt;</span> walk seed&#39; names</span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Continue</span> seed&#39;</span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> isDirectory info <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>              next <span class="ot">&lt;-</span> fold seed&#39; path&#39;</span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>              <span class="kw">case</span> next <span class="kw">of</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>                done <span class="op">@</span> (<span class="dt">Done</span> _) <span class="ot">-&gt;</span> <span class="fu">return</span> done</span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a>                seed&#39;&#39;          <span class="ot">-&gt;</span> walk (unwrap seed&#39;&#39;) names</span>
<span id="cb41-19"><a href="#cb41-19" aria-hidden="true" tabindex="-1"></a>          <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">-&gt;</span> walk seed&#39; names</span>
<span id="cb41-20"><a href="#cb41-20" aria-hidden="true" tabindex="-1"></a>    walk seed _ <span class="ot">=</span> <span class="fu">return</span> (<span class="dt">Continue</span> seed)</span></code></pre></div>
</div>
<p>There are a few interesting things about the way this code is
written. The first is the use of scoping to avoid having to pass extra
parameters around. The top-level <code>foldTree</code> function is just
a wrapper for <code>fold</code> that peels off the constructor of the
<code>fold</code>'s final result.</p>
<p>Because <code>fold</code> is a local function, we don't have to pass
<code>foldTree</code>'s <code>iter</code> variable into it; it can
already access it in the outer scope. Similarly, <code>walk</code> can
see <code>path</code> in its outer scope.</p>
<p>Another point to note is that <code>walk</code> is a tail recursive
loop, instead of an anonymous function called by <code>forM</code> as in
our earlier functions. By taking the reins ourselves, we can stop early
if we need to. This lets us drop out when our iterator returns
<code>Done</code>.</p>
<p>Although <code>fold</code> calls <code>walk</code>, <code>walk</code>
calls <code>fold</code> recursively to traverse subdirectories. Each
function returns a seed wrapped in an <code>Iterate</code>: when
<code>fold</code> is called by <code>walk</code> and returns,
<code>walk</code> examines its result to see whether it should continue
or drop out because it returned <code>Done</code>. In this way, a return
of <code>Done</code> from the caller-supplied iterator immediately
terminates all mutually recursive calls between the two functions.</p>
<p>What does an iterator look like in practice? Here's a somewhat
complicated example that looks for at most three bitmap images, and
won't recurse into Subversion metadata directories.</p>
<div class="captioned-content">
<div class="caption">
FoldDir.hs
</div>
<div class="sourceCode" id="cb42"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">atMostThreePictures ::</span> <span class="dt">Iterator</span> [<span class="dt">FilePath</span>]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>atMostThreePictures paths info</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">length</span> paths <span class="op">==</span> <span class="dv">3</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=</span> <span class="dt">Done</span> paths</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> isDirectory info <span class="op">&amp;&amp;</span> takeFileName path <span class="op">==</span> <span class="st">&quot;.svn&quot;</span></span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=</span> <span class="dt">Skip</span> paths</span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> extension <span class="ot">`elem`</span> [<span class="st">&quot;.jpg&quot;</span>, <span class="st">&quot;.png&quot;</span>]</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=</span> <span class="dt">Continue</span> (path <span class="op">:</span> paths)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">|</span> <span class="fu">otherwise</span></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>      <span class="ot">=</span> <span class="dt">Continue</span> paths</span>
<span id="cb42-11"><a href="#cb42-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> extension <span class="ot">=</span> <span class="fu">map</span> <span class="fu">toLower</span> (takeExtension path)</span>
<span id="cb42-12"><a href="#cb42-12" aria-hidden="true" tabindex="-1"></a>        path <span class="ot">=</span> infoPath info</span></code></pre></div>
</div>
<p>To use this, we'd call
<code>foldTree atMostThreePictures [] "."</code> (where <code>.</code>
is the current directory, you can supply another path), giving us a
return value of type <code>IO [FilePath]</code>.</p>
<p>Of course, iterators don't have to be this complicated. Here's one
that counts the number of directories it encounters.</p>
<div class="captioned-content">
<div class="caption">
FoldDir.hs
</div>
<div class="sourceCode" id="cb43"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>countDirectories count info <span class="ot">=</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Continue</span> (<span class="kw">if</span> isDirectory info</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>              <span class="kw">then</span> count <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>              <span class="kw">else</span> count)</span></code></pre></div>
</div>
<p>Here, the initial seed that we pass to <code>foldTree</code> should
be the number zero.</p>
<h2 data-number="9.1" id="exercises-2"><span
class="header-section-number">9.1</span> Exercises</h2>
<ol>
<li>Modify <code>foldTree</code> to allow the caller to change the order
of traversal of entries in a directory.</li>
<li>The <code>foldTree</code> function performs preorder traversal.
Modify it to allow the caller to determine the order of traversal.</li>
<li>Write a combinator library that makes it possible to express the
kinds of iterators that <code>foldTree</code> accepts. Does it make the
iterators you write any more succinct?</li>
</ol>
<h1 data-number="10" id="useful-coding-guidelines"><span
class="header-section-number">10</span> Useful coding guidelines</h1>
<p>While many good Haskell programming habits come with experience, we
have a few general guidelines to offer so that you can write readable
code more quickly.</p>
<p>If you find yourself proudly thinking that a particular piece of code
is fiendishly clever, stop and consider whether you'll be able to
understand it again after you've stepped away from it for a month.</p>
<p>The conventional way of naming types and variables with compound
names is to use "camel case", i.e. <code>myVariableName</code>. This
style is almost universal in Haskell code. Regardless of your opinion of
other naming practices, if you follow a non-standard convention, your
Haskell code will be somewhat jarring to the eyes of other readers.</p>
<p>Until you've been working with Haskell for a substantial amount of
time, spend a few minutes searching for library functions before you
write small functions. This applies particularly to ubiquitous types
like lists, <code>Maybe</code>, and <code>Either</code>. If the standard
libraries don't already provide exactly what you need, you might be able
to combine a few functions to obtain the result you desire.</p>
<p>Long pipelines of composed functions are hard to read, where "long"
means a series of more than three or four elements. If you have such a
pipeline, use a <code>let</code> or <code>where</code> block to break it
into smaller parts. Give each one of these pipeline elements a
meaningful name, then glue them back together. If you can't think of a
meaningful name for an element, ask yourself if you can even describe
what it does. If the answer is "no", simplify your code.</p>
<p>Even though it's easy to resize a text editor window far beyond 80
columns, this width is still very common. Wider lines are wrapped or
truncated in 80-column text editor windows, which severely hurts
readability. Treating lines as no more than 80 characters long limits
the amount of code you can cram onto a single line. This helps to keep
individual lines less complicated, therefore easier to understand.</p>
<h2 data-number="10.1" id="common-layout-styles"><span
class="header-section-number">10.1</span> Common layout styles</h2>
<p>A Haskell implementation won't make a fuss about indentation as long
as your code follows the layout rules and can hence be parsed
unambiguously. That said, some layout patterns are widely used.</p>
<p>As we already mentioned in <a
href="3-defining-types-streamlining-functions.org::*A note about tabs versus spaces">the
section called "A note about tabs versus spaces"</a> to use spaces.</p>
<p>The <code>in</code> keyword is usually aligned directly under the
<code>let</code> keyword, with the expression immediately following
it.</p>
<div class="captioned-content">
<div class="caption">
Style.hs
</div>
<div class="sourceCode" id="cb44"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>tidyLet <span class="ot">=</span> <span class="kw">let</span> foo <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>              bar <span class="ot">=</span> foo <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>          <span class="kw">in</span> <span class="fu">undefined</span></span></code></pre></div>
</div>
<p>While it's <em>legal</em> to indent the <code>in</code> differently,
or to let it "dangle" at the end of a series of equations, the following
would generally be considered odd.</p>
<div class="captioned-content">
<div class="caption">
Style.hs
</div>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>weirdLet <span class="ot">=</span> <span class="kw">let</span> foo <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>               bar <span class="ot">=</span> foo <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">in</span> <span class="fu">undefined</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>strangeLet <span class="ot">=</span> <span class="kw">let</span> foo <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a>                 bar <span class="ot">=</span> foo <span class="op">*</span> <span class="dv">2</span> <span class="kw">in</span></span>
<span id="cb45-7"><a href="#cb45-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">undefined</span></span></code></pre></div>
</div>
<p>In contrast, it's usual to let a <code>do</code> dangle at the end of
a line, rather than sit at the beginning of a line.</p>
<div class="captioned-content">
<div class="caption">
Style.hs
</div>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>commonDo <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>  something <span class="ot">&lt;-</span> <span class="fu">undefined</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span> ()</span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">-- not seen very often</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>rareDo <span class="ot">=</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>  <span class="kw">do</span> something <span class="ot">&lt;-</span> <span class="fu">undefined</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>     <span class="fu">return</span> ()</span></code></pre></div>
</div>
<p>Curly braces and semicolons, though legal, are almost never used.
There's nothing wrong with them; they just make code look strange due to
their rarity. They're really intended to let programs generate Haskell
code without having to implement the layout rules, not for human
use.</p>
<div class="captioned-content">
<div class="caption">
Style.hs
</div>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>unusualPunctuation <span class="ot">=</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>    [ (x,y) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>a], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>b] ] <span class="kw">where</span> {</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>                                           b <span class="ot">=</span> <span class="dv">7</span>;</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a> a <span class="ot">=</span> <span class="dv">6</span> }</span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>preferredLayout <span class="ot">=</span> [ (x,y) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>a], y <span class="ot">&lt;-</span> [<span class="dv">1</span><span class="op">..</span>b] ]</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> b <span class="ot">=</span> <span class="dv">7</span></span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>          a <span class="ot">=</span> <span class="dv">6</span></span></code></pre></div>
</div>
<p>If the right hand side of an equation starts on a new line, it's
usually indented a small number of spaces relative to the name of the
variable or function that it's defining.</p>
<div class="captioned-content">
<div class="caption">
Style.hs
</div>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>normalIndent <span class="ot">=</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">undefined</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>strangeIndent <span class="ot">=</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>                           <span class="fu">undefined</span></span></code></pre></div>
</div>
<p>The actual number of spaces used to indent varies, sometimes within a
single file. Depths of two, three, and four spaces are about equally
common. A single space is legal, but not very visually distinctive, so
it's easy to misread.</p>
<p>When indenting a <code>where</code> clause, it's best to make it
visually distinctive.</p>
<div class="captioned-content">
<div class="caption">
Style.hs
</div>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>goodWhere <span class="ot">=</span> <span class="fu">take</span> <span class="dv">5</span> lambdas</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> lambdas <span class="ot">=</span> []</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a>alsoGood <span class="ot">=</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    <span class="fu">take</span> <span class="dv">5</span> lambdas</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span></span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a>    lambdas <span class="ot">=</span> []</span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-9"><a href="#cb49-9" aria-hidden="true" tabindex="-1"></a>badWhere <span class="ot">=</span>           <span class="co">-- legal, but ugly and hard to read</span></span>
<span id="cb49-10"><a href="#cb49-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">take</span> <span class="dv">5</span> lambdas</span>
<span id="cb49-11"><a href="#cb49-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span></span>
<span id="cb49-12"><a href="#cb49-12" aria-hidden="true" tabindex="-1"></a>    lambdas <span class="ot">=</span> []</span></code></pre></div>
</div>
<h1 data-number="11" id="exercises-3"><span
class="header-section-number">11</span> Exercises</h1>
<ol>
<li>Port the code from this chapter to your platform's native API,
either <code>System.Posix</code> or <code>System.Win32</code>.</li>
<li>Add the ability to find out who owns a directory entry to your code.
Make this information available to predicates.</li>
</ol>
<h1 data-number="12" id="footnotes"><span
class="header-section-number">12</span> Footnotes</h1>
<p>Although the file finding code we described in this chapter is a good
vehicle for learning, it's not ideal for real systems programming tasks,
because Haskell's portable I/O libraries don't expose enough information
to let us write interesting and complicated queries.</p>
</body>
</html>
