<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Appendix. Characters, strings, and escaping rules</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Appendix. Characters, strings, and escaping rules</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#writing-character-and-string-literals"><span
class="toc-section-number">1</span> Writing character and string
literals</a></li>
<li><a href="#international-language-support"><span
class="toc-section-number">2</span> International language
support</a></li>
<li><a href="#escaping-text"><span class="toc-section-number">3</span>
Escaping text</a>
<ul>
<li><a href="#single-character-escape-codes"><span
class="toc-section-number">3.1</span> Single-character escape
codes</a></li>
<li><a href="#multiline-string-literals"><span
class="toc-section-number">3.2</span> Multiline string literals</a></li>
<li><a href="#ascii-control-codes"><span
class="toc-section-number">3.3</span> ASCII control codes</a></li>
<li><a href="#control-with-character-escapes"><span
class="toc-section-number">3.4</span> Control-with-character
escapes</a></li>
<li><a href="#numeric-escapes"><span
class="toc-section-number">3.5</span> Numeric escapes</a></li>
<li><a href="#the-zero-width-escape-sequence"><span
class="toc-section-number">3.6</span> The zero-width escape
sequence</a></li>
</ul></li>
</ul>
</nav>
<p>This appendix covers the escaping rules used to represent non-ASCII
characters in Haskell character and string literals. Haskell's escaping
rules follow the pattern established by the C programming language, but
expand considerably upon them.</p>
<h1 data-number="1" id="writing-character-and-string-literals"><span
class="header-section-number">1</span> Writing character and string
literals</h1>
<p>A single character is surrounded by ASCII single quotes,
<code>'</code>, and has type <code>Char</code>.</p>
<pre class="screen"><code>ghci&gt; &#39;c&#39;
&#39;c&#39;
ghci&gt; :type &#39;c&#39;
&#39;c&#39; :: Char
</code></pre>
<p>A string literal is surrounded by double quotes, <code>"</code>, and
has type <code>[Char]</code> (more often written as
<code>String</code>).</p>
<pre class="screen"><code>ghci&gt; &quot;a string literal&quot;
&quot;a string literal&quot;
ghci&gt; :type &quot;a string literal&quot;
&quot;a string literal&quot; :: [Char]
</code></pre>
<p>The double-quoted form of a string literal is just syntactic sugar
for list notation.</p>
<pre class="screen"><code>ghci&gt; [&#39;a&#39;, &#39; &#39;, &#39;s&#39;, &#39;t&#39;, &#39;r&#39;, &#39;i&#39;, &#39;n&#39;, &#39;g&#39;] == &quot;a string&quot;
True
</code></pre>
<h1 data-number="2" id="international-language-support"><span
class="header-section-number">2</span> International language
support</h1>
<p>Haskell uses Unicode internally for its <code>Char</code> data type.
Since <code>String</code> is just an alias for <code>[Char]</code>, a
list of ~Char~s, Unicode is also used to represent strings.</p>
<p>Different Haskell implementations place limitations on the character
sets they can accept in source files. GHC allows source files to be
written in the UTF-8 encoding of Unicode, so in a source file, you can
use UTF-8 literals inside a character or string constant. Do be aware
that if you use UTF-8, other Haskell implementations may not be able to
parse your source files.</p>
<p>When you run the <code>ghci</code> interpreter interactively, it may
not be able to deal with international characters in character or string
literals that you enter at the keyboard.</p>
<div class="NOTE">
<p>Note</p>
<p>Although Haskell represents characters and strings internally using
Unicode, there is no standardised way to do I/O on files that contain
Unicode data. Haskell's standard text I/O functions treat text as a
sequence of 8-bit characters, and do not perform any character set
conversion.</p>
<p>There exist third-party libraries that will convert between the many
different encodings used in files and Haskell's internal Unicode
representation.</p>
</div>
<h1 data-number="3" id="escaping-text"><span
class="header-section-number">3</span> Escaping text</h1>
<p>Some characters must be escaped to be represented inside a character
or string literal. For example, a double quote character inside a string
literal must be escaped, or else it will be treated as the end of the
string.</p>
<h2 data-number="3.1" id="single-character-escape-codes"><span
class="header-section-number">3.1</span> Single-character escape
codes</h2>
<p>Haskell uses essentially the same single-character escapes as the C
language and many other popular languages.</p>
<table>
<caption>Single-character escape codes</caption>
<thead>
<tr class="header">
<th>Escape</th>
<th>Unicode</th>
<th>Character</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="verbatim">\0</code></td>
<td>U+0000</td>
<td>null character</td>
</tr>
<tr class="even">
<td><code class="verbatim">\a</code></td>
<td>U+0007</td>
<td>alert</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\b</code></td>
<td>U+0008</td>
<td>backspace</td>
</tr>
<tr class="even">
<td><code class="verbatim">\f</code></td>
<td>U+000C</td>
<td>form feed</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\n</code></td>
<td>U+000A</td>
<td>newline (line feed)</td>
</tr>
<tr class="even">
<td><code class="verbatim">\r</code></td>
<td>U+000D</td>
<td>carriage return</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\t</code></td>
<td>U+0009</td>
<td>horizontal tab</td>
</tr>
<tr class="even">
<td><code class="verbatim">\v</code></td>
<td>U+000B</td>
<td>vertical tab</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\"</code></td>
<td>U+0022</td>
<td>double quote</td>
</tr>
<tr class="even">
<td><code class="verbatim">\&amp;</code></td>
<td><em>n/a</em></td>
<td>empty string</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\'</code></td>
<td>U+0027</td>
<td>single quote</td>
</tr>
<tr class="even">
<td><code class="verbatim">\\</code></td>
<td>U+005C</td>
<td>backslash</td>
</tr>
</tbody>
</table>
<h2 data-number="3.2" id="multiline-string-literals"><span
class="header-section-number">3.2</span> Multiline string literals</h2>
<p>To write a string literal that spans multiple lines, terminate one
line with a backslash, and resume the string with another backslash. An
arbitrary amount of whitespace (of any kind) can fill the gap between
the two backslashes.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;this is a \</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="st">\long string,\</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="st">\ spanning multiple lines&quot;</span></span></code></pre></div>
<h2 data-number="3.3" id="ascii-control-codes"><span
class="header-section-number">3.3</span> ASCII control codes</h2>
<p>Haskell recognises the escaped use of the standard two- and
three-letter abbreviations of ASCII control codes.</p>
<table>
<caption> ASCII control code abbreviations</caption>
<thead>
<tr class="header">
<th>Escape</th>
<th>Unicode</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="verbatim">\NUL</code></td>
<td>U+0000</td>
<td>null character</td>
</tr>
<tr class="even">
<td><code class="verbatim">\SOH</code></td>
<td>U+0001</td>
<td>start of heading</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\STX</code></td>
<td>U+0002</td>
<td>start of text</td>
</tr>
<tr class="even">
<td><code class="verbatim">\ETX</code></td>
<td>U+0003</td>
<td>end of text</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\EOT</code></td>
<td>U+0004</td>
<td>end of transmission</td>
</tr>
<tr class="even">
<td><code class="verbatim">\ENQ</code></td>
<td>U+0005</td>
<td>enquiry</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\ACK</code></td>
<td>U+0006</td>
<td>acknowledge</td>
</tr>
<tr class="even">
<td><code class="verbatim">\BEL</code></td>
<td>U+0007</td>
<td>bell</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\BS</code></td>
<td>U+0008</td>
<td>backspace</td>
</tr>
<tr class="even">
<td><code class="verbatim">\HT</code></td>
<td>U+0009</td>
<td>horizontal tab</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\LF</code></td>
<td>U+000A</td>
<td>line feed (newline)</td>
</tr>
<tr class="even">
<td><code class="verbatim">\VT</code></td>
<td>U+000B</td>
<td>vertical tab</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\FF</code></td>
<td>U+000C</td>
<td>form feed</td>
</tr>
<tr class="even">
<td><code class="verbatim">\CR</code></td>
<td>U+000D</td>
<td>carriage return</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\SO</code></td>
<td>U+000E</td>
<td>shift out</td>
</tr>
<tr class="even">
<td><code class="verbatim">\SI</code></td>
<td>U+000F</td>
<td>shift in</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\DLE</code></td>
<td>U+0010</td>
<td>data link escape</td>
</tr>
<tr class="even">
<td><code class="verbatim">\DC1</code></td>
<td>U+0011</td>
<td>device control 1</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\DC2</code></td>
<td>U+0012</td>
<td>device control 2</td>
</tr>
<tr class="even">
<td><code class="verbatim">\DC3</code></td>
<td>U+0013</td>
<td>device control 3</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\DC4</code></td>
<td>U+0014</td>
<td>device control 4</td>
</tr>
<tr class="even">
<td><code class="verbatim">\NAK</code></td>
<td>U+0015</td>
<td>negative acknowledge</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\SYN</code></td>
<td>U+0016</td>
<td>synchronous idle</td>
</tr>
<tr class="even">
<td><code class="verbatim">\ETB</code></td>
<td>U+0017</td>
<td>end of transmission block</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\CAN</code></td>
<td>U+0018</td>
<td>cancel</td>
</tr>
<tr class="even">
<td><code class="verbatim">\EM</code></td>
<td>U+0019</td>
<td>end of medium</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\SUB</code></td>
<td>U+001A</td>
<td>substitute</td>
</tr>
<tr class="even">
<td><code class="verbatim">\ESC</code></td>
<td>U+001B</td>
<td>escape</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\FS</code></td>
<td>U+001C</td>
<td>file separator</td>
</tr>
<tr class="even">
<td><code class="verbatim">\GS</code></td>
<td>U+001D</td>
<td>group separator</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\RS</code></td>
<td>U+001E</td>
<td>record separator</td>
</tr>
<tr class="even">
<td><code class="verbatim">\US</code></td>
<td>U+001F</td>
<td>unit separator</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\SP</code></td>
<td>U+0020</td>
<td>space</td>
</tr>
<tr class="even">
<td><code class="verbatim">\DEL</code></td>
<td>U+007F</td>
<td>delete</td>
</tr>
</tbody>
</table>
<h2 data-number="3.4" id="control-with-character-escapes"><span
class="header-section-number">3.4</span> Control-with-character
escapes</h2>
<p>Haskell recognises an alternate notation for control characters,
which represents the archaic effect of pressing the <code>control</code>
key on a keyboard and chording it with another key. These sequences
begin with the characters <code>\^</code>, followed by a symbol or
uppercase letter.</p>
<table>
<caption>Control-with-character escapes</caption>
<thead>
<tr class="header">
<th>Escape</th>
<th>Unicode</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code class="verbatim">\^@</code></td>
<td>U+0000</td>
<td>null character</td>
</tr>
<tr class="even">
<td><code class="verbatim">\^A</code> through <code
class="verbatim">\^Z</code></td>
<td>U+0001 through U+001A</td>
<td>control codes</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\^[</code></td>
<td>U+001B</td>
<td>escape</td>
</tr>
<tr class="even">
<td><code class="verbatim">\^\</code></td>
<td>U+001C</td>
<td>file separator</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\^]</code></td>
<td>U+001D</td>
<td>group separator</td>
</tr>
<tr class="even">
<td><code class="verbatim">\^^</code></td>
<td>U+001E</td>
<td>record separator</td>
</tr>
<tr class="odd">
<td><code class="verbatim">\^_</code></td>
<td>U+001F</td>
<td>unit separator</td>
</tr>
</tbody>
</table>
<h2 data-number="3.5" id="numeric-escapes"><span
class="header-section-number">3.5</span> Numeric escapes</h2>
<p>Haskell allows Unicode characters to be written using numeric
escapes. A decimal character begins with a digit, e.g.
<code>\1234</code>. A hexadecimal character begins with an
<code>x</code>, e.g. <code>\xbeef</code>. An octal character begins with
an <code>o</code>, e.g. <code>\o1234</code>.</p>
<p>The maximum value of a numeric literal is <code>\1114111</code>,
which may also be written <code>\x10ffff</code> or
<code>\o4177777</code>.</p>
<h2 data-number="3.6" id="the-zero-width-escape-sequence"><span
class="header-section-number">3.6</span> The zero-width escape
sequence</h2>
<p>String literals can contain a zero-width escape sequence, written
<code>\&amp;</code>. This is not a real character, as it represents the
empty string.</p>
<pre class="screen"><code>ghci&gt; &quot;\&amp;&quot;
&quot;&quot;
ghci&gt; &quot;foo\&amp;bar&quot;
&quot;foobar&quot;
</code></pre>
<p>The purpose of this escape sequence is to make it possible to write a
numeric escape followed immediately by a regular ASCII digit.</p>
<pre class="screen"><code>ghci&gt; &quot;\130\&amp;11&quot;
&quot;\130\&amp;11&quot;
</code></pre>
<p>Because the empty escape sequence represents an empty string, it is
not legal in a character literal.</p>
</body>
</html>
