<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 7: I/O</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 7: I/O</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#classic-io-in-haskell"><span
class="toc-section-number">1</span> Classic I/O in Haskell</a>
<ul>
<li><a href="#pure-vs.-io"><span class="toc-section-number">1.1</span>
Pure vs. I/O</a></li>
<li><a href="#why-purity-matters"><span
class="toc-section-number">1.2</span> Why Purity Matters</a></li>
</ul></li>
<li><a href="#working-with-files-and-handles"><span
class="toc-section-number">2</span> Working With Files and Handles</a>
<ul>
<li><a href="#more-on-openfile"><span
class="toc-section-number">2.1</span> More on
<code>openFile</code></a></li>
<li><a href="#closing-handles"><span
class="toc-section-number">2.2</span> Closing Handles</a></li>
<li><a href="#seek-and-tell"><span class="toc-section-number">2.3</span>
Seek and Tell</a></li>
<li><a href="#standard-input-output-and-error"><span
class="toc-section-number">2.4</span> Standard Input, Output, and
Error</a></li>
<li><a href="#deleting-and-renaming-files"><span
class="toc-section-number">2.5</span> Deleting and Renaming
Files</a></li>
<li><a href="#temporary-files"><span
class="toc-section-number">2.6</span> Temporary Files</a></li>
</ul></li>
<li><a href="#extended-example-functional-io-and-temporary-files"><span
class="toc-section-number">3</span> Extended Example: Functional I/O and
Temporary Files</a></li>
<li><a href="#lazy-io"><span class="toc-section-number">4</span> Lazy
I/O</a>
<ul>
<li><a href="#hgetcontents"><span class="toc-section-number">4.1</span>
hGetContents</a></li>
<li><a href="#readfile-and-writefile"><span
class="toc-section-number">4.2</span> <code>readFile</code> and
<code>writeFile</code></a></li>
<li><a href="#a-word-on-lazy-output"><span
class="toc-section-number">4.3</span> A Word On Lazy Output</a></li>
<li><a href="#interact"><span class="toc-section-number">4.4</span>
<code>interact</code></a></li>
</ul></li>
<li><a href="#the-io-monad"><span class="toc-section-number">5</span>
The IO Monad</a>
<ul>
<li><a href="#actions"><span class="toc-section-number">5.1</span>
Actions</a></li>
<li><a href="#sequencing"><span class="toc-section-number">5.2</span>
Sequencing</a></li>
<li><a href="#the-true-nature-of-return"><span
class="toc-section-number">5.3</span> The True Nature of Return</a></li>
</ul></li>
<li><a href="#is-haskell-really-imperative"><span
class="toc-section-number">6</span> Is Haskell Really
Imperative?</a></li>
<li><a href="#side-effects-with-lazy-io"><span
class="toc-section-number">7</span> Side Effects with Lazy I/O</a></li>
<li><a href="#buffering"><span class="toc-section-number">8</span>
Buffering</a>
<ul>
<li><a href="#buffering-modes"><span
class="toc-section-number">8.1</span> Buffering Modes</a></li>
<li><a href="#flushing-the-buffer"><span
class="toc-section-number">8.2</span> Flushing The Buffer</a></li>
</ul></li>
<li><a href="#reading-command-line-arguments"><span
class="toc-section-number">9</span> Reading Command-Line
Arguments</a></li>
<li><a href="#environment-variables"><span
class="toc-section-number">10</span> Environment Variables</a></li>
<li><a href="#footnotes"><span class="toc-section-number">11</span>
Footnotes</a></li>
</ul>
</nav>
<p>It should be obvious that most, if not all, programs are devoted to
gathering data from outside, processing it, and providing results back
to the outside world. That is, input and output are key.</p>
<p>Haskell's I/O system is powerful and expressive. It is easy to work
with and important to understand. Haskell strictly separates pure code
from code that could cause things to occur in the world. That is, it
provides a complete isolation from side-effects in pure code. Besides
helping programmers to reason about the correctness of their code, it
also permits compilers to automatically introduce optimizations and
parallelism.</p>
<p>We'll begin this chapter with simple, standard-looking I/O in
Haskell. Then we'll discuss some of the more powerful options as well as
provide more detail on how I/O fits into the pure, lazy, functional
Haskell world.</p>
<h1 data-number="1" id="classic-io-in-haskell"><span
class="header-section-number">1</span> Classic I/O in Haskell</h1>
<p>Let's get started with I/O in Haskell by looking at a program that
looks surprisingly similar to I/O in other languages such as C or
Perl.</p>
<div class="captioned-content">
<div class="caption">
basicio.hs
</div>
<div class="sourceCode" id="cb1"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="st">&quot;Greetings! What is your name?&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Welcome to Haskell, &quot;</span> <span class="op">++</span> inpStr <span class="op">++</span> <span class="st">&quot;!&quot;</span></span></code></pre></div>
</div>
<p>You can compile this program to a standalone executable, run it with
<code>runghc</code>, or invoke <code>main</code> from within
<code>ghci</code>. Here's a sample session using
<code>runghc</code>:</p>
<pre class="screen"><code>$ runghc basicio.hs
Greetings!  What is your name?
John
Welcome to Haskell, John!
</code></pre>
<p>That's a fairly simple, obvious result. You can see that
<code>putStrLn</code> writes out a <code>String</code>, followed by an
end-of-line character. <code>getLine</code> reads a line from standard
input. The <code>&lt;-</code> syntax may be new to you. Put simply, that
binds the result from executing an I/O action to a name.<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> We
use the simple list concatenation operator <code>++</code> to join the
input string with our own text.</p>
<p>Let's take a look at the types of <code>putStrLn</code> and
<code>getLine</code>. You can find that information in the library
reference, or just ask <code>ghci</code>:</p>
<pre class="screen"><code>ghci&gt; :type putStrLn
putStrLn :: String -&gt; IO ()
ghci&gt; :type getLine
getLine :: IO String
</code></pre>
<p>Notice that both of these types have <code>IO</code> in their return
value. That is your key to knowing that they may have side effects, or
that they may return different values even when called with the same
arguments, or both. The type of <code>putStrLn</code> looks like a
function. It takes a parameter of type <code>String</code> and returns
value of type <code>IO ()</code>. Just what is an <code>IO ()</code>
though?</p>
<p>Anything that is type <code>IO something</code> is an I/O
<em>action</em>. You can store it and nothing will happen. I could say
<code>writefoo = putStrLn
"foo"</code> and nothing happens right then. But if I later use
<code>writefoo</code> in the middle of another I/O action, the
<code>writefoo</code> action will be executed when its parent action is
executed –I/O actions can be glued together to form bigger I/O actions.
The <code>()</code> is an empty tuple (pronounced "unit"), indicating
that there is no return value from <code>putStrLn</code>. This is
similar to <code>void</code> in Java or C.<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a></p>
<div class="TIP">
<p>Tip</p>
<p>Actions can be created, assigned, and passed anywhere. However, they
may only be performed (executed) from within another I/O action.</p>
</div>
<p>Let's look at this with <code>ghci</code>:</p>
<pre class="screen"><code>ghci&gt; writefoo = putStrLn &quot;foo&quot;
ghci&gt; writefoo
foo
</code></pre>
<p>In this example, the output <code>foo</code> is not a return value
from <code>putStrLn</code>. Rather, it's the side effect of
<code>putStrLn</code> actually writing <code>foo</code> to the
terminal.</p>
<p>Notice one other thing: <code>ghci</code> actually executed
<code>writefoo</code>. This means that, when given an I/O action,
<code>ghci</code> will perform it for you on the spot.</p>
<div class="NOTE">
<p>What Is An I/O Action?</p>
<ul>
<li>Have the type <code>IO t</code></li>
<li>Are first-class values in Haskell and fit seamlessly with Haskell's
type system</li>
<li>Produce an effect when <em>performed</em>, but not when
<em>evaluated</em>. That is, they only produce an effect when called by
something else in an I/O context.</li>
<li>Any expression may produce an action as its value, but the action
will not perform I/O until it is executed inside another I/O action (or
it is <code>main</code>)</li>
<li>Performing (executing) an action of type <code>IO t</code> may
perform I/O and will ultimately deliver a result of type
<code>t</code></li>
</ul>
</div>
<p>The type of <code>getLine</code> may look strange to you. It looks
like a value, rather than a function. And in fact, that is one way to
look at it: <code>getLine</code> is storing an I/O action. When that
action is performed, you get a <code>String</code>. The
<code>&lt;-</code> operator is used to "pull out" the result from
performing an I/O action and store it in a variable.</p>
<p><code>main</code> itself is an I/O action with type
<code>IO ()</code>. You can only perform I/O actions from within other
I/O actions. All I/O in Haskell programs is driven from the top at
<code>main</code>, which is where execution of every Haskell program
begins. This, then, is the mechanism that provides isolation from side
effects in Haskell: you perform I/O in your <code>IO</code> actions, and
call pure (non-I/O) functions from there. Most Haskell code is pure; the
I/O actions perform I/O and call that pure code.</p>
<p><code>do</code> is a convenient way to define a sequence of actions.
As you'll see later, there are other ways. When you use <code>do</code>
in this way, indentation is significant; make sure you line up your
actions properly.</p>
<p>You only need to use <code>do</code> if you have more than one action
that you need to perform. The value of a <code>do</code> block is the
value of the last action executed. For a complete description of
<code>do</code> syntax, see <a
href="15-monads.org::*Desugaring of do blocks">the section called
"Desugaring of do blocks"</a></p>
<p>Let's consider an example of calling pure code from within an I/O
action:</p>
<div class="captioned-content">
<div class="caption">
callingpure.hs
</div>
<div class="sourceCode" id="cb5"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">name2reply ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>name2reply name <span class="ot">=</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Pleased to meet you, &quot;</span> <span class="op">++</span> name <span class="op">++</span> <span class="st">&quot;.\n&quot;</span> <span class="op">++</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Your name contains &quot;</span> <span class="op">++</span> charcount <span class="op">++</span> <span class="st">&quot; characters.&quot;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> charcount <span class="ot">=</span> <span class="fu">show</span> (<span class="fu">length</span> name)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="st">&quot;Greetings once again.  What is your name?&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> outStr <span class="ot">=</span> name2reply inpStr</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> outStr</span></code></pre></div>
</div>
<p>Notice the <code>name2reply</code> function in this example. It is a
regular Haskell function and obeys all the rules we've told you about:
it always returns the same result when given the same input, it has no
side effects, and it operates lazily. It uses other Haskell functions:
<code>(++)</code>, <code>show</code>, and <code>length</code>.</p>
<p>Down in <code>main</code>, we bind the result of
<code>name2reply inpStr</code> to <code>outStr</code>. When you're
working in a <code>do</code> block, you use <code>&lt;-</code> to get
results from <code>IO</code> actions and <code>let</code> to get results
from pure code. When used in a <code>do</code> block, you should not put
<code>in</code> after your <code>let</code> statement.</p>
<p>You can see here how we read the person's name from the keyboard.
Then, that data got passed to a pure function, and its result was
printed. In fact, the last two lines of <code>main</code> could have
been replaced with <code>putStrLn (name2reply inpStr)</code>. So, while
<code>main</code> did have side effects–it caused things to appear on
the terminal, for instance–~name2reply~ did not and could not. That's
because <code>name2reply</code> is a pure function, not an action.</p>
<p>Let's examine this with <code>ghci</code>:</p>
<pre class="screen"><code>ghci&gt; :load callingpure.hs
[1 of 1] Compiling Main             ( callingpure.hs, interpreted )
Ok, one module loaded.
*Main&gt; name2reply &quot;John&quot;
&quot;Pleased to meet you, John.\nYour name contains 4 characters.&quot;
*Main&gt; putStrLn (name2reply &quot;John&quot;)
Pleased to meet you, John.
Your name contains 4 characters.
</code></pre>
<p>The <code>\n</code> within the string is the end-of-line (newline)
character, which causes the terminal to begin a new line in its output.
Just calling <code>name2reply "John"</code> in <code>ghci</code> will
show you the <code>\n</code> literally, because it is using
<code>show</code> to display the return value. But using
<code>putStrLn</code> sends it to the terminal, and the terminal
interprets <code>\n</code> to start a new line.</p>
<p>What do you think will happen if you simply type <code>main</code> at
the <code>ghci</code> prompt? Give it a try.</p>
<p>After looking at these example programs, you may be wondering if
Haskell is really imperative rather than pure, lazy, and functional.
Some of these examples look like a sequence of actions to be followed in
order. There's more to it than that, though. We'll discuss that question
later in this chapter in <a
href="7-io.org::*Is Haskell Really Imperative?">the section called "Is
Haskell Really Imperative?"</a> <a href="7-io.org::*Lazy I/O">the
section called "Lazy I/O"</a></p>
<h2 data-number="1.1" id="pure-vs.-io"><span
class="header-section-number">1.1</span> Pure vs. I/O</h2>
<p>As a way to help with understanding the differences between pure code
and I/O, here's a comparison table. When we speak of pure code, we are
talking about Haskell functions that always return the same result when
given the same input and have no side effects. In Haskell, only the
execution of I/O actions avoid these rules.</p>
<table>
<caption>Table 7.1. Pure vs. Impure</caption>
<thead>
<tr class="header">
<th>Pure</th>
<th>Impure</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Always produces the same result when given the same parameters</td>
<td>May produce different results for the same parameters</td>
</tr>
<tr class="even">
<td>Never has side effects</td>
<td>May have side effects</td>
</tr>
<tr class="odd">
<td>Never alters state</td>
<td>May alter the global state of the program, system, or world</td>
</tr>
</tbody>
</table>
<h2 data-number="1.2" id="why-purity-matters"><span
class="header-section-number">1.2</span> Why Purity Matters</h2>
<p>In this section, we've discussed how Haskell draws a clear
distinction between pure code and I/O actions. Most languages don't draw
this distinction. In languages such as C or Java, there is no such thing
as a function that is guaranteed by the compiler to always return the
same result for the same arguments, or a function that is guaranteed to
never have side effects. The only way to know if a given function has
side effects is to read its documentation and hope that it's
accurate.</p>
<p>Many bugs in programs are caused by unanticipated side effects. Still
more are caused by misunderstanding circumstances in which functions may
return different results for the same input. As multithreading and other
forms of parallelism grow increasingly common, it becomes more difficult
to manage global side effects.</p>
<p>Haskell's method of isolating side effects into I/O actions provides
a clear boundary. You can always know which parts of the system may
alter state and which won't. You can always be sure that the pure parts
of your program aren't having unanticipated results. This helps you to
think about the program. It also helps the compiler to think about it.
Recent versions of <code>ghc</code>, for instance, can provide a level
of automatic parallelism for the pure parts of your code–something of a
holy grail for computing.</p>
<p>For more discussion on this topic, refer to <a
href="7-io.org::*Side Effects with Lazy I/O">the section called "Side
Effects with Lazy I/O"</a></p>
<h1 data-number="2" id="working-with-files-and-handles"><span
class="header-section-number">2</span> Working With Files and
Handles</h1>
<p>So far, you've seen how to interact with the user at the computer's
terminal. Of course, you'll often need to manipulate specific files.
That's easy to do, too.</p>
<p>Haskell defines quite a few basic functions for I/O, many of which
are similar to functions seen in other programming languages. The
library reference for <code>System.IO</code> provides a good summary of
all the basic I/O functions, should you need one that we aren't touching
upon here.</p>
<p>You will generally begin by using <code>openFile</code>, which will
give you a file <code>Handle</code>. That <code>Handle</code> is then
used to perform specific operations on the file. Haskell provides
functions such as <code>hPutStrLn</code> that work just like
<code>putStrLn</code> but take an additional argument–a
<code>Handle~–that specifies which file to operate upon.
When you're done, you'll use ~hClose</code> to close the
<code>Handle</code>. These functions are all defined in
<code>System.IO</code>, so you'll need to import that module when
working with files. There are "h" functions corresponding to virtually
all of the non-"h" functions; for instance, there is <code>print</code>
for printing to the screen and <code>hPrint</code> for printing to a
file.</p>
<p>Let's start with an imperative way to read and write files. This
should seem similar to a <code>while</code> loop that you may find in
other languages. This isn't the best way to write it in Haskell; later,
you'll see examples of more Haskellish approaches.</p>
<div class="captioned-content">
<div class="caption">
toupper-imp.hs
</div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>       inh <span class="ot">&lt;-</span> openFile <span class="st">&quot;input.txt&quot;</span> <span class="dt">ReadMode</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>       outh <span class="ot">&lt;-</span> openFile <span class="st">&quot;output.txt&quot;</span> <span class="dt">WriteMode</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>       mainloop inh outh</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>       hClose inh</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>       hClose outh</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="ot">mainloop ::</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>mainloop inh outh <span class="ot">=</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> ineof <span class="ot">&lt;-</span> hIsEOF inh</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>       <span class="kw">if</span> ineof</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>           <span class="kw">then</span> <span class="fu">return</span> ()</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>           <span class="kw">else</span> <span class="kw">do</span> inpStr <span class="ot">&lt;-</span> hGetLine inh</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                   hPutStrLn outh (<span class="fu">map</span> <span class="fu">toUpper</span> inpStr)</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                   mainloop inh outh</span></code></pre></div>
</div>
<p>Like every Haskell program, execution of this program begins with
<code>main</code>. Two files are opened: <code>input.txt</code> is
opened for reading, and <code>output.txt</code> is opened for writing.
Then we call <code>mainloop</code> to process the file.</p>
<p><code>mainloop</code> begins by checking to see if we're at the end
of file (EOF) for the input. If not, we read a line from the input. We
write out the same line to the output, after first converting it to
uppercase. Then we recursively call <code>mainloop</code> again to
continue processing the file.<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>Notice that <code>return</code> call. This is not really the same as
<code>return</code> in C or Python. In those languages,
<code>return</code> is used to terminate execution of the current
function immediately, and to return a value to the caller. In Haskell,
<code>return</code> is the opposite of <code>&lt;-</code>. That is,
<code>return</code> takes a pure value and wraps it inside
<code>IO</code>. Since every I/O action must return some <code>IO</code>
type, if your result came from pure computation, you must use
<code>return</code> to wrap it in <code>IO</code>. As an example, if
<code>7</code> is an <code>Int</code>, then <code>return 7</code> would
create an action stored in a value of type <code>IO Int</code>. When
executed, that action would produce the result <code>7</code>. For more
details on <code>return</code>, see <a
href="7-io.org::*The True Nature of Return">the section called "The True
Nature of Return"</a></p>
<p>Let's try running the program. We've got a file named
<code>input.txt</code> that looks like this:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">This</span> is input<span class="op">.</span>txt</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Test</span> <span class="dt">Input</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">I</span> like <span class="dt">Haskell</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dt">Haskell</span> is great</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">I</span><span class="op">/</span><span class="dt">O</span> is fun</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="dv">123456789</span></span></code></pre></div>
<p>Now, you can use <code>runghc toupper-imp.hs</code> and you'll find
<code>output.txt</code> in your directory. It should look like this:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">THIS</span> <span class="dt">IS</span> <span class="dt">INPUT.TXT</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="dt">TEST</span> <span class="dt">INPUT</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">I</span> <span class="dt">LIKE</span> <span class="dt">HASKELL</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="dt">HASKELL</span> <span class="dt">IS</span> <span class="dt">GREAT</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="dt">I</span><span class="op">/</span><span class="dt">O</span> <span class="dt">IS</span> <span class="dt">FUN</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="dv">123456789</span></span></code></pre></div>
<h2 data-number="2.1" id="more-on-openfile"><span
class="header-section-number">2.1</span> More on
<code>openFile</code></h2>
<p>Let's use <code>ghci</code> to check on the type of
<code>openFile</code>:</p>
<pre class="screen"><code>ghci&gt; :module System.IO
ghci&gt; :type openFile
openFile :: FilePath -&gt; IOMode -&gt; IO Handle
</code></pre>
<p><code>FilePath</code> is simply another name for <code>String</code>.
It is used in the types of I/O functions to help clarify that the
parameter is being used as a filename, and not as regular data.</p>
<p><code>IOMode</code> specifies how the file is to be managed. The
possible values for <code>IOMode</code> are listed in <span
class="spurious-link"
target="Table%C2%A07.2.%C2%A0Possible IOMode Values"><em>Table 7.2,
"Possible IOMode Values"</em></span>.</p>
<div id="Table 7.2. Possible IOMode Values">
<table>
<caption>Table 7.2. Possible IOMode Values</caption>
<thead>
<tr class="header">
<th><code>IOMode</code></th>
<th>Can read?</th>
<th>Can write?</th>
<th>Starting position</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>ReadMode</code></td>
<td>Yes</td>
<td>No</td>
<td>Beginning of file</td>
<td>File must exist already</td>
</tr>
<tr class="even">
<td><code>WriteMode</code></td>
<td>No</td>
<td>Yes</td>
<td>Beginning of file</td>
<td>File is truncated (completely emptied) if it already existed</td>
</tr>
<tr class="odd">
<td><code>ReadWriteMode</code></td>
<td>Yes</td>
<td>Yes</td>
<td>Beginning of file</td>
<td>File is created if it didn't exist; otherwise, existing data is left
intact</td>
</tr>
<tr class="even">
<td><code>AppendMode</code></td>
<td>No</td>
<td>Yes</td>
<td>End of file</td>
<td>File is created if it didn't exist; otherwise, existing data is left
intact</td>
</tr>
</tbody>
</table>
</div>
<p>While we are mostly working with text examples in this chapter,
binary files can also be used in Haskell. If you are working with a
binary file, you should use <code>openBinaryFile</code> instead of
<code>openFile</code>. Operating systems such as Windows process files
differently if they are opened as binary instead of as text. On
operating systems such as Linux, both <code>openFile</code> and
<code>openBinaryFile</code> perform the same operation. Nevertheless,
for portability, it is still wise to always use
<code>openBinaryFile</code> if you will be dealing with binary data.</p>
<h2 data-number="2.2" id="closing-handles"><span
class="header-section-number">2.2</span> Closing Handles</h2>
<p>You've already seen that <code>hClose</code> is used to close file
handles. Let's take a moment and think about why this is important.</p>
<p>As you'll see in <a href="7-io.org::*Buffering">the section called
"Buffering"</a> Haskell maintains internal buffers for files. This
provides an important performance boost. However, it means that until
you call <code>hClose</code> on a file that is open for writing, your
data may not be flushed out to the operating system.</p>
<p>Another reason to make sure to <code>hClose</code> files is that open
files take up resources on the system. If your program runs for a long
time, and opens many files but fails to close them, it is conceivable
that your program could even crash due to resource exhaustion. All of
this is no different in Haskell than in other languages.</p>
<p>When a program exits, Haskell will normally take care of closing any
files that remain open. However, there are some circumstances in which
this may not happen<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>, so once again, it is best to be
responsible and call <code>hClose</code> all the time.</p>
<p>Haskell provides several tools for you to use to easily ensure this
happens, regardless of whether errors are present. You can read about
<code>finally</code> in <a
href="7-io.org::*Extended Example: Functional I/O and Temporary Files">the
section called "Extended Example: Functional I/O and Temporary
Files"</a> and <code>bracket</code> in <a
href="9-a-library-for-searching-the-file-system.org::*The acquire-use-release cycle">the
section called "The acquire-use-release cycle"</a></p>
<h2 data-number="2.3" id="seek-and-tell"><span
class="header-section-number">2.3</span> Seek and Tell</h2>
<p>When reading and writing from a <code>Handle</code> that corresponds
to a file on disk, the operating system maintains an internal record of
the current position. Each time you do another read, the operating
system returns the next chunk of data that begins at the current
position, and increments the position to reflect the data that you
read.</p>
<p>You can use <code>hTell</code> to find out your current position in
the file. When the file is initially created, it is empty and your
position will be 0. After you write out 5 bytes, your position will be
5, and so on. <code>hTell</code> takes a <code>Handle</code> and returns
an <code>IO Integer</code> with your position.</p>
<p>The companion to <code>hTell</code> is <code>hSeek</code>.
<code>hSeek</code> lets you change the file position. It takes three
parameters: a <code>Handle</code>, a <code>SeekMode</code>, and a
position.</p>
<p><code>SeekMode</code> can be one of three different values, which
specify how the given position is to be interpreted.
<code>AbsoluteSeek</code> means that the position is a precise location
in the file. This is the same kind of information that
<code>hTell</code> gives you. <code>RelativeSeek</code> means to seek
from the current position. A positive number requests going forwards in
the file, and a negative number means going backwards. Finally,
<code>SeekFromEnd</code> will seek to the specified number of bytes
before the end of the file. <code>hSeek handle
SeekFromEnd 0</code> will take you to the end of the file. For an
example of <code>hSeek</code>, refer to <a
href="7-io.org::*Extended Example: Functional I/O and Temporary Files">the
section called "Extended Example: Functional I/O and Temporary
Files"</a></p>
<p>Not all <code>Handle~s are seekable. A ~Handle</code> usually
corresponds to a file, but it can also correspond to other things such
as network connections, tape drives, or terminals. You can use
<code>hIsSeekable</code> to see if a given <code>Handle</code> is
seekable.</p>
<h2 data-number="2.4" id="standard-input-output-and-error"><span
class="header-section-number">2.4</span> Standard Input, Output, and
Error</h2>
<p>Earlier, we pointed out that for each non-"h" function, there is
usually also a corresponding "h" function that works on any
<code>Handle</code>. In fact, the non-"h" functions are nothing more
than shortcuts for their "h" counterparts.</p>
<p>There are three pre-defined <code>Handle~s in ~System.IO</code>.
These
<code>Handle~s are always available for your use. They are ~stdin</code>,
which corresponds to standard input; <code>stdout</code> for standard
output; and <code>stderr</code> for standard error. Standard input
normally refers to the keyboard, standard output to the monitor, and
standard error also normally goes to the monitor.</p>
<p>Functions such as <code>getLine</code> can thus be trivially defined
like this:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">getLine</span> <span class="ot">=</span> hGetLine stdin</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">putStrLn</span> <span class="ot">=</span> hPutStrLn stdout</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span> <span class="ot">=</span> hPrint stdout</span></code></pre></div>
<div class="TIP">
<p>Tip</p>
<p>We're using partial application here. If this isn't making sense,
consult <a
href="4-functional-programming.org::*Partial function application and currying">the
section called "Partial function application and currying"</a> a
refresher.</p>
</div>
<p>Earlier, we told you what the three standard file handles "normally"
correspond to. That's because some operating systems let you redirect
the file handles to come from (or go to) different places–files,
devices, or even other programs. This feature is used extensively in
shell scripting on POSIX (Linux, BSD, Mac) operating systems, but can
also be used on Windows.</p>
<p>It often makes sense to use standard input and output instead of
specific files. This lets you interact with a human at the terminal. But
it also lets you work with input and output files–or even combine your
code with other programs–if that's what's requested.<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>As an example, we can provide input to <code>callingpure.hs</code> in
advance like this:</p>
<pre class="screen"><code>$ echo John | runghc callingpure.hs
Greetings once again. What is your name?
Pleased to meet you, John.
Your name contains 4 characters.
</code></pre>
<p>While <code>callingpure.hs</code> was running, it did not wait for
input at the keyboard; instead it received <code>John</code> from the
<code>echo</code> program. Notice also that the output didn't contain
the word <code>John</code> on a separate line as it did when this
program was run at the keyboard. The terminal normally echoes everything
you type back to you, but that is technically input, and is not included
in the output stream.</p>
<h2 data-number="2.5" id="deleting-and-renaming-files"><span
class="header-section-number">2.5</span> Deleting and Renaming
Files</h2>
<p>So far in this chapter, we've discussed the contents of the files.
Let's now talk a bit about the files themselves.</p>
<p><code>System.Directory</code> provides two functions you may find
useful. <code>removeFile</code> takes a single argument, a filename, and
deletes that file.<a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a> <code>renameFile</code> takes two
filenames: the first is the old name and the second is the new name. If
the new filename is in a different directory, you can also think of this
as a move. The old filename must exist prior to the call to
<code>renameFile</code>. If the new file already exists, it is removed
before the rename takes place.</p>
<p>Like many other functions that take a filename, if the "old" name
doesn't exist, <code>renameFile</code> will raise an exception. More
information on exception handling can be found in <a
href="19-error-handling.org">Chapter 19, <em>Error
handling</em></a>.</p>
<p>There are many other functions in <code>System.Directory</code> for
doing things such as creating and removing directories, finding lists of
files in directories, and testing for file existence. These are
discussed in <a
href="20-systems-programming-in-haskell.org::*Directory and File Information">the
section called "Directory and File Information"</a></p>
<h2 data-number="2.6" id="temporary-files"><span
class="header-section-number">2.6</span> Temporary Files</h2>
<p>Programmers frequently need temporary files. These files may be used
to store large amounts of data needed for computations, data to be used
by other programs, or any number of other uses.</p>
<p>While you could craft a way to manually open files with unique names,
the details of doing this in a secure way differ from platform to
platform. Haskell provides a convenient function called
<code>openTempFile</code> (and a corresponding
<code>openBinaryTempFile</code>) to handle the difficult bits for
you.</p>
<p><code>openTempFile</code> takes two parameters: the directory in
which to create the file, and a "template" for naming the file. The
directory could simply be <code>"."</code> for the current working
directory. Or you could use
<code>System.Directory.getTemporaryDirectory</code> to find the best
place for temporary files on a given machine. The template is used as
the basis for the file name; it will have some random characters added
to it to ensure that the result is truly unique. It guarantees that it
will be working on a unique filename, in fact.</p>
<p>The return type of <code>openTempFile</code> is
<code>IO (FilePath, Handle)</code>. The first part of the tuple is the
name of the file created, and the second is a <code>Handle</code> opened
in <code>ReadWriteMode</code> over that file. When you're done with the
file, you'll want to <code>hClose</code> it and then call
<code>removeFile</code> to delete it. See the following example for a
sample function to use.</p>
<h1 data-number="3"
id="extended-example-functional-io-and-temporary-files"><span
class="header-section-number">3</span> Extended Example: Functional I/O
and Temporary Files</h1>
<p>Here's a larger example that puts together some concepts from this
chapter, from some earlier chapters, and a few you haven't seen yet.
Take a look at the program and see if you can figure out what it does
and how it works.</p>
<div class="captioned-content">
<div class="caption">
tempfile.hs
</div>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Directory</span>(getTemporaryDirectory, removeFile)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO.Error</span>(catchIOError)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span>(finally)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co">-- The main entry point. Work with a temp file in myAction.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> withTempFile <span class="st">&quot;mytemp.txt&quot;</span> myAction</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a><span class="co">{- The guts of the program. Called with the path and handle of a temporary</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co">   file. When this function exits, that file will be closed and deleted</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co">   because myAction was called from withTempFile. -}</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="ot">myAction ::</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>myAction tempname temph <span class="ot">=</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="co">-- Start by displaying a greeting on the terminal</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="st">&quot;Welcome to tempfile.hs&quot;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;I have a temporary file at &quot;</span> <span class="op">++</span> tempname</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Let&#39;s see what the initial position is</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>       pos <span class="ot">&lt;-</span> hTell temph</span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;My initial position is &quot;</span> <span class="op">++</span> <span class="fu">show</span> pos</span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Now, write some data to the temporary file</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> tempdata <span class="ot">=</span> <span class="fu">show</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb13-25"><a href="#cb13-25" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Writing one line containing &quot;</span> <span class="op">++</span></span>
<span id="cb13-26"><a href="#cb13-26" aria-hidden="true" tabindex="-1"></a>                  <span class="fu">show</span> (<span class="fu">length</span> tempdata) <span class="op">++</span> <span class="st">&quot; bytes: &quot;</span> <span class="op">++</span></span>
<span id="cb13-27"><a href="#cb13-27" aria-hidden="true" tabindex="-1"></a>                  tempdata</span>
<span id="cb13-28"><a href="#cb13-28" aria-hidden="true" tabindex="-1"></a>       hPutStrLn temph tempdata</span>
<span id="cb13-29"><a href="#cb13-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-30"><a href="#cb13-30" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Get our new position. This doesn&#39;t actually modify pos</span></span>
<span id="cb13-31"><a href="#cb13-31" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- in memory, but makes the name &quot;pos&quot; correspond to a different</span></span>
<span id="cb13-32"><a href="#cb13-32" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- value for the remainder of the &quot;do&quot; block.</span></span>
<span id="cb13-33"><a href="#cb13-33" aria-hidden="true" tabindex="-1"></a>       pos <span class="ot">&lt;-</span> hTell temph</span>
<span id="cb13-34"><a href="#cb13-34" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;After writing, my new position is &quot;</span> <span class="op">++</span> <span class="fu">show</span> pos</span>
<span id="cb13-35"><a href="#cb13-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-36"><a href="#cb13-36" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Seek to the beginning of the file and display it</span></span>
<span id="cb13-37"><a href="#cb13-37" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;The file content is: &quot;</span></span>
<span id="cb13-38"><a href="#cb13-38" aria-hidden="true" tabindex="-1"></a>       hSeek temph <span class="dt">AbsoluteSeek</span> <span class="dv">0</span></span>
<span id="cb13-39"><a href="#cb13-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-40"><a href="#cb13-40" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- hGetContents performs a lazy read of the entire file</span></span>
<span id="cb13-41"><a href="#cb13-41" aria-hidden="true" tabindex="-1"></a>       c <span class="ot">&lt;-</span> hGetContents temph</span>
<span id="cb13-42"><a href="#cb13-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-43"><a href="#cb13-43" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Copy the file byte-for-byte to stdout, followed by \n</span></span>
<span id="cb13-44"><a href="#cb13-44" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> c</span>
<span id="cb13-45"><a href="#cb13-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-46"><a href="#cb13-46" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Let&#39;s also display it as a Haskell literal</span></span>
<span id="cb13-47"><a href="#cb13-47" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Which could be expressed as this Haskell literal:&quot;</span></span>
<span id="cb13-48"><a href="#cb13-48" aria-hidden="true" tabindex="-1"></a>       <span class="fu">print</span> c</span>
<span id="cb13-49"><a href="#cb13-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-50"><a href="#cb13-50" aria-hidden="true" tabindex="-1"></a><span class="co">{- This function takes two parameters: a filename pattern and another</span></span>
<span id="cb13-51"><a href="#cb13-51" aria-hidden="true" tabindex="-1"></a><span class="co">   function. It will create a temporary file, and pass the name and Handle</span></span>
<span id="cb13-52"><a href="#cb13-52" aria-hidden="true" tabindex="-1"></a><span class="co">   of that file to the given function.</span></span>
<span id="cb13-53"><a href="#cb13-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-54"><a href="#cb13-54" aria-hidden="true" tabindex="-1"></a><span class="co">   The temporary file is created with openTempFile. The directory is the one</span></span>
<span id="cb13-55"><a href="#cb13-55" aria-hidden="true" tabindex="-1"></a><span class="co">   indicated by getTemporaryDirectory, or, if the system has no notion of</span></span>
<span id="cb13-56"><a href="#cb13-56" aria-hidden="true" tabindex="-1"></a><span class="co">   a temporary directory, &quot;.&quot; is used. The given pattern is passed to</span></span>
<span id="cb13-57"><a href="#cb13-57" aria-hidden="true" tabindex="-1"></a><span class="co">   openTempFile.</span></span>
<span id="cb13-58"><a href="#cb13-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-59"><a href="#cb13-59" aria-hidden="true" tabindex="-1"></a><span class="co">   After the given function terminates, even if it terminates due to an</span></span>
<span id="cb13-60"><a href="#cb13-60" aria-hidden="true" tabindex="-1"></a><span class="co">   exception, the Handle is closed and the file is deleted. -}</span></span>
<span id="cb13-61"><a href="#cb13-61" aria-hidden="true" tabindex="-1"></a><span class="ot">withTempFile ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> (<span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">Handle</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb13-62"><a href="#cb13-62" aria-hidden="true" tabindex="-1"></a>withTempFile <span class="kw">pattern</span> func <span class="ot">=</span></span>
<span id="cb13-63"><a href="#cb13-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="co">-- The library ref says that getTemporaryDirectory may raise on</span></span>
<span id="cb13-64"><a href="#cb13-64" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- exception on systems that have no notion of a temporary directory.</span></span>
<span id="cb13-65"><a href="#cb13-65" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- So, we run getTemporaryDirectory under catchIOError. catchIOError takes</span></span>
<span id="cb13-66"><a href="#cb13-66" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- two functions: one to run, and a different one to run if the</span></span>
<span id="cb13-67"><a href="#cb13-67" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- first raised an exception. If getTemporaryDirectory raised an</span></span>
<span id="cb13-68"><a href="#cb13-68" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- exception, just use &quot;.&quot; (the current working directory).</span></span>
<span id="cb13-69"><a href="#cb13-69" aria-hidden="true" tabindex="-1"></a>       tempdir <span class="ot">&lt;-</span> catchIOError (getTemporaryDirectory) (\_ <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="st">&quot;.&quot;</span>)</span>
<span id="cb13-70"><a href="#cb13-70" aria-hidden="true" tabindex="-1"></a>       (tempfile, temph) <span class="ot">&lt;-</span> openTempFile tempdir <span class="kw">pattern</span></span>
<span id="cb13-71"><a href="#cb13-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-72"><a href="#cb13-72" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- Call (func tempfile temph) to perform the action on the temporary</span></span>
<span id="cb13-73"><a href="#cb13-73" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- file. finally takes two actions. The first is the action to run.</span></span>
<span id="cb13-74"><a href="#cb13-74" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- The second is an action to run after the first, regardless of</span></span>
<span id="cb13-75"><a href="#cb13-75" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- whether the first action raised an exception. This way, we ensure</span></span>
<span id="cb13-76"><a href="#cb13-76" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- the temporary file is always deleted. The return value from finally</span></span>
<span id="cb13-77"><a href="#cb13-77" aria-hidden="true" tabindex="-1"></a>       <span class="co">-- is the first action&#39;s return value.</span></span>
<span id="cb13-78"><a href="#cb13-78" aria-hidden="true" tabindex="-1"></a>       finally (func tempfile temph)</span>
<span id="cb13-79"><a href="#cb13-79" aria-hidden="true" tabindex="-1"></a>               (<span class="kw">do</span> hClose temph</span>
<span id="cb13-80"><a href="#cb13-80" aria-hidden="true" tabindex="-1"></a>                   removeFile tempfile)</span></code></pre></div>
</div>
<p>Let's start looking at this program from the end. The
<code>withTempFile</code> function demonstrates that Haskell doesn't
forget its functional nature when I/O is introduced. This function takes
a <code>String</code> and another function. The function passed to
<code>withTempFile</code> is invoked with the name and
<code>Handle</code> of a temporary file. When that function exits, the
temporary file is closed and deleted. So even when dealing with I/O, we
can still find the idiom of passing functions as parameters to be
convenient. Lisp programmers might find our <code>withTempFile</code>
function similar to Lisp's <code>with-open-file</code> function.</p>
<p>There is some exception handling going on to make the program more
robust in the face of errors. You normally want the temporary files to
be deleted after processing completes, even if something went wrong. So
we make sure that happens. For more on exception handling, see <a
href="19-error-handling.org">Chapter 19, <em>Error
handling</em></a>.</p>
<p>Let's return to the start of the program. <code>main</code> is
defined simply as <code>withTempFile "mytemp.txt" myAction</code>.
<code>myAction</code>, then, will be invoked with the name and
<code>Handle</code> of the temporary file.</p>
<p><code>myAction</code> displays some information to the terminal,
writes some data to the file, seeks to the beginning of the file, and
reads the data back with <code>hGetContents</code>.<a href="#fn7"
class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> It
then displays the contents of the file byte-for-byte, and also as a
Haskell literal via <code>print c</code>. That's the same as
<code>putStrLn (show c)</code>.</p>
<p>Let's look at the output:</p>
<pre class="screen"><code>$ runhaskell tempfile.hs
Welcome to tempfile.hs
I have a temporary file at /tmp/mytemp8572.txt
My initial position is 0
Writing one line containing 22 bytes: [1,2,3,4,5,6,7,8,9,10]
After writing, my new position is 23
The file content is:
[1,2,3,4,5,6,7,8,9,10]

Which could be expressed as this Haskell literal:
&quot;[1,2,3,4,5,6,7,8,9,10]\n&quot;
</code></pre>
<p>Every time you run this program, your temporary file name should be
slightly different since it contains a randomly-generated component.
Looking at this output, there are a few questions that might occur to
you:</p>
<ol>
<li>Why is your position 23 after writing a line with 22 bytes?</li>
<li>Why is there an empty line after the file content display?</li>
<li>Why is there a <code>\n</code> at the end of the Haskell literal
display?</li>
</ol>
<p>You might be able to guess that the answers to all three questions
are related. See if you can work out the answers for a moment. If you
need some help, here are the explanations:</p>
<ol>
<li>That's because we used <code>hPutStrLn</code> instead of
<code>hPutStr</code> to write the data. <code>hPutStrLn</code> always
terminates the line by writing a <code>\n</code> at the end, which
didn't appear in <code>tempdata</code>.</li>
<li>We used <code>putStrLn c</code> to display the file contents
<code>c</code>. Because the data was written originally with
<code>hPutStrLn</code>, <code>c</code> ends with the newline character,
and <code>putStrLn</code> adds a second newline character. The result is
a blank line.</li>
<li>The <code>\n</code> is the newline character from the original
<code>hPutStrLn</code>.</li>
</ol>
<p>As a final note, the byte counts may be different on some operating
systems. Windows, for instance, uses the two-byte sequence
<code>\r\n</code> as the end-of-line marker, so you may see differences
on that platform.</p>
<h1 data-number="4" id="lazy-io"><span
class="header-section-number">4</span> Lazy I/O</h1>
<p>So far in this chapter, you've seen examples of fairly traditional
I/O. Each line, or block of data, is requested individually and
processed individually.</p>
<p>Haskell has another approach available to you as well. Since Haskell
is a lazy language, meaning that any given piece of data is only
evaluated when its value must be known, there are some novel ways of
approaching I/O.</p>
<h2 data-number="4.1" id="hgetcontents"><span
class="header-section-number">4.1</span> hGetContents</h2>
<p>One novel way to approach I/O is the <code>hGetContents</code>
function.<a href="#fn8" class="footnote-ref" id="fnref8"
role="doc-noteref"><sup>8</sup></a> <code>hGetContents</code> has the
type <code>Handle -&gt; IO String</code>. The <code>String</code> it
returns represents all of the data in the file given by the
<code>Handle</code>.<a href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a></p>
<p>In a strictly-evaluated language, using such a function is often a
bad idea. It may be fine to read the entire contents of a 2KB file, but
if you try to read the entire contents of a 500GB file, you are likely
to crash due to lack of RAM to store all that data. In these languages,
you would traditionally use mechanisms such as loops to process the
file's entire data.</p>
<p>But <code>hGetContents</code> is different. The <code>String</code>
it returns is evaluated lazily. At the moment you call
<code>hGetContents</code>, nothing is actually read. Data is only read
from the <code>Handle</code> as the elements (characters) of the list
are processed. As elements of the <code>String</code> are no longer
used, Haskell's garbage collector automatically frees that memory. All
of this happens completely transparently to you. And since you have what
looks like–and, really, is–a pure <code>String</code>, you can pass it
to pure (non-I/O) code.</p>
<p>Let's take a quick look at an example. Back in <a
href="7-io.org::*Working With Files and Handles">the section called
"Working With Files and Handles"</a> imperative program that converted
the entire content of a file to uppercase. Its imperative algorithm was
similar to what you'd see in many other languages. Here now is the much
simpler algorithm that exploits lazy evaluation:</p>
<div class="captioned-content">
<div class="caption">
toupper-lazy1.hs
</div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>       inh <span class="ot">&lt;-</span> openFile <span class="st">&quot;input.txt&quot;</span> <span class="dt">ReadMode</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>       outh <span class="ot">&lt;-</span> openFile <span class="st">&quot;output.txt&quot;</span> <span class="dt">WriteMode</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> hGetContents inh</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> result <span class="ot">=</span> processData inpStr</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>       hPutStr outh result</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>       hClose inh</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>       hClose outh</span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a><span class="ot">processData ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>processData <span class="ot">=</span> <span class="fu">map</span> <span class="fu">toUpper</span></span></code></pre></div>
</div>
<p>Notice that <code>hGetContents</code> handled <em>all</em> of the
reading for us. Also, take a look at <code>processData</code>. It's a
pure function since it has no side effects and always returns the same
result each time it is called. It has no need to know–and no way to
tell–that its input is being read lazily from a file in this case. It
can work perfectly well with a 20-character literal or a 500GB data dump
on disk.</p>
<p>You can even verify that with <code>ghci</code>:</p>
<pre class="screen"><code>Prelude&gt; :load toupper-lazy1.hs
[1 of 1] Compiling Main             ( toupper-lazy1.hs, interpreted )
Ok, one module loaded.
*Main&gt; processData &quot;Hello, there! How are you?&quot;
&quot;HELLO, THERE! HOW ARE YOU?&quot;
&quot;HELLO, THERE!  HOW ARE YOU?&quot;
*Main&gt; :type processData
processData :: String -&gt; String
*Main&gt; :type processData &quot;Hello!&quot;
processData &quot;Hello!&quot; :: String
</code></pre>
<div class="WARNING">
<p>Warning</p>
<p>If we had tried to hang on to <code>inpStr</code> in the above
example, past the one place where it was used (the call to
<code>processData</code>), the program would have lost its memory
efficiency. That's because the compiler would have been forced to keep
<code>inpStr</code>'s value in memory for future use. Here it knows that
<code>inpStr</code> will never be reused, and frees the memory as soon
as it is done with it. Just remember: memory is only freed after its
last use.</p>
</div>
<p>This program was a bit verbose to make it clear that there was pure
code in use. Here's a bit more concise version, which we will build on
in the next examples:</p>
<div class="captioned-content">
<div class="caption">
toupper-lazy2.hs
</div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>       inh <span class="ot">&lt;-</span> openFile <span class="st">&quot;input.txt&quot;</span> <span class="dt">ReadMode</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>       outh <span class="ot">&lt;-</span> openFile <span class="st">&quot;output.txt&quot;</span> <span class="dt">WriteMode</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> hGetContents inh</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>       hPutStr outh (<span class="fu">map</span> <span class="fu">toUpper</span> inpStr)</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>       hClose inh</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>       hClose outh</span></code></pre></div>
</div>
<p>You are not required to ever consume all the data from the input file
when using <code>hGetContents</code>. Whenever the Haskell system
determines that the entire string <code>hGetContents</code> returned can
be garbage collected–which means it will never again be used–the file is
closed for you automatically. The same principle applies to data read
from the file. Whenever a given piece of data will never again be
needed, the Haskell environment releases the memory it was stored
within. Strictly speaking, we wouldn't have to call <code>hClose</code>
at all in this example program. However, it is still a good practice to
get into, as later changes to a program could make the call to
<code>hClose</code> important.</p>
<div class="WARNING">
<p>Warning</p>
<p>When using <code>hGetContents</code>, it is important to remember
that even though you may never again explicitly reference
<code>Handle</code> directly in the rest of the program, you must not
close the <code>Handle</code> until you have finished consuming its
results via <code>hGetContents</code>. Doing so would cause you to miss
on some or all of the file's data. Since Haskell is lazy, you generally
can assume that you have consumed input only after you have output the
result of the computations involving the input.</p>
</div>
<h2 data-number="4.2" id="readfile-and-writefile"><span
class="header-section-number">4.2</span> <code>readFile</code> and
<code>writeFile</code></h2>
<p>Haskell programmers use <code>hGetContents</code> as a filter quite
often. They read from one file, do something to the data, and write the
result out elsewhere. This is so common that there are some shortcuts
for doing it. <code>readFile</code> and <code>writeFile</code> are
shortcuts for working with files as strings. They handle all the details
of opening files, closing files, reading data, and writing data.
<code>readFile</code> uses <code>hGetContents</code> internally.</p>
<p>Can you guess the Haskell types of these functions? Let's check with
<code>ghci</code>:</p>
<pre class="screen"><code>ghci&gt; :type readFile
readFile :: FilePath -&gt; IO String
ghci&gt; :type writeFile
writeFile :: FilePath -&gt; String -&gt; IO ()
</code></pre>
<p>Now, here's an example program that uses <code>readFile</code> and
<code>writeFile</code>:</p>
<div class="captioned-content">
<div class="caption">
toupper-lazy3.hs
</div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> <span class="fu">readFile</span> <span class="st">&quot;input.txt&quot;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>       <span class="fu">writeFile</span> <span class="st">&quot;output.txt&quot;</span> (<span class="fu">map</span> <span class="fu">toUpper</span> inpStr)</span></code></pre></div>
</div>
<p>Look at that–the guts of the program take up only two lines!
<code>readFile</code> returned a lazy <code>String</code>, which we
stored in <code>inpStr</code>. We then took that, processed it, and
passed it to <code>writeFile</code> for writing.</p>
<p>Neither <code>readFile</code> nor <code>writeFile</code> ever provide
a <code>Handle</code> for you to work with, so there is nothing to ever
<code>hClose</code>. <code>readFile</code> uses
<code>hGetContents</code> internally, and the underlying
<code>Handle</code> will be closed when the returned <code>String</code>
is garbage-collected or all the input has been consumed.
<code>writeFile</code> will close its underlying <code>Handle</code>
when the entire <code>String</code> supplied to it has been written.</p>
<h2 data-number="4.3" id="a-word-on-lazy-output"><span
class="header-section-number">4.3</span> A Word On Lazy Output</h2>
<p>By now, you should understand how lazy input works in Haskell. But
what about laziness during output?</p>
<p>As you know, nothing in Haskell is evaluated before its value is
needed. Since functions such as <code>writeFile</code> and
<code>putStr</code> write out the entire <code>String</code> passed to
them, that entire <code>String</code> must be evaluated. So you are
guaranteed that the argument to <code>putStr</code> will be evaluated in
full.<a href="#fn10" class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a></p>
<p>But what does that mean for laziness of the input? In the examples
above, will the call to <code>putStr</code> or <code>writeFile</code>
force the entire input string to be loaded into memory at once, just to
be written out?</p>
<p>The answer is no. <code>putStr</code> (and all the similar output
functions) write out data as it becomes available. They also have no
need for keeping around data already written, so as long as nothing else
in the program needs it, the memory can be freed immediately. In a
sense, you can think of the <code>String</code> between
<code>readFile</code> and <code>writeFile</code> as a pipe linking the
two. Data goes in one end, is transformed some way, and flows back out
the other.</p>
<p>You can verify this yourself by generating a large
<code>input.txt</code> for <code
class="verbatim">toupper-lazy3.hs</code>. It may take a bit to process,
but you should see a constant–and low–memory usage while it is being
processed.</p>
<h2 data-number="4.4" id="interact"><span
class="header-section-number">4.4</span> <code>interact</code></h2>
<p>You learned that <code>readFile</code> and <code>writeFile</code>
address the common situation of reading from one file, making a
conversion, and writing to a different file. There's a situation that's
even more common than that: reading from standard input, making a
conversion, and writing the result to standard output. For that
situation, there is a function called <code>interact</code>. The type of
<code>interact</code> is <code>(String -&gt; String) -&gt; IO ()</code>.
That is, it takes one argument: a function of type
<code>String -&gt; String</code>. That function is passed the result of
~getContents~–that is, standard input read lazily. The result of that
function is sent to standard output.</p>
<p>We can convert our example program to operate on standard input and
standard output by using <code>interact</code>. Here's one way to do
that:</p>
<div class="captioned-content">
<div class="caption">
toupper-lazy4.hs
</div>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> (<span class="fu">map</span> <span class="fu">toUpper</span>)</span></code></pre></div>
</div>
<p>Look at that–/one/ line of code to achieve our transformation! To
achieve the same effect as with the previous examples, you could run
this one like this:</p>
<pre class="screen"><code>$ runghc toupper-lazy4.hs &lt; input.txt &gt; output.txt
</code></pre>
<p>Or, if you'd like to see the output printed to the screen, you could
type:</p>
<pre class="screen"><code>$ runghc toupper-lazy4.hs &lt; input.txt
</code></pre>
<p>If you want to see that Haskell output truly does write out chunks of
data as soon as they are received, run
<code>runghc toupper-lazy4.hs</code> without any other command-line
parameters. You should see each character echoed back out as soon as you
type it, but in uppercase. Buffering may change this behavior; see <a
href="7-io.org::*Buffering">the section called "Buffering"</a> for more
on buffering. If you see each line echoed as soon as you type it, or
even nothing at all for awhile, buffering is causing this behavior.</p>
<p>You can also write simple interactive programs using
<code>interact</code>. Let's start with a simple example: adding a line
of text before the uppercase output.</p>
<div class="captioned-content">
<div class="caption">
toupper-lazy5.hs
</div>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> (<span class="fu">map</span> <span class="fu">toUpper</span> <span class="op">.</span> (<span class="op">++</span>) <span class="st">&quot;Your data, in uppercase, is:\n\n&quot;</span>)</span></code></pre></div>
</div>
<div class="TIP">
<p>Tip</p>
<p>If the use of the <code>.</code> operator is confusing, you might
wish to refer to <a
href="4-functional-programming.org::*Code reuse through composition">the
section called "Code reuse through composition"</a></p>
</div>
<p>Here we add a string at the beginning of the output. Can you spot the
problem, though?</p>
<p>Since we're calling <code>map</code> on the <em>result</em> of
<code>(++)</code>, that header itself will appear in uppercase. We can
fix that in this way:</p>
<div class="captioned-content">
<div class="caption">
toupper-lazy6.hs
</div>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> ((<span class="op">++</span>) <span class="st">&quot;Your data, in uppercase, is:\n\n&quot;</span> <span class="op">.</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>                 <span class="fu">map</span> <span class="fu">toUpper</span>)</span></code></pre></div>
</div>
<p>This moved the header outside of the <code>map</code>.</p>
<ol>
<li><p>Filters with <code>interact</code></p>
<p>Another common use of <code>interact</code> is filtering. Let's say
that you want to write a program that reads a file and prints out every
line that contains the character "a". Here's how you might do that with
<code>interact</code>:</p>
<div class="captioned-content">
<div class="caption">
filter.hs
</div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> (<span class="fu">unlines</span> <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">elem</span> <span class="ch">&#39;a&#39;</span>) <span class="op">.</span> <span class="fu">lines</span>)</span></code></pre></div>
</div>
<p>This may have introduced three functions that you aren't familiar
with yet. Let's inspect their types with <code>ghci</code>:</p>
<pre class="screen"><code>ghci&gt; :type lines
lines :: String -&gt; [String]
ghci&gt; :type unlines
unlines :: [String] -&gt; String
ghci&gt; :type elem
elem :: (Eq a) =&gt; a -&gt; [a] -&gt; Bool
</code></pre>
<p>Can you guess what these functions do just by looking at their types?
If not, you can find them explained in <a
href="4-functional-programming.org::*Warming up: portably splitting lines of text">the
section called "Warming up: portably splitting lines of text"</a> and <a
href="4-functional-programming.org::*Special string-handling functions">the
section called "Special string-handling functions"</a> frequently see
<code>lines</code> and <code>unlines</code> used with I/O. Finally,
<code>elem</code> takes a element and a list and returns
<code>True</code> if that element occurs anywhere in the list.</p>
<p>Try running this over our standard example input:</p>
<pre class="screen"><code>$ runghc filter.hs &lt; input.txt
I like Haskell
Haskell is great
</code></pre>
<p>Sure enough, you got back the two lines that contain an "a". Lazy
filters are a powerful way to use Haskell. When you think about it, a
filter–such as the standard Unix program ~grep~–sounds a lot like a
function. It takes some input, applies some computation, and generates a
predictable output.</p></li>
</ol>
<h1 data-number="5" id="the-io-monad"><span
class="header-section-number">5</span> The IO Monad</h1>
<p>You've seen a number of examples of I/O in Haskell by this point.
Let's take a moment to step back and think about how I/O relates to the
broader Haskell language.</p>
<p>Since Haskell is a pure language, if you give a certain function a
specific argument, the function will return the same result every time
you give it that argument. Moreover, the function will not change
anything about the program's overall state.</p>
<p>You may be wondering, then, how I/O fits into this picture. Surely if
you want to read a line of input from the keyboard, the function to read
input can't possibly return the same result every time it is run, right?
Moreover, I/O is all about changing state. I/O could cause pixels on a
terminal to light up, to cause paper to start coming out of a printer,
or even to cause a package to be shipped from a warehouse on a different
continent. I/O doesn't just change the state of a program. You can think
of I/O as changing the state of the world.</p>
<h2 data-number="5.1" id="actions"><span
class="header-section-number">5.1</span> Actions</h2>
<p>Most languages do not make a distinction between a pure function and
an impure one. Haskell has functions in the mathematical sense: they are
purely computations which cannot be altered by anything external.
Moreover, the computation can be performed at any time–or even never, if
its result is never needed.</p>
<p>Clearly, then, we need some other tool to work with I/O. That tool in
Haskell is called <em>actions</em>. Actions resemble functions. They do
nothing when they are defined, but perform some task when they are
invoked. I/O actions are defined within the IO monad. Monads are a
powerful way of chaining functions together purely and are covered in <a
href="15-monads.org">Chapter 14, <em>Monads</em></a>. It's not necessary
to understand monads in order to understand I/O. Just understand that
the result type of actions is "tagged" with IO. Let's take a look at
some types:</p>
<pre class="screen"><code>ghci&gt; :type putStrLn
putStrLn :: String -&gt; IO ()
ghci&gt; :type getLine
getLine :: IO String
</code></pre>
<p>The type of <code>putStrLn</code> is just like any other function.
The function takes one parameter and returns an <code>IO ()</code>. This
<code>IO ()</code> is the action. You can store and pass actions in pure
code if you wish, though this isn't frequently done. An action doesn't
do anything until it is invoked. Let's look at an example of this:</p>
<div class="captioned-content">
<div class="caption">
actions.hs
</div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ot">str2action ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>str2action input <span class="ot">=</span> <span class="fu">putStrLn</span> (<span class="st">&quot;Data: &quot;</span> <span class="op">++</span> input)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ot">list2actions ::</span> [<span class="dt">String</span>] <span class="ot">-&gt;</span> [<span class="dt">IO</span> ()]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>list2actions <span class="ot">=</span> <span class="fu">map</span> str2action</span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="ot">numbers ::</span> [<span class="dt">Int</span>]</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a>numbers <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="ot">strings ::</span> [<span class="dt">String</span>]</span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a>strings <span class="ot">=</span> <span class="fu">map</span> <span class="fu">show</span> numbers</span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="ot">actions ::</span> [<span class="dt">IO</span> ()]</span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a>actions <span class="ot">=</span> list2actions strings</span>
<span id="cb29-15"><a href="#cb29-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-16"><a href="#cb29-16" aria-hidden="true" tabindex="-1"></a><span class="ot">printitall ::</span> <span class="dt">IO</span> ()</span>
<span id="cb29-17"><a href="#cb29-17" aria-hidden="true" tabindex="-1"></a>printitall <span class="ot">=</span> runall actions</span>
<span id="cb29-18"><a href="#cb29-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-19"><a href="#cb29-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- Take a list of actions, and execute each of them in turn.</span></span>
<span id="cb29-20"><a href="#cb29-20" aria-hidden="true" tabindex="-1"></a><span class="ot">runall ::</span> [<span class="dt">IO</span> ()] <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb29-21"><a href="#cb29-21" aria-hidden="true" tabindex="-1"></a>runall [] <span class="ot">=</span> <span class="fu">return</span> ()</span>
<span id="cb29-22"><a href="#cb29-22" aria-hidden="true" tabindex="-1"></a>runall (firstelem<span class="op">:</span>remainingelems) <span class="ot">=</span></span>
<span id="cb29-23"><a href="#cb29-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> firstelem</span>
<span id="cb29-24"><a href="#cb29-24" aria-hidden="true" tabindex="-1"></a>       runall remainingelems</span>
<span id="cb29-25"><a href="#cb29-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-26"><a href="#cb29-26" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> str2action <span class="st">&quot;Start of the program&quot;</span></span>
<span id="cb29-27"><a href="#cb29-27" aria-hidden="true" tabindex="-1"></a>          printitall</span>
<span id="cb29-28"><a href="#cb29-28" aria-hidden="true" tabindex="-1"></a>          str2action <span class="st">&quot;Done!&quot;</span></span></code></pre></div>
</div>
<p><code>str2action</code> is a function that takes one parameter and
returns an <code>IO ()</code>. As you can see at the end of
<code>main</code>, you could use this directly in another action and it
will print out a line right away. Or, you can store–but not execute–the
action from pure code. You can see an example of that in
<code>list2actions~–we use
~map</code> over <code>str2action</code> and return a list of actions,
just like we would with other pure data. You can see that everything up
through <code>printitall</code> is built up with pure tools.</p>
<p>Although we define <code>printitall</code>, it doesn't get executed
until its action is evaluated somewhere else. Notice in
<code>main</code> how we use <code>str2action</code> as an I/O action to
be executed, but earlier we used it outside of the I/O monad and
assembled results into a list.</p>
<p>You could think of it this way: every statement, except
<code>let</code>, in a <code>do</code> block must yield an I/O action
which will be executed.</p>
<p>The call to <code>printitall</code> finally executes all those
actions. Actually, since Haskell is lazy, the actions aren't generated
until here either.</p>
<p>When you run the program, your output will look like this:</p>
<pre class="screen"><code>Data: Start of the program
Data: 1
Data: 2
Data: 3
Data: 4
Data: 5
Data: 6
Data: 7
Data: 8
Data: 9
Data: 10
Data: Done!
</code></pre>
<p>We can actually write this in a much more compact way. Consider this
revision of the example:</p>
<div class="captioned-content">
<div class="caption">
actions2.hs
</div>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="ot">str2message ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>str2message input <span class="ot">=</span> <span class="st">&quot;Data: &quot;</span> <span class="op">++</span> input</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="ot">str2action ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>str2action <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="op">.</span> str2message</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="ot">numbers ::</span> [<span class="dt">Int</span>]</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>numbers <span class="ot">=</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">10</span>]</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span> str2action <span class="st">&quot;Start of the program&quot;</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>          <span class="fu">mapM_</span> (str2action <span class="op">.</span> <span class="fu">show</span>) numbers</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>          str2action <span class="st">&quot;Done!&quot;</span></span></code></pre></div>
</div>
<p>Notice in <code>str2action</code> the use of the standard function
composition operator. In <code>main</code>, there's a call to
<code>mapM_</code>. This function is similar to <code>map</code>. It
takes a function and a list. The function supplied to <code>mapM_</code>
is an I/O action that is executed for every item in the list.
<code>mapM_</code> throws out the result of the function, though you can
use <code>mapM</code> to return a list of I/O results if you want them.
Take a look at their types:</p>
<pre class="screen"><code>ghci&gt; :type mapM
mapM :: (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m [b]
ghci&gt; :type mapM_
mapM_ :: (Monad m) =&gt; (a -&gt; m b) -&gt; [a] -&gt; m ()
</code></pre>
<div class="TIP">
<p>Tip</p>
<p>These functions actually work for more than just I/O; they work for
any <code>Monad</code>. For now, wherever you see "M", just think "IO".
Also, functions that end with an underscore typically discard their
result.</p>
</div>
<p>Why a <code>mapM</code> when we already have <code>map</code>?
Because <code>map</code> is a pure function that returns a list. It
doesn't–and can't–actually execute actions directly. <code>mapM</code>
is a utility that lives in the IO monad and thus can actually execute
the actions.<a href="#fn11" class="footnote-ref" id="fnref11"
role="doc-noteref"><sup>11</sup></a></p>
<p>Going back to <code>main</code>, <code>mapM_</code> applies
<code>(str2action . show)</code> to every element in
<code>numbers</code>. <code>show</code> converts each number to a
<code>String</code> and <code>str2action</code> converts each
<code>String</code> to an action. <code>mapM_</code> combines these
individual actions into one big action that prints out lines.</p>
<h2 data-number="5.2" id="sequencing"><span
class="header-section-number">5.2</span> Sequencing</h2>
<p><code>do</code> blocks are actually shortcut notations for joining
together actions. There are two operators that you can use instead of
<code>do</code> blocks: <code>&gt;&gt;</code> and
<code>&gt;&gt;=</code>. Let's look at their types in
<code>ghci</code>:</p>
<pre class="screen"><code>ghci&gt; :type (&gt;&gt;)
(&gt;&gt;) :: (Monad m) =&gt; m a -&gt; m b -&gt; m b
ghci&gt; :type (&gt;&gt;=)
(&gt;&gt;=) :: (Monad m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</code></pre>
<p>The <code>&gt;&gt;</code> operator sequences two actions together:
the first action is performed, then the second. The result of the
computation is the result of the second action. The result of the first
action is thrown away. This is similar to simply having a line in a
<code>do</code> block. You might write
<code>putStrLn "line 1" &gt;&gt;</code> putStrLn "line 2" to test this
out. It will print out two lines, discard the result from the first
<code>putStrLn</code>, and provide the result from the second.</p>
<p>The <code>&gt;&gt;=</code> operator runs an action, then passes its
result to a function that returns an action. That second action is run
as well, and the result of the entire expression is the result of that
second action. As an example, you could write <code>getLine &gt;&gt;=
putStrLn</code>, which would read a line from the keyboard and then
display it back out.</p>
<p>Let's re-write one of our examples to avoid <code>do</code> blocks.
Remember this example from the start of the chapter?</p>
<div class="captioned-content">
<div class="caption">
basicio.hs
</div>
<div class="sourceCode" id="cb34"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="st">&quot;Greetings!  What is your name?&quot;</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Welcome to Haskell, &quot;</span> <span class="op">++</span> inpStr <span class="op">++</span> <span class="st">&quot;!&quot;</span></span></code></pre></div>
</div>
<p>Let's write that without a <code>do</code> block:</p>
<div class="captioned-content">
<div class="caption">
basicio-nodo.hs
</div>
<div class="sourceCode" id="cb35"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="st">&quot;Greetings!  What is your name?&quot;</span> <span class="op">&gt;&gt;</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">getLine</span> <span class="op">&gt;&gt;=</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>    (\ inpStr <span class="ot">-&gt;</span> <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Welcome to Haskell, &quot;</span> <span class="op">++</span> inpStr <span class="op">++</span> <span class="st">&quot;!&quot;</span>)</span></code></pre></div>
</div>
<p>The Haskell compiler internally performans a translation just like
this when you define a <code>do</code> block.</p>
<div class="TIP">
<p>Tip</p>
<p>Forgetting how to use <code>\</code> (lambda expressions)? See <a
href="4-functional-programming.org::*Anonymous (lambda) functions">the
section called "Anonymous (lambda) functions"</a></p>
</div>
<h2 data-number="5.3" id="the-true-nature-of-return"><span
class="header-section-number">5.3</span> The True Nature of Return</h2>
<p>Earlier in this chapter, we mentioned that <code>return</code> is
probably not what it looks like. Many languages have a keyword named
<code>return</code> that aborts execution of a function immediately and
returns a value to the caller.</p>
<p>The Haskell <code>return</code> function is quite different. In
Haskell, <code>return</code> is used to wrap data in a monad. When
speaking about I/O, <code>return</code> is used to take pure data and
bring it into the IO monad.</p>
<p>Now, why would we want to do that? Remember that anything whose
result depends on I/O must be within the IO monad. So if we are writing
a function that performs I/O, then a pure computation, we will need to
use <code>return</code> to make this pure computation the proper return
value of the function. Otherwise, a type error would occur. Here's an
example:</p>
<div class="captioned-content">
<div class="caption">
return1.hs
</div>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a><span class="ot">isGreen ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>isGreen <span class="ot">=</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Is green your favorite color?&quot;</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a>       <span class="fu">return</span> ((<span class="fu">toUpper</span> <span class="op">.</span> <span class="fu">head</span> <span class="op">$</span> inpStr) <span class="op">==</span> <span class="ch">&#39;Y&#39;</span>)</span></code></pre></div>
</div>
<p>We have a pure computation that yields a <code>Bool</code>. That
computation is passed to <code>return</code>, which puts it into the IO
monad. Since it is the last value in the <code>do</code> block, it
becomes the return value of <code>isGreen</code>, but this is not
because we used the <code>return</code> function.</p>
<p>Here's a version of the same program with the pure computation broken
out into a separate function. This helps keep the pure code separate,
and can also make the intent more clear.</p>
<div class="captioned-content">
<div class="caption">
return2.hs
</div>
<div class="sourceCode" id="cb37"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Char</span>(toUpper)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ot">isYes ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>isYes inpStr <span class="ot">=</span> (<span class="fu">toUpper</span> <span class="op">.</span> <span class="fu">head</span> <span class="op">$</span> inpStr) <span class="op">==</span> <span class="ch">&#39;Y&#39;</span></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="ot">isGreen ::</span> <span class="dt">IO</span> <span class="dt">Bool</span></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>isGreen <span class="ot">=</span></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> <span class="fu">putStrLn</span> <span class="st">&quot;Is green your favorite color?&quot;</span></span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>       inpStr <span class="ot">&lt;-</span> <span class="fu">getLine</span></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>       <span class="fu">return</span> (isYes inpStr)</span></code></pre></div>
</div>
<p>Finally, here's a contrived example to show that <code>return</code>
truly does not have to occur at the end of a <code>do</code> block. In
practice, it usually is, but it need not be so.</p>
<div class="captioned-content">
<div class="caption">
return3.hs
</div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">returnTest ::</span> <span class="dt">IO</span> ()</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>returnTest <span class="ot">=</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">do</span> one <span class="ot">&lt;-</span> <span class="fu">return</span> <span class="dv">1</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>       <span class="kw">let</span> two <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>       <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> (one <span class="op">+</span> two)</span></code></pre></div>
</div>
<p>Notice that we used <code>&lt;-</code> in combination with
<code>return</code>, but <code>let</code> in combination with the simple
literal. That's because we needed both values to be pure in order to add
them, and <code>&lt;-</code> pulls things out of monads, effectively
reversing the effect of <code>return</code>. Run this in
<code>ghci</code> and you'll see <code>3</code> displayed, as
expected.</p>
<h1 data-number="6" id="is-haskell-really-imperative"><span
class="header-section-number">6</span> Is Haskell Really
Imperative?</h1>
<p>These <code>do</code> blocks may look a lot like an imperative
language. After all, you're giving commands to run in sequence most of
the time.</p>
<p>But Haskell remains a lazy language at its core. While it is
necessary to sequence actions for I/O at times, this is done using tools
that are part of Haskell already. Haskell achieves a nice separation of
I/O from the rest of the language through the IO monad as well.</p>
<h1 data-number="7" id="side-effects-with-lazy-io"><span
class="header-section-number">7</span> Side Effects with Lazy I/O</h1>
<p>Earlier in this chapter, you read about <code>hGetContents</code>. We
explained that the <code>String</code> it returns can be used in pure
code.</p>
<p>We need to get a bit more specific about what side effects are. When
we say Haskell has no side-effects, what exactly does that mean?</p>
<p>At a certain level, side-effects are always possible. A
poorly-written loop, even if written in pure code, could cause the
system's RAM to be exhausted and the machine to crash. Or it could cause
data to be swapped to disk.</p>
<p>When we speak of no side effects, we mean that pure code in Haskell
can't run commands that trigger side effects. Pure functions can't
modify a global variable, request I/O, or run a command to take down a
system.</p>
<p>When you have a <code>String</code> from <code>hGetContents</code>
that is passed to a pure function, the function has no idea that this
<code>String</code> is backed by a disk file. It will behave just as it
always would, but processing that <code>String</code> may cause the
environment to issue I/O commands. The pure function isn't issuing them;
they are happening as a result of the processing the pure function is
doing, just as with the example of swapping RAM to disk.</p>
<p>In some cases, you may need more control over exactly when your I/O
occurs. Perhaps you are reading data interactively from the user, or via
a pipe from another program, and need to communicate directly with the
user. In those cases, <code>hGetContents</code> will probably not be
appropriate.</p>
<h1 data-number="8" id="buffering"><span
class="header-section-number">8</span> Buffering</h1>
<p>The I/O subsystem is one of the slowest parts of a modern computer.
Completing a write to disk can take thousands of times as long as a
write to memory. A write over the network can be hundreds or thousands
of times slower yet. Even if your operation doesn't directly communicate
with the disk–perhaps because the data is cached–I/O still involves a
system call, which slows things down by itself.</p>
<p>For this reason, modern operating systems and programming languages
both provide tools to help programs perform better where I/O is
concerned. The operating system typically performs caching–storing
frequently-used pieces of data in memory for faster access.</p>
<p>Programming languages typically perform buffering. This means that
they may request one large chunk of data from the operating system, even
if the code underneath is processing data one character at a time. By
doing this, they can achieve remarkable performance gains because each
request for I/O to the operating system carries a processing cost.
Buffering allows us to read the same amount of data with far fewer I/O
requests.</p>
<p>Haskell, too, provides buffering in its I/O system. In many cases, it
is even on by default. Up till now, we have pretended it isn't there.
Haskell usually is good about picking a good default buffering mode. But
this default is rarely the fastest. If you have speed-critical I/O code,
changing buffering could make a significant impact on your program.</p>
<h2 data-number="8.1" id="buffering-modes"><span
class="header-section-number">8.1</span> Buffering Modes</h2>
<p>There are three different buffering modes in Haskell. They are
defined as the <code>BufferMode</code> type: <code>NoBuffering</code>,
<code>LineBuffering</code>, and <code>BlockBuffering</code>.</p>
<p><code>NoBuffering</code> does just what it sounds like–no buffering.
Data read via functions like <code>hGetLine</code> will be read from the
OS one character at a time. Data written will be written immediately,
and also often will be written one character at a time. For this reason,
<code>NoBuffering</code> is usually a very poor performer and not
suitable for general-purpose use.</p>
<p><code>LineBuffering</code> causes the output buffer to be written
whenever the newline character is output, or whenever it gets too large.
On input, it will usually attempt to read whatever data is available in
chunks until it first sees the newline character. When reading from the
terminal, it should return data immediately after each press of
<code>Enter</code>. It is often a reasonable default.</p>
<p><code>BlockBuffering</code> causes Haskell to read or write data in
fixed-size chunks when possible. This is the best performer when
processing large amounts of data in batch, even if that data is
line-oriented. However, it is unusable for interactive programs because
it will block input until a full block is read.
<code>BlockBuffering</code> accepts one parameter of type
<code>Maybe</code>: if <code>Nothing</code>, it will use an
implementation-defined buffer size. Or, you can use a setting such as
<code>Just 4096</code> to set the buffer to 4096 bytes.</p>
<p>The default buffering mode is dependent upon the operating system and
Haskell implementation. You can ask the system for the current buffering
mode by calling <code>hGetBuffering</code>. The current mode can be set
with <code>hSetBuffering</code>, which accepts a <code>Handle</code> and
<code>BufferMode</code>. As an example, you can say
<code>hSetBuffering stdin (BlockBuffering Nothing)</code>.</p>
<h2 data-number="8.2" id="flushing-the-buffer"><span
class="header-section-number">8.2</span> Flushing The Buffer</h2>
<p>For any type of buffering, you may sometimes want to force Haskell to
write out any data that has been saved up in the buffer. There are a few
times when this will happen automatically: a call to
<code>hClose</code>, for instance. Sometimes you may want to instead
call <code>hFlush</code>, which will force any pending data to be
written immediately. This could be useful when the <code>Handle</code>
is a network socket and you want the data to be transmitted immediately,
or when you want to make the data on disk available to other programs
that might be reading it concurrently.</p>
<h1 data-number="9" id="reading-command-line-arguments"><span
class="header-section-number">9</span> Reading Command-Line
Arguments</h1>
<p>Many command-line programs are interested in the parameters passed on
the command line. <code>System.Environment.getArgs</code> returns
<code>IO [String]</code> listing each argument. This is the same as
<code>argv</code> in C, starting with <code>argv[1]</code>. The program
name (<code>argv[0]</code> in C) is available from
<code>System.Environment.getProgName</code>.</p>
<p>The <code>System.Console.GetOpt</code> module provides some tools for
parsing command-line options. If you have a program with complex
options, you may find it useful. You can find an example of its use in
<a
href="28-software-transactional-memory.org::*Command line parsing">the
section called "Command line parsing"</a></p>
<h1 data-number="10" id="environment-variables"><span
class="header-section-number">10</span> Environment Variables</h1>
<p>If you need to read environment variables, you can use one of two
functions in <code>System.Environment</code>: <code>getEnv</code> or
<code>getEnvironment</code>. <code>getEnv</code> looks for a specific
variable and raises an exception if it doesn't exist.
<code>getEnvironment</code> returns the whole environment as a
<code>[(String, String)]</code>, and then you can use functions such as
<code>lookup</code> to find the environment entry you want.</p>
<p>Setting environment variables is not defined in a cross-platform way
in Haskell. If you are on a POSIX platform such as Linux, you can use
<code>putEnv</code> or <code>setEnv</code> from the
<code>System.Posix.Env</code> module. Environment setting is not defined
for Windows.</p>
<h1 data-number="11" id="footnotes"><span
class="header-section-number">11</span> Footnotes</h1>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>You will later see that it has a more
broad application, but it is sufficient to think of it in these terms
for now.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The type of the value <code>()</code>
is also <code>()</code>.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>Imperative programmers might be
concerned that such a recursive call would consume large amounts of
stack space. In Haskell, recursion is a common idiom, and the compiler
is smart enough to avoid consuming much stack by optimizing
tail-recursive functions.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>If there was a bug in the C part of a
hybrid program, for instance<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>For more information on
interoperating with other programs with pipes, see <a
href="20-systems-programming-in-haskell.org::*Extended Example: Piping">the
section called "Extended Example: Piping"</a><a href="#fnref5"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>POSIX programmers may be interested
to know that this corresponds to <code>unlink()</code> in C.<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><code>hGetContents</code> will be
discussed in <a href="7-io.org::*Lazy I/O">the section called "Lazy
I/O"</a><a href="#fnref7" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>There is also a shortcut function
<code>getContents</code> that operates on standard input.<a
href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>More precisely, it is the entire data
from the current position of the file pointer to the end of the file.<a
href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Excepting I/O errors such as a full
disk, of course.<a href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>Technically speaking,
<code>mapM</code> combines a bunch of separate I/O actions into one big
action. The separate actions are executed when the big action is.<a
href="#fnref11" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
