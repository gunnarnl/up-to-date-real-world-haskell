<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 1: Getting Started</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 1: Getting Started</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#your-haskell-environment"><span
class="toc-section-number">1</span> Your Haskell environment</a></li>
<li><a href="#getting-started-with-ghci-the-interpreter"><span
class="toc-section-number">2</span> Getting started with ghci, the
interpreter</a></li>
<li><a href="#basic-interaction-using-ghci-as-a-calculator"><span
class="toc-section-number">3</span> Basic interaction: using ghci as a
calculator</a>
<ul>
<li><a href="#simple-arithmetic"><span
class="toc-section-number">3.1</span> Simple arithmetic</a></li>
<li><a href="#an-arithmetic-quirk-writing-negative-numbers"><span
class="toc-section-number">3.2</span> An arithmetic quirk: writing
negative numbers</a></li>
<li><a href="#boolean-logic-operators-and-value-comparisons"><span
class="toc-section-number">3.3</span> Boolean logic, operators, and
value comparisons</a></li>
<li><a href="#operator-precedence-and-associativity"><span
class="toc-section-number">3.4</span> Operator precedence and
associativity</a></li>
<li><a href="#undefined-values-and-introducing-variables"><span
class="toc-section-number">3.5</span> Undefined values, and introducing
variables</a></li>
<li><a href="#dealing-with-precedence-and-associativity-rules"><span
class="toc-section-number">3.6</span> Dealing with precedence and
associativity rules</a></li>
</ul></li>
<li><a href="#command-line-editing-in-ghci"><span
class="toc-section-number">4</span> Command line editing in
ghci</a></li>
<li><a href="#lists"><span class="toc-section-number">5</span> Lists</a>
<ul>
<li><a href="#operators-on-lists"><span
class="toc-section-number">5.1</span> Operators on lists</a></li>
</ul></li>
<li><a href="#strings-and-characters"><span
class="toc-section-number">6</span> Strings and characters</a></li>
<li><a href="#first-steps-with-types"><span
class="toc-section-number">7</span> First steps with types</a></li>
<li><a href="#a-simple-program"><span
class="toc-section-number">8</span> A simple program</a></li>
<li><a href="#exercises"><span class="toc-section-number">9</span>
Exercises</a></li>
<li><a href="#footnotes"><span class="toc-section-number">10</span>
Footnotes</a></li>
</ul>
</nav>
<p>As you read the early chapters of this book, keep in mind that we
will sometimes introduce ideas in restricted, simplified form. Haskell
is a deep language, and presenting every aspect of a given subject all
at once is likely to prove overwhelming. As we build a solid foundation
in Haskell, we will expand upon these initial explanations.</p>
<h1 data-number="1" id="your-haskell-environment"><span
class="header-section-number">1</span> Your Haskell environment</h1>
<p>The Glasgow Haskell Compiler (GHC) is the most widely used. It
compiles to native code, supports parallel execution, and provides
useful performance analysis and debugging tools.</p>
<p>GHC has three main components.</p>
<ul>
<li><code>ghc</code> is an optimizing compiler that generates fast
native code.</li>
<li><code>ghci</code> is an interactive interpreter and debugger.</li>
<li><code>runghc</code> is a program for running Haskell programs as
scripts, without needing to compile them first.</li>
</ul>
<div class="NOTE">
<p>How we refer to the components of GHC</p>
<p>When we discuss the GHC system as a whole, we will refer to it as
GHC. If we are talking about a specific command, we will mention
<code>ghc</code>, <code>ghci</code>, or <code>runghc</code> by name.</p>
</div>
<p>In this book, we assume that you're using at least version 8.2.2 of
GHC, which was released in 2017. To obtain a copy of GHC visit <a
href="http://www.haskell.org/downloads">the GHC download page</a>, and
look for the list of binary packages and installers.</p>
<p>Many Linux distributors, and providers of BSD and other Unix
variants, make custom binary packages of GHC available. Because these
are built specifically for each environment, they are much easier to
install and use than the generic binary packages that are available from
the GHC download page. You can find a list of distributions that
custom-build GHC at the GHC <a
href="http://www.haskell.org/ghc/distribution_packages.html">distribution
packages</a> page.</p>
<p>For more detailed information about how to install GHC on a variety
of popular platforms, we've provided some instructions in <a
href="installing-ghc-and-haskell-libraries.html">Appendix A,
<em>Installing GHC and Haskell libraries</em></a>.</p>
<h1 data-number="2" id="getting-started-with-ghci-the-interpreter"><span
class="header-section-number">2</span> Getting started with ghci, the
interpreter</h1>
<p>The interactive interpreter for GHC is a program named
<code>ghci</code>. It lets us enter and evaluate Haskell expressions,
explore modules, and debug our code. If you are familiar with Python or
Ruby, <code>ghci</code> is somewhat similar to <code>python</code> and
<code>irb</code>, the interactive Python and Ruby interpreters.</p>
<div class="NOTE">
<p>The <code>ghci</code> command has a narrow focus</p>
<p>We typically cannot copy some code out of a Haskell source file and
paste it into <code>ghci</code>. This does not have a significant effect
on debugging pieces of code, but it can initially be surprising if you
are used to, say, the interactive Python interpreter.</p>
</div>
<p>On Unix-like systems, we run <code>ghci</code> as a command in a
shell window. On Windows, it's available via the Start Menu. For
example, if you installed using the GHC installer on Windows, you should
go to "Programs", then "GHC"; you will then see <code>ghci</code> in the
list. (See <a
href="installing-ghc-and-haskell-libraries.org::*Windows">the section
called "Windows"</a> screenshot.)</p>
<p>When we run <code>ghci</code>, it displays a startup banner, followed
by a <code>Prelude&gt;</code> prompt. Here, we're showing version
8.2.2.</p>
<pre class="screen"><code>$ ghci
GHCi, version 8.2.2: http://www.haskell.org/ghc/  :? for help
Prelude&gt;
</code></pre>
<p>The word <code>Prelude</code> in the prompt indicates that
<code>Prelude</code>, a standard library of useful functions, is loaded
and ready to use. When we load other modules or source files, they will
show up in the prompt, too.</p>
<div class="TIP">
<p>Getting help</p>
<p>If you enter <code>:?</code> at the <code>ghci</code> prompt, it will
print a long help message.</p>
</div>
<p>The <code>Prelude</code> module is sometimes referred to as "the
standard prelude", because its contents are defined by the Haskell 2010
standard. Usually, it's simply shortened to "the prelude".</p>
<div class="NOTE">
<p>About the ghci prompt</p>
<p>The prompt displayed by <code>ghci</code> changes frequently
depending on what modules we have loaded. It can often grow long enough
to leave little visual room on a single line for our input.</p>
<p>For brevity and consistency, we have replaced <code>ghci</code>'s
default prompts throughout this book with the prompt string
<code>ghci&gt;</code>.</p>
<p>If you want to do this yourself, use <code>ghci</code>'s
<code>:set prompt</code> directive, as follows.</p>
<pre class="screen"><code>Prelude&gt; :set prompt &quot;ghci&gt; &quot;
ghci&gt;
</code></pre>
</div>
<p>The prelude is always implicitly available; we don't need to take any
actions to use the types, values, or functions it defines. To use
definitions from other modules, we must load them into
<code>ghci</code>, using the <code>:module</code> command.</p>
<pre class="screen"><code>ghci&gt; :module + Data.Ratio
</code></pre>
<p>We can now use the functionality of the <code>Data.Ratio</code>
module, which lets us work with rational numbers (fractions).</p>
<h1 data-number="3"
id="basic-interaction-using-ghci-as-a-calculator"><span
class="header-section-number">3</span> Basic interaction: using ghci as
a calculator</h1>
<p>In addition to providing a convenient interface for testing code
fragments, <code>ghci</code> can function as a readily accessible
desktop calculator. We can easily express any calculator operation in
<code>ghci</code> and, as an added bonus, we can add more complex
operations as we become more familiar with Haskell. Even using the
interpreter in this simple way can help us to become more comfortable
with how Haskell works.</p>
<h2 data-number="3.1" id="simple-arithmetic"><span
class="header-section-number">3.1</span> Simple arithmetic</h2>
<p>We can immediately start entering expressions, to see what
<code>ghci</code> will do with them. Basic arithmetic works similarly to
languages like C and Python: we write expressions in <em>infix</em>
form, where an operator appears between its operands.</p>
<pre class="screen"><code>ghci&gt; 2 + 2
4
ghci&gt; 31337 * 101
3165037
ghci&gt; 7.0 / 2.0
3.5
</code></pre>
<p>The infix style of writing an expression is just a convenience: we
can also write an expression in <em>prefix</em> form, where the operator
precedes its arguments. To do this, we must enclose the operator in
parentheses.</p>
<pre class="screen"><code>ghci&gt; 2 + 2
4
ghci&gt; (+) 2 2
4
</code></pre>
<p>As the expressions above imply, Haskell has a notion of integers and
floating point numbers. Integers can be arbitrarily large. Here,
<code>(^)</code> provides integer exponentiation.</p>
<pre class="screen"><code>ghci&gt; 313 ^ 15
27112218957718876716220410905036741257
</code></pre>
<h2 data-number="3.2"
id="an-arithmetic-quirk-writing-negative-numbers"><span
class="header-section-number">3.2</span> An arithmetic quirk: writing
negative numbers</h2>
<p>Haskell presents us with one peculiarity in how we must write
numbers: it's often necessary to enclose a negative number in
parentheses. This affects us as soon as we move beyond the simplest
expressions.</p>
<p>We'll start by writing a negative number.</p>
<pre class="screen"><code>ghci&gt; -3
-3
</code></pre>
<p>The <code>-</code> above is a unary operator. In other words, we
didn't write the single number "-3"; we wrote the number "3", and
applied the operator <code>-</code> to it. The <code>-</code> operator
is Haskell's only unary operator, and we cannot mix it with infix
operators.</p>
<pre class="screen"><code>ghci&gt; 2 + -3

&lt;interactive&gt;:1:1: error:
    Precedence parsing error
        cannot mix ‘+’ [infixl 6] and prefix `-&#39; [infixl 6] in the same infix expression
</code></pre>
<p>If we want to use the unary minus near an infix operator, we must
wrap the expression it applies to in parentheses.</p>
<pre class="screen"><code>ghci&gt; 2 + (-3)
-1
ghci&gt; 3 + (-(13 * 37))
-478
</code></pre>
<p>This avoids a parsing ambiguity. When we apply a function in Haskell,
we write the name of the function, followed by its argument, for example
<code>f 3</code>. If we did not need to wrap a negative number in
parentheses, we would have two profoundly different ways to read
<code>f-3</code>: it could be either "apply the function <code>f</code>
to the number <code>-3</code>", or "subtract the number <code>3</code>
from the variable <code>f</code>".</p>
<p><em>Most</em> of the time, we can omit white space ("blank"
characters such as space and tab) from expressions, and Haskell will
parse them as we intended. But not always. Here is an expression that
works:</p>
<pre class="screen"><code>ghci&gt; 2*3
6
</code></pre>
<p>And here is one that seems similar to the problematic negative number
example above, but results in a different error message.</p>
<pre class="screen"><code>ghci&gt; 2*-3

&lt;interactive&gt;:1:1: error:
    • Variable not in scope: (*-) :: Integer -&gt; Integer -&gt; t
    • Perhaps you meant one of these:
        ‘*’ (imported from Prelude), ‘-’ (imported from Prelude),
        ‘*&gt;’ (imported from Prelude)
</code></pre>
<p>Here, the Haskell implementation is reading <code>*-</code> as a
single operator. Haskell lets us define new operators (a subject that we
will return to later), but we haven't defined <code>*-</code>. Once
again, a few parentheses get us and <code>ghci</code> looking at the
expression in the same way.</p>
<pre class="screen"><code>ghci&gt; 2*(-3)
-6
</code></pre>
<p>Compared to other languages, this unusual treatment of negative
numbers might seem annoying, but it represents a reasoned trade-off.
Haskell lets us define new operators at any time. This is not some kind
of esoteric language feature; we will see quite a few user-defined
operators in the chapters ahead. The language designers chose to accept
a slightly cumbersome syntax for negative numbers in exchange for this
expressive power.</p>
<h2 data-number="3.3"
id="boolean-logic-operators-and-value-comparisons"><span
class="header-section-number">3.3</span> Boolean logic, operators, and
value comparisons</h2>
<p>The values of Boolean logic in Haskell are <code>True</code> and
<code>False</code>. The capitalization of these names is important. The
language uses C-influenced operators for working with Boolean values:
<code>(&amp;&amp;)</code> is logical "and", and <code>(||)</code> is
logical "or".</p>
<pre class="screen"><code>ghci&gt; True &amp;&amp; False
False
ghci&gt; False || True
True
</code></pre>
<p>While some programming languages treat the number zero as synonymous
with <code>False</code>, Haskell does not, nor does it consider a
non-zero value to be <code>True</code>.</p>
<pre class="screen"><code>ghci&gt; True &amp;&amp; 1

&lt;interactive&gt;:1:9: error:
    • No instance for (Num Bool) arising from the literal ‘1’
    • In the second argument of ‘(&amp;&amp;)’, namely ‘1’
      In the expression: True &amp;&amp; 1
      In an equation for ‘it’: it = True &amp;&amp; 1
</code></pre>
<p>Once again, we are faced with a substantial-looking error message. In
brief, it tells us that the boolean type, <code>Bool</code>, is not a
member of the family of numeric types, <code>Num</code>. The error
message is rather long because <code>ghci</code> is pointing out the
location of the problem, and hinting at a possible change we could make
that might fix the problem.</p>
<p>Here is a more detailed breakdown of the error message.</p>
<ul>
<li>"<code>No instance for (Num Bool)</code>" tells us that
<code>ghci</code> is trying to treat the numeric value 1 as having a
Bool type, but it cannot.</li>
<li>"<code>arising from the literal `1'</code>" indicates that it was
our use of the number <code>1</code> that caused the problem.</li>
<li>"<code>In the definition of `it'</code>" refers to a
<code>ghci</code> short cut that we will revisit in a few pages.</li>
</ul>
<div class="TIP">
<p>Remain fearless in the face of error messages</p>
<p>We have an important point to make here, which we will repeat
throughout the early sections of this book. If you run into problems or
error messages that you do not yet understand, <em>don't panic</em>.
Early on, all you have to do is figure out enough to make progress on a
problem. As you acquire experience, you will find it easier to
understand parts of error messages that initially seem obscure.</p>
<p>The numerous error messages have a purpose: they actually help us in
writing correct code, by making us perform some amount of debugging "up
front", before we ever run a program. If you are coming from a
background of working with more permissive languages, this way of
working may come as something of a shock. Bear with us.</p>
</div>
<p>Most of Haskell's comparison operators are similar to those used in C
and the many languages it has influenced.</p>
<pre class="screen"><code>ghci&gt; 1 == 1
True
ghci&gt; 2 &lt; 3
True
ghci&gt; 4 &gt;= 3.99
True
</code></pre>
<p>One operator that differs from its C counterpart is "is not equal
to". In C, this is written as <code>!=</code>. In Haskell, we write
<code>(/=)</code>, which resembles the ≠ notation used in
mathematics.</p>
<pre class="screen"><code>ghci&gt; 2 /= 3
True
</code></pre>
<p>Also, where C-like languages often use <code>!</code> for logical
negation, Haskell uses the <code>not</code> function.</p>
<pre class="screen"><code>ghci&gt; not True
False
</code></pre>
<h2 data-number="3.4" id="operator-precedence-and-associativity"><span
class="header-section-number">3.4</span> Operator precedence and
associativity</h2>
<p>Like written algebra and other programming languages that use infix
operators, Haskell has a notion of operator precedence. We can use
parentheses to explicitly group parts of an expression, and precedence
allows us to omit a few parentheses. For example, the multiplication
operator has a higher precedence than the addition operator, so Haskell
treats the following two expressions as equivalent.</p>
<pre class="screen"><code>ghci&gt; 1 + (4 * 4)
17
ghci&gt; 1 + 4 * 4
17
</code></pre>
<p>Haskell assigns numeric precedence values to operators, with 1 being
the lowest precedence and 9 the highest. A higher-precedence operator is
applied before a lower-precedence operator. We can use <code>ghci</code>
to inspect the precedence levels of individual operators, using its
<code>:info</code> command.</p>
<pre class="screen"><code>ghci&gt; :info (+)
class (Eq a, Show a) =&gt; Num a where
  (+) :: a -&gt; a -&gt; a
  ...
    -- Defined in GHC.Num
infixl 6 +
ghci&gt; :info (*)
class (Eq a, Show a) =&gt; Num a where
  ...
  (*) :: a -&gt; a -&gt; a
  ...
    -- Defined in GHC.Num
infixl 7 *
</code></pre>
<p>The information we seek is in the line "<code>infixl 6 +</code>",
which indicates that the <code>(+)</code> operator has a precedence of
6. (We will explain the other output in a later chapter.) The
"<code>infixl 7 *</code>" tells us that the <code>(*)</code> operator
has a precedence of 7. Since <code>(*)</code> has a higher precedence
than <code>(+)</code>, we can now see why <code>1 + 4 * 4</code> is
evaluated as <code>1 + (4 * 4)</code>, and not
<code>(1 + 4) * 4</code>.</p>
<p>Haskell also defines <em>associativity</em> of operators. This
determines whether an expression containing multiple uses of an operator
is evaluated from left to right, or right to left. The <code>(+)</code>
and <code>(*)</code> operators are left associative, which is
represented as <code>infixl</code> in the <code>ghci</code> output
above. A right associative operator is displayed with
<code>infixr</code>.</p>
<pre class="screen"><code>ghci&gt; :info (^)
(^) :: (Num a, Integral b) =&gt; a -&gt; b -&gt; a  -- Defined in GHC.Real
infixr 8 ^
</code></pre>
<p>The combination of precedence and associativity rules are usually
referred to as <em>fixity</em> rules.</p>
<h2 data-number="3.5"
id="undefined-values-and-introducing-variables"><span
class="header-section-number">3.5</span> Undefined values, and
introducing variables</h2>
<p>Haskell's prelude, the standard library we mentioned earlier, defines
at least one well-known mathematical constant for us.</p>
<pre class="screen"><code>ghci&gt; pi
3.141592653589793
</code></pre>
<p>But its coverage of mathematical constants is not comprehensive, as
we can quickly see. Let us look for Euler's number, <code>e</code>.</p>
<pre class="screen"><code>ghci&gt; e

&lt;interactive&gt;:1:1: error: Variable not in scope: e
</code></pre>
<p>Oh well. We have to define it ourselves.</p>
<div class="NOTE">
<p>Don't worry about the error message</p>
<p>If the above "not in scope" error message seems a little daunting, do
not worry. All it means is that there is no variable defined with the
name <code>e</code>.</p>
</div>
<p>Using <code>ghci</code>'s <code>let</code> construct, we can make a
temporary definition of <code>e</code> ourselves.</p>
<pre class="screen"><code>ghci&gt; e = exp 1
</code></pre>
<p>This is an application of the exponential function, <code>exp</code>,
and our first example of applying a function in Haskell. While languages
like Python require parentheses around the arguments to a function,
Haskell does not.</p>
<p>With <code>e</code> defined, we can now use it in arithmetic
expressions. The <code>(^)</code> exponentiation operator that we
introduced earlier can only raise a number to an integer power. To use a
floating point number as the exponent, we use the <code>(**)</code>
exponentiation operator.</p>
<pre class="screen"><code>ghci&gt; (e ** pi) - pi
19.99909997918947
</code></pre>
<div class="WARNING">
<p>This syntax is ghci-specific</p>
<p>The syntax for <code>let</code> that <code>ghci</code> accepts is not
the same as we would use at the "top level" of a normal Haskell program.
We will see the normal syntax in <a
href="3-defining-types-streamlining-functions.org::*Introducing local variables">the
section called "Introducing local variables"</a></p>
</div>
<h2 data-number="3.6"
id="dealing-with-precedence-and-associativity-rules"><span
class="header-section-number">3.6</span> Dealing with precedence and
associativity rules</h2>
<p>It is sometimes better to leave at least some parentheses in place,
even when Haskell allows us to omit them. Their presence can help future
readers (including ourselves) to understand what we intended.</p>
<p>Even more importantly, complex expressions that rely completely on
operator precedence are notorious sources of bugs. A compiler and a
human can easily end up with different notions of what even a short,
parenthesis-free expression is supposed to do.</p>
<p>There is no need to remember all of the precedence and associativity
rules numbers: it is simpler to add parentheses if you are unsure.</p>
<h1 data-number="4" id="command-line-editing-in-ghci"><span
class="header-section-number">4</span> Command line editing in ghci</h1>
<p>On most systems, <code>ghci</code> has some amount of command line
editing ability. In case you are not familiar with command line editing,
it's a huge time saver. The basics are common to both Unix-like and
Windows systems. Pressing the ↑ key on your keyboard recalls the last
line of input you entered; pressing ↑ repeatedly cycles through earlier
lines of input. You can use the ← and → arrow keys to move around inside
a line of input. On Unix (but not Windows, unfortunately), the
<code>tab</code> key completes partially entered identifiers.</p>
<div class="TIP">
<p>Where to look for more information</p>
<p>We've barely scratched the surface of command line editing here.
Since you can work more effectively if you're more familiar with the
capabilities of your command line editing system, you might find it
useful to do some further reading. <code>ghci</code> uses the Haskeline
library under the hood, which is <a
href="https://github.com/judah/haskeline/wiki/KeyBindings">powerful</a>
and <a
href="https://github.com/judah/haskeline/wiki/UserPreferences">customisable</a>.</p>
</div>
<h1 data-number="5" id="lists"><span
class="header-section-number">5</span> Lists</h1>
<p>A list is surrounded by square brackets; the elements are separated
by commas.</p>
<pre class="screen"><code>ghci&gt; [1, 2, 3]
[1,2,3]
</code></pre>
<div class="NOTE">
<p>Commas are separators, not terminators</p>
<p>Some languages permit the last element in a list to be followed by an
optional trailing comma before a closing bracket, but Haskell doesn't
allow this. If you leave in a trailing comma (e.g. <code>[1,2,]</code>),
you'll get a parse error.</p>
</div>
<p>A list can be of any length. The empty list is written
<code>[]</code>.</p>
<pre class="screen"><code>ghci&gt; []
[]
ghci&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;quux&quot;, &quot;fnord&quot;, &quot;xyzzy&quot;]
[&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;,&quot;quux&quot;,&quot;fnord&quot;,&quot;xyzzy&quot;]
</code></pre>
<p>All elements of a list must be of the same type. Here, we violate
this rule: our list starts with two Bool values, but ends with a
string.</p>
<pre class="screen"><code>ghci&gt; [True, False, &quot;testing&quot;]

&lt;interactive&gt;:1:15: error:
    • Couldn&#39;t match expected type ‘Bool’ with actual type ‘[Char]’
    • In the expression: &quot;testing&quot;
      In the expression: [True, False, &quot;testing&quot;]
      In an equation for ‘it’: it = [True, False, &quot;testing&quot;]
</code></pre>
<p>Once again, <code>ghci</code>'s error message is verbose, but it's
simply telling us that there is no way to turn the string into a Boolean
value, so the list expression isn't properly typed.</p>
<p>If we write a series of elements using <em>enumeration notation</em>,
Haskell will fill in the contents of the list for us.</p>
<pre class="screen"><code>ghci&gt; [1..10]
[1,2,3,4,5,6,7,8,9,10]
</code></pre>
<p>Here, the <code>..</code> characters denote an <em>enumeration</em>.
We can only use this notation for types whose elements we can enumerate.
It makes no sense for text strings, for instance: there is not any
sensible, general way to enumerate <code>["foo".."quux"]</code>.</p>
<p>By the way, notice that the above use of range notation gives us a
<em>closed interval</em>; the list contains both endpoints.</p>
<p>When we write an enumeration, we can optionally specify the size of
the step to use by providing the first two elements, followed by the
value at which to stop generating the enumeration.</p>
<pre class="screen"><code>ghci&gt; [1.0,1.25..2.0]
[1.0,1.25,1.5,1.75,2.0]
ghci&gt; [1,4..15]
[1,4,7,10,13]
ghci&gt; [10,9..1]
[10,9,8,7,6,5,4,3,2,1]
</code></pre>
<p>In the latter case above, the list is quite sensibly missing the end
point of the enumeration, because it isn't an element of the series we
defined.</p>
<p>We can omit the end point of an enumeration. If a type doesn't have a
natural "upper bound", this will produce values indefinitely. For
example, if you type <code>[1..]</code> at the <code>ghci</code> prompt,
you'll have to interrupt or kill <code>ghci</code> to stop it from
printing an infinite succession of ever-larger numbers. If you are
tempted to do this, type <code>Ctrl-C</code> to halt the enumeration. We
will find later on that infinite lists are often useful in Haskell.</p>
<div class="WARNING">
<p>Beware enumerating floating point numbers</p>
<p>Here's a non-intuitive bit of behaviour.</p>
<pre class="screen"><code>ghci&gt; [1.0..1.8]
[1.0,2.0]
</code></pre>
<p>Behind the scenes, to avoid floating point roundoff problems, the
Haskell implementation enumerates from <code>1.0</code> to
<code>1.8+0.5</code>.</p>
<p>Using enumeration notation over floating point numbers can pack more
than a few surprises, so if you use it at all, be careful. Floating
point behavior is quirky in all programming languages; there is nothing
unique to Haskell here.</p>
</div>
<h2 data-number="5.1" id="operators-on-lists"><span
class="header-section-number">5.1</span> Operators on lists</h2>
<p>There are two ubiquitous operators for working with lists. We
concatenate two lists using the <code>(++)</code> operator.</p>
<pre class="screen"><code>ghci&gt; [3,1,3] ++ [3,7]
[3,1,3,3,7]
ghci&gt; [] ++ [False,True] ++ [True]
[False,True,True]
</code></pre>
<p>More basic is the <code>(:)</code> operator, which adds an element to
the front of a list. This is pronounced "cons" (short for
"construct").</p>
<pre class="screen"><code>ghci&gt; 1 : [2,3]
[1,2,3]
ghci&gt; 1 : []
[1]
</code></pre>
<p>You might be tempted to try writing <code>[1,2] : 3</code> to add an
element to the end of a list, but <code>ghci</code> will reject this
with an error message, because the first argument of <code>(:)</code>
must be an element, and the second must be a list.</p>
<h1 data-number="6" id="strings-and-characters"><span
class="header-section-number">6</span> Strings and characters</h1>
<p>If you know a language like Perl or C, you'll find Haskell's
notations for strings familiar.</p>
<p>A text string is surrounded by double quotes.</p>
<pre class="screen"><code>ghci&gt; &quot;This is a string.&quot;
&quot;This is a string.&quot;
</code></pre>
<p>As in many languages, we can represent hard-to-see characters by
"escaping" them. Haskell's escape characters and escaping rules follow
the widely used conventions established by the C language. For example,
<code>'\n'</code> denotes a newline character, and <code>'\t'</code> is
a tab character. For complete details, see <a
href="appendix-characters-strings-and-escaping-rules.org">Appendix B,
<em>Characters, strings, and escaping rules</em></a>.</p>
<pre class="screen"><code>ghci&gt; putStrLn &quot;Here&#39;s a newline --&gt;\n&lt;-- See?&quot;
Here&#39;s a newline --&gt;
&lt;-- See?
</code></pre>
<p>Haskell makes a distinction between single characters and text
strings. A single character is enclosed in single quotes.</p>
<pre class="screen"><code>ghci&gt; &#39;a&#39;
&#39;a&#39;
</code></pre>
<p>In fact, a text string is simply a list of individual characters.
Here's a painful way to write a short string, which <code>ghci</code>
gives back to us in a more familiar form.</p>
<pre class="screen"><code>ghci&gt; a = [&#39;l&#39;, &#39;o&#39;, &#39;t&#39;, &#39;s&#39;, &#39; &#39;, &#39;o&#39;, &#39;f&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;k&#39;]
ghci&gt; a
&quot;lots of work&quot;
ghci&gt; a == &quot;lots of work&quot;
True
</code></pre>
<p>The empty string is written <code>""</code>, and is a synonym for
<code>[]</code>.</p>
<pre class="screen"><code>ghci&gt; &quot;&quot; == []
True
</code></pre>
<p>Since a string is a list of characters, we can use the regular list
operators to construct new strings.</p>
<pre class="screen"><code>ghci&gt; &#39;a&#39;:&quot;bc&quot;
&quot;abc&quot;
ghci&gt; &quot;foo&quot; ++ &quot;bar&quot;
&quot;foobar&quot;
</code></pre>
<h1 data-number="7" id="first-steps-with-types"><span
class="header-section-number">7</span> First steps with types</h1>
<p>While we've talked a little about types already, our interactions
with <code>ghci</code> have so far been free of much type-related
thinking. We haven't told <code>ghci</code> what types we've been using,
and it's mostly been willing to accept our input.</p>
<p>Haskell requires type names to start with an uppercase letter, and
variable names must start with a lowercase letter. Bear this in mind as
you read on; it makes it much easier to follow the names.</p>
<p>The first thing we can do to start exploring the world of types is to
get <code>ghci</code> to tell us more about what it's doing.
<code>ghci</code> has a command, <code>:set</code>, that lets us change
a few of its default behaviours. We can tell it to print more type
information as follows.</p>
<pre class="screen"><code>ghci&gt; :set +t
ghci&gt; &#39;c&#39;
&#39;c&#39;
it :: Char
ghci&gt; &quot;foo&quot;
&quot;foo&quot;
it :: [Char]
</code></pre>
<p>What the <code>+t</code> does is tell <code>ghci</code> to print the
type of an expression after the expression. That cryptic <code>it</code>
in the output can be very useful: it's actually the name of a special
variable, in which <code>ghci</code> stores the result of the last
expression we evaluated. (This isn't a Haskell language feature; it's
specific to <code>ghci</code> alone.) Let's break down the meaning of
the last line of <code>ghci</code> output.</p>
<ul>
<li>It's telling us about the special variable <code>it</code>.</li>
<li>We can read text of the form <code>x :: y</code> as meaning "the
expression <code>x</code> has the type <code>y</code>".</li>
<li>Here, the expression "it" has the type <code>[Char]</code>. (The
name <code>String</code> is often used instead of <code>[Char]</code>.
It is simply a synonym for <code>[Char]</code>.)</li>
</ul>
<div class="TIP">
<p>The joy of "it"</p>
<p>That <code>it</code> variable is a handy <code>ghci</code> shortcut.
It lets us use the result of the expression we just evaluated in a new
expression.</p>
<pre class="screen"><code>ghci&gt; &quot;foo&quot;
&quot;foo&quot;
it :: [Char]
ghci&gt; it ++ &quot;bar&quot;
&quot;foobar&quot;
it :: [Char]
</code></pre>
<p>When evaluating an expression, <code>ghci</code> won't change the
value of <code>it</code> if the evaluation fails. This lets you write
potentially bogus expressions with something of a safety net.</p>
<pre class="screen"><code>ghci&gt; it
&quot;foobar&quot;
it :: [Char]
ghci&gt; it ++ 3

&lt;interactive&gt;:1:1: error
    • No instance for (Num [Char]) arising from the literal ‘3’
    • In the second argument of ‘(++)’, namely ‘3’
      In the expression: it ++ 3
      In an equation for ‘it’: it = it ++ 3
ghci&gt; it
&quot;foobar&quot;
it :: [Char]
ghci&gt; it ++ &quot;baz&quot;
&quot;foobarbaz&quot;
it :: [Char]
</code></pre>
<p>When we couple <code>it</code> with liberal use of the arrow keys to
recall and edit the last expression we typed, we gain a decent way to
experiment interactively: the cost of mistakes is very low. Take
advantage of the opportunity to make cheap, plentiful mistakes when
you're exploring the language!</p>
</div>
<p>Here are a few more of Haskell's names for types, from expressions of
the sort we've already seen.</p>
<pre class="screen"><code>ghci&gt; 7 ^ 80
40536215597144386832065866109016673800875222251012083746192454448001
it :: Integer
</code></pre>
<p>Haskell's integer type is named <code>Integer</code>. The size of an
<code>Integer</code> value is bounded only by your system's memory
capacity.</p>
<p>Rational numbers don't look quite the same as integers. To construct
a rational number, we use the <code>(%)</code> operator. The numerator
is on the left, the denominator on the right.</p>
<pre class="screen"><code>ghci&gt; :m +Data.Ratio
ghci&gt; 11 % 29
11%29
it :: Integral a =&gt; Ratio a
</code></pre>
<p>For convenience, <code>ghci</code> lets us abbreviate many commands,
so we can write <code>:m</code> instead of <code>:module</code> to load
a module.</p>
<p>Notice <em>two</em> words on the right hand side of the
<code>::</code> above. We can read this as a "ratio of integer". We
might guess that a <code>Ratio</code> must have values of type Integer
as both numerator and denominator. Sure enough, if we try to construct a
<code>Ratio</code> where the numerator and denominator are of different
types, or of the same non-integral type, <code>ghci</code>
complains.</p>
<pre class="screen"><code>ghci&gt; 3.14 % 8

&lt;interactive&gt;:1:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance Show a =&gt; Show (Ratio a) -- Defined in ‘GHC.Real’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 23 others
        ...plus 11 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
ghci&gt; 1.2 % 3.4

&lt;interactive&gt;:1:1: error:
    • Ambiguous type variable ‘a0’ arising from a use of ‘print’
      prevents the constraint ‘(Show a0)’ from being solved.
      Probable fix: use a type annotation to specify what ‘a0’ should be.
      These potential instances exist:
        instance Show a =&gt; Show (Ratio a) -- Defined in ‘GHC.Real’
        instance Show Ordering -- Defined in ‘GHC.Show’
        instance Show Integer -- Defined in ‘GHC.Show’
        ...plus 23 others
        ...plus 11 instances involving out-of-scope types
        (use -fprint-potential-instances to see them all)
    • In a stmt of an interactive GHCi command: print it
</code></pre>
<p>Although it is initially useful to have <code>:set +t</code> giving
us type information for every expression we enter, this is a facility we
will quickly outgrow. After a while, we will often know what type we
expect an expression to have. We can turn off the extra type information
at any time, using the <code>:unset</code> command.</p>
<pre class="screen"><code>ghci&gt; :unset +t
ghci&gt; 2
2
</code></pre>
<p>Even with this facility turned off, we can still get that type
information easily when we need it, using another <code>ghci</code>
command.</p>
<pre class="screen"><code>ghci&gt; :type &#39;a&#39;
&#39;a&#39; :: Char
ghci&gt; &quot;foo&quot;
&quot;foo&quot;
ghci&gt; :type it
it :: [Char]
</code></pre>
<p>The <code>:type</code> command will print type information for any
expression we give it (including <code>it</code>, as we see above). It
won't actually evaluate the expression; it only checks its type and
prints that.</p>
<p>Why are the types reported for these two expressions different?</p>
<pre class="screen"><code>ghci&gt; 3 + 2
5
ghci&gt; :type it
it :: Integer
ghci&gt; :type 3 + 2
3 + 2 :: (Num t) =&gt; t
</code></pre>
<p>Haskell has several numeric types. For example, a literal number such
as <code>1</code> could, depending on the context in which it appears,
be an integer or a floating point value. When we force <code>ghci</code>
to evaluate the expression <code>3 + 2</code>, it has to choose a type
so that it can print the value, and it defaults to <code>Integer</code>.
In the second case, we ask <code>ghci</code> to print the type of the
expression without actually evaluating it, so it does not have to be so
specific. It answers, in effect, "its type is numeric". We will see more
of this style of type annotation in <a
href="6-using-typeclasses.org">Chapter 6, Using Type Classes</a>.</p>
<h1 data-number="8" id="a-simple-program"><span
class="header-section-number">8</span> A simple program</h1>
<p>Let's take a small leap ahead, and write a small program that counts
the number of lines in its input. Don't expect to understand this yet;
it's just fun to get our hands dirty. In a text editor, enter the
following code into a file, and save it as <code>WC.hs</code>.</p>
<div class="captioned-content">
<div class="caption">
wc.hs
</div>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- lines beginning with &quot;--&quot; are comments.</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="fu">interact</span> wordCount</span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> wordCount input <span class="ot">=</span> <span class="fu">show</span> (<span class="fu">length</span> (<span class="fu">lines</span> input)) <span class="op">++</span> <span class="st">&quot;\n&quot;</span></span></code></pre></div>
</div>
<p>Find or create a text file; let's call it <code>quux.txt</code><a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>.</p>
<pre class="screen"><code>$ cat quux.txt
Teignmouth, England
Paris, France
Ulm, Germany
Auxerre, France
Brunswick, Germany
Beaumont-en-Auge, France
Ryazan, Russia
</code></pre>
<p>From a shell or command prompt, run the following command.</p>
<pre class="screen"><code>$ runghc wc &lt; quux.txt
7
</code></pre>
<p>We have successfully written a simple program that interacts with the
real world! In the chapters that follow, we will successively fill the
gaps in our understanding until we can write programs of our own.</p>
<h1 data-number="9" id="exercises"><span
class="header-section-number">9</span> Exercises</h1>
<ol>
<li><p>Enter the following expressions into <code>ghci</code>. What are
their types?</p>
<ul>
<li><code>5 + 8</code></li>
<li><code>3 * 5 + 8</code></li>
<li><code>2 + 4</code></li>
<li><code>(+) 2 4</code></li>
<li><code>sqrt 16</code></li>
<li><code>succ 6</code></li>
<li><code>succ 7</code></li>
<li><code>pred 9</code></li>
<li><code>pred 8</code></li>
<li><code>sin (pi / 2)</code></li>
<li><code>truncate pi</code></li>
<li><code>round 3.5</code></li>
<li><code>round 3.4</code></li>
<li><code>floor 3.7</code></li>
<li><code>ceiling 3.3</code></li>
</ul></li>
<li><p>From <code>ghci</code>, type <code>:?</code> to print some help.
Define a variable, such as <code>x = 1</code>, then type
<code>:show bindings</code>. What do you see?</p></li>
<li><p>The <code>words</code> function counts the number of words in a
string. Modify the <code>wc.hs</code> example to count the number of
words in a file.</p></li>
<li><p>Modify the <code>wc.hs</code> example again, to print the number
of characters in a file.</p></li>
</ol>
<h1 data-number="10" id="footnotes"><span
class="header-section-number">10</span> Footnotes</h1>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Incidentally, what do these cities
have in common?<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
