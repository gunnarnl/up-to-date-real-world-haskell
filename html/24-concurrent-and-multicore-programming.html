<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Chapter 24. Concurrent and multicore programming</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">Chapter 24. Concurrent and multicore programming</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#defining-concurrency-and-parallelism"><span
class="toc-section-number">1</span> Defining concurrency and
parallelism</a></li>
<li><a href="#concurrent-programming-with-threads"><span
class="toc-section-number">2</span> Concurrent programming with
threads</a>
<ul>
<li><a href="#threads-are-nondeterministic"><span
class="toc-section-number">2.1</span> Threads are
nondeterministic</a></li>
<li><a href="#hiding-latency"><span
class="toc-section-number">2.2</span> Hiding latency</a></li>
</ul></li>
<li><a href="#simple-communication-between-threads"><span
class="toc-section-number">3</span> Simple communication between
threads</a></li>
<li><a href="#the-main-thread-and-waiting-for-other-threads"><span
class="toc-section-number">4</span> The main thread and waiting for
other threads</a>
<ul>
<li><a href="#safely-modifying-an-mvar"><span
class="toc-section-number">4.1</span> Safely modifying an
<code>MVar</code></a></li>
<li><a
href="#safe-resource-management-a-good-idea-and-easy-besides"><span
class="toc-section-number">4.2</span> Safe resource management: a good
idea, and easy besides</a></li>
<li><a href="#finding-the-status-of-a-thread"><span
class="toc-section-number">4.3</span> Finding the status of a
thread</a></li>
<li><a href="#writing-tighter-code"><span
class="toc-section-number">4.4</span> Writing tighter code</a></li>
</ul></li>
<li><a href="#communicating-over-channels"><span
class="toc-section-number">5</span> Communicating over channels</a></li>
<li><a href="#useful-things-to-know-about"><span
class="toc-section-number">6</span> Useful things to know about</a>
<ul>
<li><a href="#mvar-and-chan-are-non-strict"><span
class="toc-section-number">6.1</span> <code>MVar</code> and
<code>Chan</code> are non-strict</a></li>
<li><a href="#chan-is-unbounded"><span
class="toc-section-number">6.2</span> Chan is unbounded</a></li>
</ul></li>
<li><a href="#shared-state-concurrency-is-still-hard"><span
class="toc-section-number">7</span> Shared-state concurrency is still
hard</a>
<ul>
<li><a href="#deadlock"><span class="toc-section-number">7.1</span>
Deadlock</a></li>
<li><a href="#starvation"><span class="toc-section-number">7.2</span>
Starvation</a></li>
<li><a href="#is-there-any-hope"><span
class="toc-section-number">7.3</span> Is there any hope?</a></li>
</ul></li>
<li><a href="#exercises"><span class="toc-section-number">8</span>
Exercises</a></li>
<li><a href="#using-multiple-cores-with-ghc"><span
class="toc-section-number">9</span> Using multiple cores with GHC</a>
<ul>
<li><a href="#runtime-options"><span
class="toc-section-number">9.1</span> Runtime options</a></li>
<li><a href="#finding-the-number-of-available-cores-from-haskell"><span
class="toc-section-number">9.2</span> Finding the number of available
cores from Haskell</a></li>
<li><a href="#choosing-the-right-runtime"><span
class="toc-section-number">9.3</span> Choosing the right
runtime</a></li>
</ul></li>
<li><a href="#parallel-programming-in-haskell"><span
class="toc-section-number">10</span> Parallel programming in Haskell</a>
<ul>
<li><a href="#normal-form-and-head-normal-form"><span
class="toc-section-number">10.1</span> Normal form and head normal
form</a></li>
<li><a href="#sequential-sorting"><span
class="toc-section-number">10.2</span> Sequential sorting</a></li>
<li><a href="#transforming-our-code-into-parallel-code"><span
class="toc-section-number">10.3</span> Transforming our code into
parallel code</a></li>
<li><a href="#knowing-what-to-evaluate-in-parallel"><span
class="toc-section-number">10.4</span> Knowing what to evaluate in
parallel</a></li>
<li><a href="#what-promises-does-par-make"><span
class="toc-section-number">10.5</span> What promises does par
make?</a></li>
<li><a href="#running-our-code-and-measuring-performance"><span
class="toc-section-number">10.6</span> Running our code, and measuring
performance</a></li>
<li><a href="#tuning-for-performance"><span
class="toc-section-number">10.7</span> Tuning for performance</a></li>
<li><a href="#exercises-1"><span class="toc-section-number">10.8</span>
Exercises</a></li>
</ul></li>
<li><a href="#parallel-strategies-and-mapreduce"><span
class="toc-section-number">11</span> Parallel strategies and
<code>MapReduce</code></a>
<ul>
<li><a href="#separating-algorithm-from-evaluation"><span
class="toc-section-number">11.1</span> Separating algorithm from
evaluation</a></li>
<li><a href="#separating-algorithm-from-strategy"><span
class="toc-section-number">11.2</span> Separating algorithm from
strategy</a></li>
<li><a href="#writing-a-simple-mapreduce-definition"><span
class="toc-section-number">11.3</span> Writing a simple MapReduce
definition</a></li>
<li><a href="#mapreduce-and-strategies"><span
class="toc-section-number">11.4</span> MapReduce and strategies</a></li>
<li><a href="#sizing-work-appropriately"><span
class="toc-section-number">11.5</span> Sizing work
appropriately</a></li>
<li><a href="#efficiently-finding-line-aligned-chunks"><span
class="toc-section-number">11.6</span> Efficiently finding line-aligned
chunks</a></li>
<li><a href="#counting-lines"><span
class="toc-section-number">11.7</span> Counting lines</a></li>
<li><a href="#finding-the-most-popular-urls"><span
class="toc-section-number">11.8</span> Finding the most popular
URLs</a></li>
<li><a href="#conclusions"><span class="toc-section-number">11.9</span>
Conclusions</a></li>
</ul></li>
<li><a href="#footnotes"><span class="toc-section-number">12</span>
Footnotes</a></li>
</ul>
</nav>
<p>As we write this book, the landscape of CPU architecture is changing
more rapidly than it has in decades.</p>
<h1 data-number="1" id="defining-concurrency-and-parallelism"><span
class="header-section-number">1</span> Defining concurrency and
parallelism</h1>
<p>A <em>concurrent</em> program needs to perform several possibly
unrelated tasks at the same time. Consider the example of a game server:
it is typically composed of dozens of components, each of which has
complicated interactions with the outside world. One component might
handle multi-user chat; several more will process the inputs of players,
and feed state updates back to them; while another performs physics
calculations.</p>
<p>The correct operation of a concurrent program does not require
multiple cores, though they may improve performance and
responsiveness.</p>
<p>In contrast, a <em>parallel</em> program solves a single problem.
Consider a financial model that attempts to predict the next minute of
fluctuations in the price of a single stock. If we want to apply this
model to every stock listed on an exchange, for example to estimate
which ones we should buy and sell, we hope to get an answer more quickly
if we run the model on five hundred cores than if we use just one. As
this suggests, a parallel program does not usually depend on the
presence of multiple cores to work correctly.</p>
<p>Another useful distinction between concurrent and parallel programs
lies in their interaction with the outside world. By definition, a
concurrent program deals continuously with networking protocols,
databases, and the like. A typical parallel program is likely to be more
focused: it streams data in, crunches it for a while (with little
further I/O), then streams data back out.</p>
<p>Many traditional languages further blur the already indistinct
boundary between concurrent and parallel programming, because they force
programmers to use the same primitives to construct both kinds of
program.</p>
<p>In this chapter, we will concern ourselves with concurrent and
parallel programs that operate within the boundaries of a single
operating system process.</p>
<h1 data-number="2" id="concurrent-programming-with-threads"><span
class="header-section-number">2</span> Concurrent programming with
threads</h1>
<p>As a building block for concurrent programs, most programming
languages provide a way of creating multiple independent <em>threads of
control</em>. Haskell is no exception, though programming with threads
in Haskell looks somewhat different than in other languages.</p>
<p>In Haskell, a thread is an <code>IO</code> action that executes
independently from other threads. To create a thread, we import the
<code>Control.Concurrent</code> module and use the <code>forkIO</code>
function.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Concurrent
ghci&gt; :t forkIO
forkIO :: IO () -&gt; IO ThreadId
ghci&gt; :m +System.Directory
ghci&gt; forkIO (writeFile &quot;xyzzy&quot; &quot;seo craic nua!&quot;) &gt;&gt; doesFileExist &quot;xyzzy&quot;
False
</code></pre>
<p>The new thread starts to execute almost immediately, and the thread
that created it continues to execute concurrently. The thread will stop
executing when it reaches the end of its <code>IO</code> action.</p>
<h2 data-number="2.1" id="threads-are-nondeterministic"><span
class="header-section-number">2.1</span> Threads are
nondeterministic</h2>
<p>The runtime component of GHC does not specify an order in which it
executes threads. As a result, in our example above, the file
<code>xyzzy</code> created by the new thread <em>may or may not</em>
have been created by the time the original thread checks for its
existence. If we try this example once, then remove <code>xyzzy</code>
and try again, we may get a different result the second time.</p>
<h2 data-number="2.2" id="hiding-latency"><span
class="header-section-number">2.2</span> Hiding latency</h2>
<p>Suppose we have a large file to compress and write to disk, but we
want to handle a user's input quickly enough that they will perceive our
program as responding immediately. If we use <code>forkIO</code> to
write the file out in a separate thread, we can do both
simultaneously.</p>
<div class="captioned-content">
<div class="caption">
Compressor.hs
</div>
<div class="sourceCode" id="cb2"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span> (forkIO)</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span> (handle)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forever)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Console.Readline</span> (readline)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co">-- Provided by the &#39;zlib&#39; package on http://hackage.haskell.org/</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Codec.Compression.GZip</span> (compress)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    maybeLine <span class="ot">&lt;-</span> readline <span class="st">&quot;Enter a file to compress&gt; &quot;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> maybeLine <span class="kw">of</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()      <span class="co">-- user entered EOF</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> <span class="st">&quot;&quot;</span> <span class="ot">-&gt;</span> <span class="fu">return</span> ()      <span class="co">-- treat no name as &quot;want to quit&quot;</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> name <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>           handle <span class="fu">print</span> <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>             content <span class="ot">&lt;-</span> L.readFile name</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>             forkIO (compressFile name content)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>             <span class="fu">return</span> ()</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>           main</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> compressFile path <span class="ot">=</span> L.writeFile (path <span class="op">++</span> <span class="st">&quot;.gz&quot;</span>) <span class="op">.</span> compress</span></code></pre></div>
</div>
<p>Because we're using lazy <code>ByteString</code> I/O here, all we
really do in the main thread is open the file. The actual reading occurs
on demand in the other thread.</p>
<p>The use of <code>handle print</code> gives us a cheap way to print an
error message if the user enters the name of a file that does not
exist.</p>
<h1 data-number="3" id="simple-communication-between-threads"><span
class="header-section-number">3</span> Simple communication between
threads</h1>
<p>The simplest way to share information between two threads is to let
them both use a variable. In our file compression example, the
<code>main</code> thread shares both the name of a file and its contents
with the other thread. Because Haskell data is immutable by default,
this poses no risks: neither thread can modify the other's view of the
file's name or contents.</p>
<p>We often need to have threads actively communicate with each other.
For example, GHC does not provide a way for one thread to find out
whether another is still executing, has completed, or has crashed<a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>. However, it provides a
<em>synchronizing variable</em> type, the <code>MVar</code>, which we
can use to create this capability for ourselves.</p>
<p>An <code>MVar</code> acts like a single-element box: it can be either
full or empty. We can put something into the box, making it full, or
take something out, making it empty.</p>
<pre class="screen"><code>ghci&gt; :t putMVar
putMVar :: MVar a -&gt; a -&gt; IO ()
ghci&gt; :t takeMVar
takeMVar :: MVar a -&gt; IO a
</code></pre>
<p>If we try to put a value into an <code>MVar</code> that is already
full, our thread is put to sleep until another thread takes the value
out. Similarly, if we try to take a value from an empty
<code>MVar</code>, our thread is put to sleep until some other thread
puts a value in.</p>
<div class="captioned-content">
<div class="caption">
MVarExample.hs
</div>
<div class="sourceCode" id="cb4"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>communicate <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>  m <span class="ot">&lt;-</span> newEmptyMVar</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    v <span class="ot">&lt;-</span> takeMVar m</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> (<span class="st">&quot;received &quot;</span> <span class="op">++</span> <span class="fu">show</span> v)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;sending&quot;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  putMVar m <span class="st">&quot;wake up!&quot;</span></span></code></pre></div>
</div>
<p>The <code>newEmptyMVar</code> function has a descriptive name. To
create an <code>MVar</code> that starts out non-empty, we'd use
<code>newMVar</code>.</p>
<pre class="screen"><code>ghci&gt; :t newEmptyMVar
newEmptyMVar :: IO (MVar a)
ghci&gt; :t newMVar
newMVar :: a -&gt; IO (MVar a)
</code></pre>
<p>Let's run our example in <code>ghci</code>.</p>
<pre class="screen"><code>ghci&gt; :load MVarExample
[1 of 1] Compiling Main             ( MVarExample.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; communicate
sending
rece
</code></pre>
<p>If you're coming from a background of concurrent programming in a
traditional language, you can think of an <code>MVar</code> as being
useful for two familiar purposes.</p>
<ul>
<li>Sending a message from one thread to another, e.g. a
notification.</li>
<li>Providing <em>mutual exclusion</em> for a piece of mutable data that
is shared among threads. We put the data into the <code>MVar</code> when
it is not being used by any thread, and one thread takes it out
temporarily to read or modify it.</li>
</ul>
<h1 data-number="4"
id="the-main-thread-and-waiting-for-other-threads"><span
class="header-section-number">4</span> The main thread and waiting for
other threads</h1>
<p>GHC's runtime system treats the program's original thread of control
differently from other threads. When this thread finishes executing, the
runtime system considers the program as a whole to have completed. If
any other threads are executing at the time, they are terminated.</p>
<p>As a result, when we have long-running threads that must not be
killed, we must make special arrangements to ensure that the main thread
doesn't complete until the others do. Let's develop a small library that
makes this easy to do.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb7"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span> (<span class="dt">Exception</span>, try)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ThreadStatus</span> <span class="ot">=</span> <span class="dt">Running</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">Finished</span>         <span class="co">-- terminated normally</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                  <span class="op">|</span> <span class="dt">Threw</span> <span class="dt">Exception</span>  <span class="co">-- killed by uncaught exception</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Create a new thread manager.</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="ot">newManager ::</span> <span class="dt">IO</span> <span class="dt">ThreadManager</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Create a new managed thread.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="ot">forkManaged ::</span> <span class="dt">ThreadManager</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> () <span class="ot">-&gt;</span> <span class="dt">IO</span> <span class="dt">ThreadId</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Immediately return the status of a managed thread.</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="ot">getStatus ::</span> <span class="dt">ThreadManager</span> <span class="ot">-&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">ThreadStatus</span>)</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Block until a specific managed thread terminates.</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="ot">waitFor ::</span> <span class="dt">ThreadManager</span> <span class="ot">-&gt;</span> <span class="dt">ThreadId</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Maybe</span> <span class="dt">ThreadStatus</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co">-- | Block until all managed threads terminate.</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a><span class="ot">waitAll ::</span> <span class="dt">ThreadManager</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span></code></pre></div>
</div>
<p>We keep our <code>ThreadManager</code> type abstract using the usual
recipe: we wrap it in a <code>newtype</code>, and prevent clients from
creating values of this type. Among our module's exports, we list the
type constructor and the <code>IO</code> action that constructs a
manager, but we do not export the data constructor.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb8"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">NiceFork</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">ThreadManager</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    , newManager</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    , forkManaged</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    , getStatus</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    , waitFor</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    , waitAll</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">where</span></span></code></pre></div>
</div>
<p>For the implementation of <code>ThreadManager</code>, we maintain a
map from thread <code>ID</code> to thread state. We'll refer to this as
the <em>thread map</em>.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb9"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">ThreadManager</span> <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Mgr</span> (<span class="dt">MVar</span> (<span class="dt">M.Map</span> <span class="dt">ThreadId</span> (<span class="dt">MVar</span> <span class="dt">ThreadStatus</span>)))</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">deriving</span> (<span class="dt">Eq</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>newManager <span class="ot">=</span> <span class="dt">Mgr</span> <span class="ot">`fmap`</span> newMVar M.empty</span></code></pre></div>
</div>
<p>We have two levels of <code>MVar</code> use here. We keep the
<code>Map</code> in an <code>MVar</code>. This lets us "modify" the map
by replacing it with a new version. We also ensure that any thread that
uses the Map will see a consistent view of it.</p>
<p>For each thread that we manage, we maintain an <code>MVar</code>. A
per-thread <code>MVar</code> starts off empty, which indicates that the
thread is executing. When the thread finishes or is killed by an
uncaught exception, we put this information into the
<code>MVar</code>.</p>
<p>To create a thread and watch its status, we must perform a little bit
of book-keeping.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb10"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>forkManaged (<span class="dt">Mgr</span> mgr) body <span class="ot">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    modifyMVar mgr <span class="op">$</span> \m <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>      state <span class="ot">&lt;-</span> newEmptyMVar</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>      tid <span class="ot">&lt;-</span> forkIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        result <span class="ot">&lt;-</span> try body</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        putMVar state (<span class="fu">either</span> <span class="dt">Threw</span> (<span class="fu">const</span> <span class="dt">Finished</span>) result)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>      <span class="fu">return</span> (M.insert tid state m, tid)</span></code></pre></div>
</div>
<h2 data-number="4.1" id="safely-modifying-an-mvar"><span
class="header-section-number">4.1</span> Safely modifying an
<code>MVar</code></h2>
<p>The <code>modifyMVar</code> function that we used in
<code>forkManaged</code> above is very useful: it's a safe combination
of <code>takeMVar</code> and <code>putMVar</code>.</p>
<pre class="screen"><code>ghci&gt; :t modifyMVar
ved &quot;wake up!&quot;
modifyMVar :: MVar a -&gt; (a -&gt; IO (a, b)) -&gt; IO b
</code></pre>
<p>It takes the value from an <code>MVar</code>, and passes it to a
function. This function can both generate a new value and return a
result. If the function throws an exception, <code>modifyMVar</code>
puts the original value back into the <code>MVar</code>, otherwise it
puts the new value in. It returns the other element of the function as
its own result.</p>
<p>When we use <code>modifyMVar</code> instead of manually managing an
<code>MVar</code> with <code>takeMVar</code> and <code>putMVar</code>,
we avoid two common kinds of concurrency bug.</p>
<ul>
<li>Forgetting to put a value back into an <code>MVar</code>. This can
result in <em>deadlock</em>, in which some thread waits forever on an
<code>MVar</code> that will never have a value put into it.</li>
<li>Failure to account for the possibility that an exception might be
thrown, disrupting the flow of a piece of code. This can result in a
call to <code>putMVar</code> that <em>should</em> occur not actually
happening, again leading to deadlock.</li>
</ul>
<p>Because of these nice safety properties, it's wise to use
<code>modifyMVar</code> whenever possible.</p>
<h2 data-number="4.2"
id="safe-resource-management-a-good-idea-and-easy-besides"><span
class="header-section-number">4.2</span> Safe resource management: a
good idea, and easy besides</h2>
<p>We can the take the pattern that <code>modifyMVar</code> follows, and
apply it to many other resource management situations. Here are the
steps of the pattern.</p>
<ol>
<li>Acquire a resource. 2. Pass the resource to a function that</li>
</ol>
<p>will do something with it. 3. Always release the resource, even if
the function throws an exception. If that occurs, rethrow the exception
so it can be caught by application code.</p>
<p>Safety aside, this approach has another benefit: it can make our code
shorter and easier to follow. As we can see from looking at
<code>forkManaged</code> above, Haskell's lightweight syntax for
anonymous functions makes this style of coding visually unobtrusive.</p>
<p>Here's the definition of <code>modifyMVar</code>, so that you can see
a specific form of this pattern.</p>
<div class="captioned-content">
<div class="caption">
ModifyMVar.hs
</div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span> (<span class="dt">MVar</span>, putMVar, takeMVar)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span> (block, catch, throw, unblock)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (catch) <span class="co">-- use Control.Exception&#39;s version</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyMVar ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> (a,b)) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>modifyMVar m io <span class="ot">=</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>  block <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    a <span class="ot">&lt;-</span> takeMVar m</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    (b,r) <span class="ot">&lt;-</span> unblock (io a) <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>             putMVar m a <span class="op">&gt;&gt;</span> throw e</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    putMVar m b</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> r</span></code></pre></div>
</div>
<p>You should easily be able to adapt this to your particular needs,
whether you're working with network connections, database handles, or
data managed by a C library.</p>
<h2 data-number="4.3" id="finding-the-status-of-a-thread"><span
class="header-section-number">4.3</span> Finding the status of a
thread</h2>
<p>Our <code>getStatus</code> function tells us the current state of a
thread. If the thread is no longer managed (or was never managed in the
first place), it returns <code>Nothing</code>.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb13"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>getStatus (<span class="dt">Mgr</span> mgr) tid <span class="ot">=</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  modifyMVar mgr <span class="op">$</span> \m <span class="ot">-&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> M.lookup tid m <span class="kw">of</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (m, <span class="dt">Nothing</span>)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>      <span class="dt">Just</span> st <span class="ot">-&gt;</span> tryTakeMVar st <span class="op">&gt;&gt;=</span> \mst <span class="ot">-&gt;</span> <span class="kw">case</span> mst <span class="kw">of</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> (m, <span class="dt">Just</span> <span class="dt">Running</span>)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>                   <span class="dt">Just</span> sth <span class="ot">-&gt;</span> <span class="fu">return</span> (M.delete tid m, <span class="dt">Just</span> sth)</span></code></pre></div>
</div>
<p>If the thread is still running, it returns <code>Just Running</code>.
Otherwise, it indicates why the thread terminated, <em>and</em> stops
managing the thread.</p>
<p>If the <code>tryTakeMVar</code> function finds that the
<code>MVar</code> is empty, it returns <code>Nothing</code> immediately
instead of blocking.</p>
<pre class="screen"><code>ghci&gt; :t tryTakeMVar
tryTakeMVar :: MVar a -&gt; IO (Maybe a)
</code></pre>
<p>Otherwise, it extracts the value from the <code>MVar</code> as
usual.</p>
<p>The <code>waitFor</code> function behaves similarly, but instead of
returning immediately, it blocks until the given thread terminates
before returning.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb15"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>waitFor (<span class="dt">Mgr</span> mgr) tid <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>  maybeDone <span class="ot">&lt;-</span> modifyMVar mgr <span class="op">$</span> \m <span class="ot">-&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="kw">case</span> M.updateLookupWithKey (\_ _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>) tid m <span class="kw">of</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Nothing</span>, _) <span class="ot">-&gt;</span> (m, <span class="dt">Nothing</span>)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>      (done, m&#39;) <span class="ot">-&gt;</span> (m&#39;, done)</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>  <span class="kw">case</span> maybeDone <span class="kw">of</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">return</span> <span class="dt">Nothing</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Just</span> st <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="ot">`fmap`</span> takeMVar st</span></code></pre></div>
</div>
<p>It first extracts the <code>MVar</code> that holds the thread's
state, if it exists. The <code>Map</code> type's
<code>updateLookupWithKey</code> function is useful: it combines looking
up a key with modifying or removing the value.</p>
<pre class="screen"><code>ghci&gt; :m +Data.Map
ghci&gt; :t updateLookupWithKey
updateLookupWithKey :: (Ord k) =&gt;
                       (k -&gt; a -&gt; Maybe a) -&gt; k -&gt; Map k a -&gt; (Maybe a, Map k a)
</code></pre>
<p>In this case, we want to always remove the <code>MVar</code> holding
the thread's state if it is present, so that our thread manager will no
longer be managing the thread. If there was a value to extract, we take
the thread's exit status from the <code>MVar</code> and return it.</p>
<p>Our final useful function simply waits for all currently managed
threads to complete, and ignores their exit statuses.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb17"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>waitAll (<span class="dt">Mgr</span> mgr) <span class="ot">=</span> modifyMVar mgr elems <span class="op">&gt;&gt;=</span> <span class="fu">mapM_</span> takeMVar</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> elems m <span class="ot">=</span> <span class="fu">return</span> (M.empty, M.elems m)</span></code></pre></div>
</div>
<h2 data-number="4.4" id="writing-tighter-code"><span
class="header-section-number">4.4</span> Writing tighter code</h2>
<p>Our definition of <code>waitFor</code> above is a little
unsatisfactory, because we're performing more or less the same case
analysis in two places: inside the function called by
<code>modifyMVar</code>, and again on its return value.</p>
<p>Sure enough, we can apply a function that we came across earlier to
eliminate this duplication. The function in question is
<code>join</code>, from the <code>Control.Monad</code> module.</p>
<pre class="screen"><code>ghci&gt; :m +Control.Monad
ghci&gt; :t join
join :: (Monad m) =&gt; m (m a) -&gt; m a
</code></pre>
<p>The trick here is to see that we can get rid of the second
<code>case</code> expression by having the first one return the
<code>IO</code> action that we should perform once we return from
<code>modifyMVar</code>. We'll use <code>join</code> to execute the
action.</p>
<div class="captioned-content">
<div class="caption">
NiceFork.hs
</div>
<div class="sourceCode" id="cb19"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>waitFor2 (<span class="dt">Mgr</span> mgr) tid <span class="ot">=</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  join <span class="op">.</span> modifyMVar mgr <span class="op">$</span> \m <span class="ot">-&gt;</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> <span class="op">$</span> <span class="kw">case</span> M.updateLookupWithKey (\_ _ <span class="ot">-&gt;</span> <span class="dt">Nothing</span>) tid m <span class="kw">of</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Nothing</span>, _) <span class="ot">-&gt;</span> (m, <span class="fu">return</span> <span class="dt">Nothing</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>      (<span class="dt">Just</span> st, m&#39;) <span class="ot">-&gt;</span> (m&#39;, <span class="dt">Just</span> <span class="ot">`fmap`</span> takeMVar st)</span></code></pre></div>
</div>
<p>This is an interesting idea: we can create a monadic function or
action in pure code, then pass it around until we end up in a monad
where we can use it. This can be a nimble way to write code, once we
develop an eye for when it makes sense.</p>
<h1 data-number="5" id="communicating-over-channels"><span
class="header-section-number">5</span> Communicating over channels</h1>
<p>For one-shot communications between threads, an <code>MVar</code> is
perfectly good. Another type, <code>Chan</code>, provides a one-way
communication channel. Here is a simple example of its use.</p>
<div class="captioned-content">
<div class="caption">
Chan.hs
</div>
<div class="sourceCode" id="cb20"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent.Chan</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>chanExample <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>  ch <span class="ot">&lt;-</span> newChan</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>    writeChan ch <span class="st">&quot;hello world&quot;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    writeChan ch <span class="st">&quot;now i quit&quot;</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>  readChan ch <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>  readChan ch <span class="op">&gt;&gt;=</span> <span class="fu">print</span></span></code></pre></div>
</div>
<p>If a <code>Chan</code> is empty, <code>readChan</code> blocks until
there is a value to read. The <code>writeChan</code> function never
blocks: it writes a new value into a <code>Chan</code> immediately.</p>
<h1 data-number="6" id="useful-things-to-know-about"><span
class="header-section-number">6</span> Useful things to know about</h1>
<h2 data-number="6.1" id="mvar-and-chan-are-non-strict"><span
class="header-section-number">6.1</span> <code>MVar</code> and
<code>Chan</code> are non-strict</h2>
<p>Like most Haskell container types, both <code>MVar</code> and
<code>Chan</code> are non-strict: neither evaluates its contents. We
mention this not because it's a problem, but because it's a common blind
spot: people tend to assume that these types are strict, perhaps because
they're used in the <code>IO</code> monad.</p>
<p>As for other container types, the upshot of a mistaken guess about
the strictness of an <code>MVar</code> or <code>Chan</code> type is
often a space or performance leak. Here's a plausible scenario to
consider.</p>
<p>We fork off a thread to perform some expensive computation on another
core.</p>
<div class="captioned-content">
<div class="caption">
Expensive.hs
</div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>notQuiteRight <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>  mv <span class="ot">&lt;-</span> newEmptyMVar</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> expensiveComputation_stricter mv</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>  someOtherActivity</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a>  result <span class="ot">&lt;-</span> takeMVar mv</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">print</span> result</span></code></pre></div>
</div>
<p>It <em>seems</em> to do something, and puts its result back into the
<code>MVar</code>.</p>
<div class="captioned-content">
<div class="caption">
Expensive.hs
</div>
<div class="sourceCode" id="cb22"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>expensiveComputation mv <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> a <span class="ot">=</span> <span class="st">&quot;this is &quot;</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>      b <span class="ot">=</span> <span class="st">&quot;not really &quot;</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>      c <span class="ot">=</span> <span class="st">&quot;all that expensive&quot;</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>  putMVar mv (a <span class="op">++</span> b <span class="op">++</span> c)</span></code></pre></div>
</div>
<p>When we take the result from the <code>MVar</code> in the parent
thread and attempt to do something with it, our thread starts computing
furiously, because we never forced the computation to actually occur in
the other thread!</p>
<p>As usual, the solution is straightforward, once we know there's a
potential for a problem: we add strictness to the forked thread, to
ensure that the computation occurs there. This strictness is best added
in one place, to avoid the possibility that we might forget to add
it.</p>
<div class="captioned-content">
<div class="caption">
ModifyMVarStrict.hs
</div>
<div class="sourceCode" id="cb23"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">{-# LANGUAGE BangPatterns #-}</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span> (<span class="dt">MVar</span>, putMVar, takeMVar)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span> (block, catch, throw, unblock)</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (catch) <span class="co">-- use Control.Exception&#39;s version</span></span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="ot">modifyMVar_strict ::</span> <span class="dt">MVar</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> a) <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>modifyMVar_strict m io <span class="ot">=</span> block <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> takeMVar m</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>  <span class="op">!</span>b <span class="ot">&lt;-</span> unblock (io a) <span class="ot">`catch`</span> \e <span class="ot">-&gt;</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>        putMVar m a <span class="op">&gt;&gt;</span> throw e</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>  putMVar m b</span></code></pre></div>
</div>
<div class="TIP">
<p>It's always worth checking Hackage</p>
<p>In the Hackage package database, you will find a library,
<code>strict-concurrency</code>, that provides strict versions of the
<code>MVar</code> and <code>Chan</code> types.</p>
</div>
<p>The <code>!</code> pattern above is simple to use, but it is not
always sufficient to ensure that our data is evaluated. For a more
complete approach, see <a
href="24-concurrent-and-multicore-programming.org::*Separating algorithm from evaluation">the
section called "Separating algorithm from evaluation"</a> below.</p>
<h2 data-number="6.2" id="chan-is-unbounded"><span
class="header-section-number">6.2</span> Chan is unbounded</h2>
<p>Because <code>writeChan</code> always succeeds immediately, there is
a potential risk to using a <code>Chan</code>. If one thread writes to a
<code>Chan</code> more often than another thread reads from it, the
<code>Chan</code> will grow in an unchecked manner: unread messages will
pile up as the reader falls further and further behind.</p>
<h1 data-number="7" id="shared-state-concurrency-is-still-hard"><span
class="header-section-number">7</span> Shared-state concurrency is still
hard</h1>
<p>Although Haskell has different primitives for sharing data between
threads than other languages, it still suffers from the same fundamental
problem: writing correct concurrent programs is fiendishly difficult.
Indeed, several pitfalls of concurrent programming in other languages
apply equally to Haskell. Two of the better known problems are
<em>deadlock</em> and <em>starvation</em>.</p>
<h2 data-number="7.1" id="deadlock"><span
class="header-section-number">7.1</span> Deadlock</h2>
<p>In a <em>deadlock</em> situation, two or more threads get stuck
forever in a clash over access to shared resources. One classic way to
make a multithreaded program deadlock is to forget the order in which we
must acquire locks. This kind of bug is so common, it has a name:
<em>lock order inversion</em>. While Haskell doesn't provide locks, the
<code>MVar</code> type is prone to the order inversion problem. Here's a
simple example.</p>
<div class="captioned-content">
<div class="caption">
LockHierarchy.hs
</div>
<div class="sourceCode" id="cb24"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Concurrent</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>nestedModification outer inner <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>  modifyMVar_ outer <span class="op">$</span> \x <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    yield  <span class="co">-- force this thread to temporarily yield the CPU</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    modifyMVar_ inner <span class="op">$</span> \y <span class="ot">-&gt;</span> <span class="fu">return</span> (y <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (x <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="st">&quot;done&quot;</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  a <span class="ot">&lt;-</span> newMVar <span class="dv">1</span></span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  b <span class="ot">&lt;-</span> newMVar <span class="dv">2</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> nestedModification a b</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  forkIO <span class="op">$</span> nestedModification b a</span></code></pre></div>
</div>
<p>If we run this in <code>ghci</code>, it will usually—but not
always—print nothing, indicating that both threads have gotten
stuck.</p>
<p>The problem with the <code>nestedModification</code> function is easy
to spot. In the first thread, we take the <code>MVar</code>
<code>a</code>, then <code>b</code>. In the second, we take
<code>b</code>, then <code>a</code>. If the first thread succeeds in
taking <code>a</code> and the second takes <code>b</code>, both threads
will block: each tries to take an <code>MVar</code> that the other has
already emptied, so neither can make progress.</p>
<p>Across languages, the usual way to solve an order inversion problem
is to always follow a consistent order when acquiring resources. Since
this approach requires manual adherence to a coding convention, it is
easy to miss in practice.</p>
<p>To make matters more complicated, these kinds of inversion problems
can be difficult to spot in real code. The taking of <code>MVars</code>
is often spread across several functions in different files, making
visual inspection more tricky. Worse, these problems are often
<em>intermittent</em>, which makes them tough to even reproduce, never
mind isolate and fix.</p>
<h2 data-number="7.2" id="starvation"><span
class="header-section-number">7.2</span> Starvation</h2>
<p>Concurrent software is also prone to <em>starvation</em>, in which
one thread "hogs" a shared resource, preventing another from using it.
It's easy to imagine how this might occur: one thread calls
<code>modifyMVar</code> with a body that executes for 100 milliseconds,
while another calls <code>modifyMVar</code> on the same
<code>MVar</code> with a body that executes for 1 millisecond. The
second thread cannot make progress until the first puts a value back
into the <code>MVar</code>.</p>
<p>The non-strict nature of the <code>MVar</code> type can either
exacerbate or cause a starvation problem. If we put a thunk into an
<code>MVar</code> that will be expensive to evaluate, and take it out of
the <code>MVar</code> in a thread that otherwise looks like it
<em>ought</em> to be cheap, that thread could suddenly become
computationally expensive if it has to evaluate the thunk. This makes
the advice we gave in <a
href="24-concurrent-and-multicore-programming.org::*MVar and Chan are non-strict">the
section called "MVar and Chan are non-strict"</a></p>
<h2 data-number="7.3" id="is-there-any-hope"><span
class="header-section-number">7.3</span> Is there any hope?</h2>
<p>Fortunately, the APIs for concurrency that we have covered here are
by no means the end of the story. A more recent addition to Haskell,
Software Transactional Memory, is both easier and safer to work with. We
will discuss it in chapter <a
href="28-software-transactional-memory.org">Chapter 28, <em>Software
transactional memory</em></a>.</p>
<h1 data-number="8" id="exercises"><span
class="header-section-number">8</span> Exercises</h1>
<ol>
<li>The <code>Chan</code> type is implemented using
<code>MVar~s. Use ~MVar~s to
  develop a ~BoundedChan</code> library.</li>
<li>Your <code>newBoundedChan</code> function should accept an
<code>Int</code> parameter, limiting the number of unread items that can
be present in a <code>BoundedChan</code> at once.</li>
<li>If this limit is hit, a call to your <code>writeBoundedChan</code>
function must block until a reader uses <code>readBoundedChan</code> to
consume a value.</li>
<li>Although we've already mentioned the existence of the
strict-concurrency package in the Hackage repository, try developing
your own, as a wrapper around the built-in <code>MVar</code> type.
Following classic Haskell practice, make your library type safe, so that
users cannot accidentally mix uses of strict and non-strict
<code>MVars</code>.</li>
</ol>
<h1 data-number="9" id="using-multiple-cores-with-ghc"><span
class="header-section-number">9</span> Using multiple cores with
GHC</h1>
<p>By default, GHC generates programs that use just one core, even when
we write explicitly concurrent code. To use multiple cores, we must
explicitly choose to do so. We make this choice at <em>link time</em>,
when we are generating an executable program.</p>
<ul>
<li>The "non-threaded" runtime library runs all Haskell threads in a
single operating system thread. This runtime is highly efficient for
creating threads and passing data around in <code>MVars</code>.</li>
<li>The "threaded" runtime library uses multiple operating system
threads to run Haskell threads. It has somewhat more overhead for
creating threads and using <code>MVars</code>.</li>
</ul>
<p>If we pass the <code>-threaded</code> option to the compiler, it will
link our program against the threaded runtime library. We do not need to
use <code>-threaded</code> when we are compiling libraries or source
files, only when we are finally generating an executable.</p>
<p>Even when we select the threaded runtime for our program, it will
still default to using only one core when we run it. We must explicitly
tell the runtime how many cores to use.</p>
<h2 data-number="9.1" id="runtime-options"><span
class="header-section-number">9.1</span> Runtime options</h2>
<p>We can pass options to GHC's runtime system on the command line of
our program. Before handing control to our code, the runtime scans the
program's arguments for the special command line option
<code>+RTS</code>. It interprets everything that follows, until the
special option <code>-RTS</code>, as an option for the runtime system,
not our program. It hides all of these options from our code. When we
use the <code>System.Environment</code> module's <code>getArgs</code>
function to obtain our command line arguments, we will not find any
runtime options in the list.</p>
<p>The threaded runtime accepts an option <code>-N</code><a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.
This takes one argument, which specifies the number of cores that GHC's
runtime system should use. The option parser is picky: there must be no
spaces between <code>-N</code> and the number that follows it. The
option <code>-N4</code> is acceptable, but <code>-N 4</code> is not.</p>
<h2 data-number="9.2"
id="finding-the-number-of-available-cores-from-haskell"><span
class="header-section-number">9.2</span> Finding the number of available
cores from Haskell</h2>
<p>The module <code>GHC.Conc</code> exports a variable,
<code>numCapabilities</code>, that tells us how many cores the runtime
system has been given with the <code class="verbatim">-N</code> RTS
option.</p>
<div class="captioned-content">
<div class="caption">
NumCapabilities.hs
</div>
<div class="sourceCode" id="cb25"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Conc</span> (numCapabilities)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;command line arguments: &quot;</span> <span class="op">++</span> <span class="fu">show</span> args</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;number of cores: &quot;</span> <span class="op">++</span> <span class="fu">show</span> numCapabilities</span></code></pre></div>
</div>
<p>If we compile and run the above program, we can see that the options
to the runtime system are not visible to the program, but that it can
see how many cores it can run on.</p>
<pre class="screen"><code>$ ghc -c NumCapabilities.hs
$ ghc -threaded -o NumCapabilities NumCapabilities.o
$ ./NumCapabilities +RTS -N4 -RTS foo
command line arguments: [&quot;foo&quot;]
number of cores: 4
</code></pre>
<h2 data-number="9.3" id="choosing-the-right-runtime"><span
class="header-section-number">9.3</span> Choosing the right runtime</h2>
<p>The decision of which runtime to use is not completely clear cut.
While the threaded runtime can use multiple cores, it has a cost:
threads and sharing data between them are more expensive than with the
non-threaded runtime.</p>
<p>Furthermore, the garbage collector used by GHC as of version 6.8.3 is
single threaded: it pauses all other threads while it runs, and executes
on one core. This limits the performance improvement we can hope to see
from using multiple cores<a href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<p>In many real world concurrent programs, an individual thread will
spend most of its time waiting for a network request or response. In
these cases, if a single Haskell program serves tens of thousands of
concurrent clients, the lower overhead of the non-threaded runtime may
be helpful. For example, instead of having a single server program use
the threaded runtime on four cores, we might see better performance if
we design our server so that we can run four copies of it
simultaneously, and use the non-threaded runtime.</p>
<p>Our purpose here is not to dissuade you from using the threaded
runtime. It is not much more expensive than the non-threaded runtime:
threads remain amazingly cheap compared to the runtimes of most other
programming languages. We merely want to make it clear that switching to
the threaded runtime will not necessarily result in an automatic
win.</p>
<h1 data-number="10" id="parallel-programming-in-haskell"><span
class="header-section-number">10</span> Parallel programming in
Haskell</h1>
<p>We will now switch our focus to parallel programming. For many
computationally expensive problems, we could calculate a result more
quickly if we could divide up the solution, and evaluate it on many
cores at once. Computers with multiple cores are already ubiquitous, but
few programs can take advantage of the computing power of even a modern
laptop.</p>
<p>In large part, this is because parallel programming is traditionally
seen as very difficult. In a typical programming language, we would use
the same libraries and constructs that we apply to concurrent programs
to develop a parallel program. This forces us to contend with the
familiar problems of deadlocks, race conditions, starvation, and sheer
complexity.</p>
<p>While we could certainly use Haskell's concurrency features to
develop parallel code, there is a much simpler approach available to us.
We can take a normal Haskell function, apply a few simple
transformations to it, and have it evaluated in parallel.</p>
<h2 data-number="10.1" id="normal-form-and-head-normal-form"><span
class="header-section-number">10.1</span> Normal form and head normal
form</h2>
<p>The familiar <code>seq</code> function evaluates an expression to
what we call <em>head normal form</em> (abbreviated HNF). It stops once
it reaches the outermost constructor (the "head"). This is distinct from
<em>normal form</em> (NF), in which an expression is completely
evaluated.</p>
<p>You will also hear Haskell programmers refer to <em>weak</em> head
normal form (WHNF). For normal data, weak head normal form is the same
as head normal form. The difference only arises for functions, and is
too abstruse to concern us here.</p>
<h2 data-number="10.2" id="sequential-sorting"><span
class="header-section-number">10.2</span> Sequential sorting</h2>
<p>Here is a normal Haskell function that sorts a list using a
divide-and-conquer approach.</p>
<div class="captioned-content">
<div class="caption">
Sorting.hs
</div>
<div class="sourceCode" id="cb27"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sort</span><span class="ot"> ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">sort</span> (x<span class="op">:</span>xs) <span class="ot">=</span> lesser <span class="op">++</span> x<span class="op">:</span>greater</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> lesser  <span class="ot">=</span> <span class="fu">sort</span> [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&lt;</span>  x]</span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>          greater <span class="ot">=</span> <span class="fu">sort</span> [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&gt;=</span> x]</span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="fu">sort</span> _ <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>This function is inspired by the well-known Quicksort algorithm, and
it is a classic among Haskell programmers: it is often presented as a
one-liner early in a Haskell tutorial, to tease the reader with an
example of Haskell's expressiveness. Here, we've split the code over a
few lines, to make it easier to compare the serial and parallel
versions.</p>
<p>Here is a very brief description of how <code>sort</code>
operates.</p>
<ol>
<li>It chooses an element from the list. This is called the
<em>pivot</em>. Any element would do as the pivot; the first is merely
the easiest to pattern match on.</li>
<li>It creates a sublist of all elements less than the pivot, and
recursively sorts them.</li>
<li>It creates a sublist of all elements greater than or equal to the
pivot, and recursively sorts them.</li>
<li>It appends the two sorted sublists.</li>
</ol>
<h2 data-number="10.3"
id="transforming-our-code-into-parallel-code"><span
class="header-section-number">10.3</span> Transforming our code into
parallel code</h2>
<p>The parallel version of the function is only a little more
complicated than the initial version.</p>
<div class="captioned-content">
<div class="caption">
Sorting.hs
</div>
<div class="sourceCode" id="cb28"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Sorting</span> <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel</span> (par, pseq)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="ot">parSort ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>parSort (x<span class="op">:</span>xs)    <span class="ot">=</span> force greater <span class="ot">`par`</span> (force lesser <span class="ot">`pseq`</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>                                         (lesser <span class="op">++</span> x<span class="op">:</span>greater))</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> lesser  <span class="ot">=</span> parSort [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&lt;</span>  x]</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>          greater <span class="ot">=</span> parSort [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&gt;=</span> x]</span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a>parSort _         <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>We have barely perturbed the code: all we have added are three
functions, <code>par</code>, <code>pseq</code>, and
<code>force</code>.</p>
<p>The <code>par</code> function is provided by the
<code>Control.Parallel</code> module. It serves a similar purpose to
<code>seq</code>: it evaluates its left argument to weak head normal
form, and returns its right. As its name suggests, <code>par</code> can
evaluate its left argument in parallel with whatever other evaluations
are occurring.</p>
<p>As for <code>pseq</code>, it is similar to <code>seq</code>: it
evaluates the expression on the left to WHNF before returning the
expression on the right. The difference between the two is subtle, but
important for parallel programs: the compiler does not <em>promise</em>
to evaluate the left argument of <code>seq</code> if it can see that
evaluating the right argument first would improve performance. This
flexibility is fine for a program executing on one core, but it is not
strong enough for code running on multiple cores. In contrast, the
compiler <em>guarantees</em> that <code>pseq</code> will evaluate its
left argument before its right.</p>
<p>These changes to our code are remarkable for all the things we have
<em>not</em> needed to say.</p>
<ul>
<li>How many cores to use.</li>
<li>What threads do to communicate with each other.</li>
<li>How to divide up work among the available cores.</li>
<li>Which data are shared between threads, and which are private.</li>
<li>How to determine when all the participants are finished.</li>
</ul>
<h2 data-number="10.4" id="knowing-what-to-evaluate-in-parallel"><span
class="header-section-number">10.4</span> Knowing what to evaluate in
parallel</h2>
<p>The key to getting decent performance out of parallel Haskell code is
to find meaningful chunks of work to perform in parallel. Non-strict
evaluation can get in the way of this, which is why we use the
<code>force</code> function in our parallel sort. To best explain what
the <code>force</code> function is for, we will first look at a mistaken
example.</p>
<div class="captioned-content">
<div class="caption">
Sorting.hs
</div>
<div class="sourceCode" id="cb29"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>sillySort (x<span class="op">:</span>xs) <span class="ot">=</span> greater <span class="ot">`par`</span> (lesser <span class="ot">`pseq`</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>                                  (lesser <span class="op">++</span> x<span class="op">:</span>greater))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> lesser   <span class="ot">=</span> sillySort [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&lt;</span>  x]</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>          greater  <span class="ot">=</span> sillySort [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&gt;=</span> x]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>sillySort _        <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>Take a look at the small changes in each use of <code>par</code>.
Instead of <code>force lesser</code> and <code>force greater</code>,
here we evaluate <code>lesser</code> and <code>greater</code>.</p>
<p>Remember that evaluation to WHNF only computes enough of an
expression to see its <em>outermost</em> constructor. In this mistaken
example, we evaluate each sorted sublist to WHNF. Since the outermost
constructor in each case is just a single list constructor, we are in
fact only forcing the evaluation of the first element of each sorted
sublist! Every other element of each list remains unevaluated. In other
words, we do almost no useful work in parallel: our
<code>sillySort</code> is nearly completely sequential.</p>
<p>We avoid this with our <code>force</code> function by forcing the
entire spine of a list to be evaluated before we give back a
constructor.</p>
<div class="captioned-content">
<div class="caption">
Sorting.hs
</div>
<div class="sourceCode" id="cb30"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ot">force ::</span> [a] <span class="ot">-&gt;</span> ()</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>force xs <span class="ot">=</span> go xs <span class="ot">`pseq`</span> ()</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> go (_<span class="op">:</span>xs) <span class="ot">=</span> go xs</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>          go [] <span class="ot">=</span> <span class="dv">1</span></span></code></pre></div>
</div>
<p>Notice that we don't care what's in the list; we walk down its spine
to the end, then use <code>pseq</code> once. There is clearly no magic
involved here: we are just using our usual understanding of Haskell's
evaluation model. And because we will be using <code>force</code> on the
left hand side of <code>par</code> or <code>pseq</code>, we don't need
to return a meaningful value.</p>
<p>Of course, in many cases we will need to force the evaluation of
individual elements of the list, too. Below, we will discuss a type
class-based solution to this problem.</p>
<h2 data-number="10.5" id="what-promises-does-par-make"><span
class="header-section-number">10.5</span> What promises does par
make?</h2>
<p>The <code>par</code> function does not actually promise to evaluate
an expression in parallel with another. Instead, it undertakes to do so
if it "makes sense". This wishy-washy non-promise is actually more
useful than a guarantee to always evaluate an expression in parallel. It
gives the runtime system the freedom to act intelligently when it
encounters a use of <code>par</code>.</p>
<p>For instance, the runtime could decide that an expression is too
cheap to be worth evaluating in parallel. Or it might notice that all
cores are currently busy, so that "sparking" a new parallel evaluation
will lead to there being more runnable threads than there are cores
available to execute them.</p>
<p>This lax specification in turn affects how we write parallel code.
Since <code>par</code> may be somewhat intelligent at runtime, we can
use it almost wherever we like, on the assumption that performance will
not be bogged down by threads contending for busy cores.</p>
<h2 data-number="10.6"
id="running-our-code-and-measuring-performance"><span
class="header-section-number">10.6</span> Running our code, and
measuring performance</h2>
<p>To try our code out, let's save <code>sort</code>,
<code>parSort</code>, and <code>parSort2</code> to a module named
<code>Sorting.hs</code>. We create a small driver program that we can
use to time the performance of one of those sorting function.</p>
<div class="captioned-content">
<div class="caption">
SortMain.hs
</div>
<div class="sourceCode" id="cb31"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Time.Clock</span> (diffUTCTime, getCurrentTime)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Random</span> (<span class="dt">StdGen</span>, getStdGen, randoms)</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Sorting</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="co">-- testFunction = sort</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="co">-- testFunction = seqSort</span></span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>testFunction <span class="ot">=</span> parSort</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a><span class="co">-- testFunction = parSort2 2</span></span>
<span id="cb31-13"><a href="#cb31-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-14"><a href="#cb31-14" aria-hidden="true" tabindex="-1"></a><span class="ot">randomInts ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]</span>
<span id="cb31-15"><a href="#cb31-15" aria-hidden="true" tabindex="-1"></a>randomInts k g <span class="ot">=</span> <span class="kw">let</span> result <span class="ot">=</span> <span class="fu">take</span> k (randoms g)</span>
<span id="cb31-16"><a href="#cb31-16" aria-hidden="true" tabindex="-1"></a>                 <span class="kw">in</span> force result <span class="ot">`seq`</span> result</span>
<span id="cb31-17"><a href="#cb31-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-18"><a href="#cb31-18" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb31-19"><a href="#cb31-19" aria-hidden="true" tabindex="-1"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb31-20"><a href="#cb31-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> count <span class="op">|</span> <span class="fu">null</span> args <span class="ot">=</span> <span class="dv">500000</span></span>
<span id="cb31-21"><a href="#cb31-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">read</span> (<span class="fu">head</span> args)</span>
<span id="cb31-22"><a href="#cb31-22" aria-hidden="true" tabindex="-1"></a>  input <span class="ot">&lt;-</span> randomInts count <span class="ot">`fmap`</span> getStdGen</span>
<span id="cb31-23"><a href="#cb31-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;We have &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> input) <span class="op">++</span> <span class="st">&quot; elements to sort.&quot;</span></span>
<span id="cb31-24"><a href="#cb31-24" aria-hidden="true" tabindex="-1"></a>  start <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb31-25"><a href="#cb31-25" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> sorted <span class="ot">=</span> testFunction input</span>
<span id="cb31-26"><a href="#cb31-26" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="st">&quot;Sorted all &quot;</span> <span class="op">++</span> <span class="fu">show</span> (<span class="fu">length</span> sorted) <span class="op">++</span> <span class="st">&quot; elements.&quot;</span></span>
<span id="cb31-27"><a href="#cb31-27" aria-hidden="true" tabindex="-1"></a>  end <span class="ot">&lt;-</span> getCurrentTime</span>
<span id="cb31-28"><a href="#cb31-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">putStrLn</span> <span class="op">$</span> <span class="fu">show</span> (end <span class="ot">`diffUTCTime`</span> start) <span class="op">++</span> <span class="st">&quot; elapsed.&quot;</span></span></code></pre></div>
</div>
<p>For simplicity, we choose the sorting function to benchmark at
compilation time, via the <code>testFunction</code> variable.</p>
<p>Our program accepts a single optional command line argument, the
length of the random list to generate.</p>
<p>Non-strict evaluation can turn performance measurement and analysis
into something of a minefield. Here are some potential problems that we
specifically work to avoid in our driver program.</p>
<ul>
<li><p><em>Measuring several things, when we think we are looking at
just one.</em> Haskell's default pseudorandom number generator (PRNG) is
slow, and the <code>randoms</code> function generates random numbers on
demand.</p>
<p>Before we record our starting time, we force every element of the
input list to be evaluated, and we print the length of the list: this
ensures that we create all of the random numbers that we will need in
advance.</p>
<p>If we were to omit this step, we would interleave the generation of
random numbers with attempts to work with them in parallel. We would
thus be measuring both the cost of sorting the numbers and, less
obviously, the cost of generating them.</p></li>
<li><p><em>Invisible data dependencies.</em> When we generate the list
of random numbers, simply printing the length of the list would not
perform enough evaluation. This would evaluate the <em>spine</em> of the
list, but not its elements. The actual random numbers would not be
evaluated until the sort compares them.</p>
<p>This can have serious consequences for performance. The value of a
random number depends on the value of the preceding random number in the
list, but we have scattered the list elements randomly among our
processor cores. If we did not evaluate the list elements prior to
sorting, we would suffer a terrible "ping pong" effect: not only would
evaluation bounce from one core to another, performance would
suffer.</p>
<p>Try snipping out the application of <code>force</code> from the body
of <code>main</code> above: you should find that the parallel code can
easily end up three times <em>slower</em> than the non-parallel
code.</p></li>
<li><p><em>Benchmarking a thunk, when we believe that the code is
performing meaningful work.</em> To force the sort to take place, we
print the length of the result list before we record the ending time.
Without <code>putStrLn</code> demanding the length of the list in order
to print it, the sort would not occur at all.</p></li>
</ul>
<p>When we build the program, we enable optimization and GHC's threaded
runtime.</p>
<pre class="screen"><code>$ ghc -threaded -O2 --make SortMain
[1 of 2] Compiling Sorting          ( Sorting.hs, Sorting.o )
[2 of 2] Compiling Main             ( SortMain.hs, SortMain.o )
Linking SortMain ...
</code></pre>
<p>When we run the program, we must tell GHC's runtime how many cores to
use. Initially, we try the original <code>sort</code>, to establish a
performance baseline.</p>
<pre class="screen"><code>$ ./Sorting +RTS -N1 -RTS 700000
We have 700000 elements to sort.
Sorted all 700000 elements.
3.178941s elapsed.
</code></pre>
<p>Enabling a second core ought to have no effect on performance.</p>
<pre class="screen"><code>$ ./Sorting +RTS -N2 -RTS 700000
We have 700000 elements to sort.
Sorted all 700000 elements.
3.259869s elapsed.
</code></pre>
<p>If we recompile and test the performance of <code>parSort</code>, the
results are less than stellar.</p>
<pre class="screen"><code>$ ./Sorting +RTS -N1 -RTS 700000
We have 700000 elements to sort.
Sorted all 700000 elements.
3.915818s elapsed.
$ ./Sorting +RTS -N2 -RTS 700000
We have 700000 elements to sort.
Sorted all 700000 elements.
4.029781s elapsed.
</code></pre>
<p>We have gained nothing in performance. It seems that this could be
due to one of two factors: either <code>par</code> is intrinsically
expensive, or we are using it too much. To help us to distinguish
between the two possibilities, here is a sort is identical to
<code>parSort</code>, but it uses <code>pseq</code> instead of
<code>par</code>.</p>
<div class="captioned-content">
<div class="caption">
Sorting.hs
</div>
<div class="sourceCode" id="cb36"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ot">seqSort ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>seqSort (x<span class="op">:</span>xs) <span class="ot">=</span> lesser <span class="ot">`pseq`</span> (greater <span class="ot">`pseq`</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>                                (lesser <span class="op">++</span> x<span class="op">:</span>greater))</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">where</span> lesser  <span class="ot">=</span> seqSort [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&lt;</span>  x]</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a>          greater <span class="ot">=</span> seqSort [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&gt;=</span> x]</span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a>seqSort _ <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>We also drop the use of <code>force</code>, so compared to our
original <code>sort</code>, we should only be measuring the cost of
using <code>pseq</code>. What effect does <code>pseq</code> alone have
on performance?</p>
<pre class="screen"><code>$ ./Sorting +RTS -N1 -RTS 700000
We have 700000 elements to sort.
Sorted all 700000 elements.
3.848295s elapsed.
</code></pre>
<p>This suggests that <code>par</code> and <code>pseq</code> have
similar costs. What can we do to improve performance?</p>
<h2 data-number="10.7" id="tuning-for-performance"><span
class="header-section-number">10.7</span> Tuning for performance</h2>
<p>In our <code>parSort</code>, we perform twice as many applications of
<code>par</code> as there are elements to sort. While <code>par</code>
is <em>cheap</em>, as we have seen, it is not <em>free</em>. When we
recursively apply <code>parSort</code>, we eventually apply
<code>par</code> to individual list elements. At this fine granularity,
the cost of using <code>par</code> outweighs any possible usefulness. To
reduce this effect, we switch to our non-parallel <code>sort</code>
after passing some threshold.</p>
<div class="captioned-content">
<div class="caption">
Sorting.hs
</div>
<div class="sourceCode" id="cb38"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parSort2 ::</span> (<span class="dt">Ord</span> a) <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>parSort2 d list<span class="op">@</span>(x<span class="op">:</span>xs)</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> d <span class="op">&lt;=</span> <span class="dv">0</span>     <span class="ot">=</span> <span class="fu">sort</span> list</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> force greater <span class="ot">`par`</span> (force lesser <span class="ot">`pseq`</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>                                     (lesser <span class="op">++</span> x<span class="op">:</span>greater))</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>      <span class="kw">where</span> lesser      <span class="ot">=</span> parSort2 d&#39; [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&lt;</span>  x]</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>            greater     <span class="ot">=</span> parSort2 d&#39; [y <span class="op">|</span> y <span class="ot">&lt;-</span> xs, y <span class="op">&gt;=</span> x]</span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>            d&#39; <span class="ot">=</span> d <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>parSort2 _ _            <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>Here, we stop recursing and sparking new parallel evaluations at a
controllable depth. If we knew the size of the data we were dealing
with, we could stop subdividing and switch to the non-parallel code once
we reached a sufficiently small amount of remaining work.</p>
<pre class="screen"><code>$ ./Sorting +RTS -N2 -RTS 700000
We have 700000 elements to sort.
Sorted all 700000 elements.
2.947872s elapsed.
</code></pre>
<p>On a dual core system, this gives us roughly a 25% speedup. This is
not a huge number, but consider the number of changes we had to make in
return for this performance improvement: just a few annotations.</p>
<p>This sorting function is particularly resistant to good parallel
performance. The amount of memory allocation it performs forces the
garbage collector to run frequently. We can see the effect by running
our program with the <code>-sstderr</code> RTS option, which prints
garbage collection statistics to the screen. This indicates that our
program spends roughly 40% of its time collecting garbage. Since the
garbage collector in GHC 6.8 stops all threads and runs on a single
core, it acts as a bottleneck.</p>
<p>You can expect more impressive performance improvements from less
allocation-heavy code when you use <code>par</code> annotations. We have
seen some simple numerical benchmarks run 1.8 times faster on a dual
core system than with a single core. As we write this book, a parallel
garbage collector is under development for GHC, which should help
considerably with the performance of allocation-heavy code on multicore
systems.</p>
<div class="WARNING">
<p>Beware a GC bug in GHC 6.8.2</p>
<p>The garbage collector in release 6.8.2 of GHC has a bug that can
cause programs using <code>par</code> to crash. If you want to use
<code>par</code> and you are using 6.8.2, we suggest upgrading to at
least 6.8.3.</p>
</div>
<h2 data-number="10.8" id="exercises-1"><span
class="header-section-number">10.8</span> Exercises</h2>
<ol>
<li>It can be difficult to determine when to switch from
<code>parSort2</code> to sort. An alternative approach to the one we
outline above would be to decide based on the length of a sublist.
Rewrite <code>parList2</code> so that it switches to sort if the list
contains more than some number of elements.</li>
<li>Measure the performance of the length-based approach, and compare
with the depth approach. Which gives better performance results?</li>
</ol>
<h1 data-number="11" id="parallel-strategies-and-mapreduce"><span
class="header-section-number">11</span> Parallel strategies and
<code>MapReduce</code></h1>
<p>Within the programming community, one of the most famous software
systems to credit functional programming for inspiration is Google's
MapReduce infrastructure for parallel processing of bulk data.</p>
<p>We can easily construct a greatly simplified, but still useful,
Haskell equivalent. To focus our attention, we will look at the
processing of web server log files, which tend to be both huge and
plentiful<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>.</p>
<p>As an example, here is a log entry for a page visit recorded by the
Apache web server. The entry originally filled one line; we have split
it across several lines to fit.</p>
<pre class="example"><code>201.49.94.87 - - [08/Jun/2008:07:04:20 -0500] &quot;GET / HTTP/1.1&quot;
200 2097 &quot;http://en.wikipedia.org/wiki/Mercurial_(software)&quot;
&quot;Mozilla/5.0 (Windows; U; Windows XP 5.1; en-GB; rv:1.8.1.12)
Gecko/20080201 Firefox/2.0.0.12&quot; 0 hgbook.red-bean.com
</code></pre>
<p>While we could create a straightforward implementation without much
effort, we will resist the temptation to dive in. If we think about
solving a <em>class</em> of problems instead of a single one, we may end
up with more widely applicable code.</p>
<p>When we develop a parallel program, we are always faced with a few
"bad penny" problems, which turn up no matter what the underlying
programming language is.</p>
<ul>
<li>Our algorithm quickly becomes obscured by the details of
partitioning and communication. This makes it difficult to understand
code, which in turn makes modifying it risky.</li>
<li>Choosing a "grain size"—the smallest unit of work parceled out to a
core—can be difficult. If the grain size is too small, cores spend so
much of their time on book-keeping that a parallel program can easily
become slower than a serial counterpart. If the grain size is too large,
some cores may lie idle due to poor load balancing.</li>
</ul>
<h2 data-number="11.1" id="separating-algorithm-from-evaluation"><span
class="header-section-number">11.1</span> Separating algorithm from
evaluation</h2>
<p>In parallel Haskell code, the clutter that would arise from
communication code in a traditional language is replaced with the
clutter of <code>par</code> and <code>pseq</code> annotations. As an
example, this function operates similarly to <code>map</code>, but
evaluates each element to weak head normal form (WHNF) in parallel as it
goes.</p>
<div class="captioned-content">
<div class="caption">
ParMap.hs
</div>
<div class="sourceCode" id="cb41"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel</span> (par)</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a><span class="ot">parallelMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>parallelMap f (x<span class="op">:</span>xs) <span class="ot">=</span> <span class="kw">let</span> r <span class="ot">=</span> f x</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>                       <span class="kw">in</span> r <span class="ot">`par`</span> r <span class="op">:</span> parallelMap f xs</span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>parallelMap _ _      <span class="ot">=</span> []</span></code></pre></div>
</div>
<p>The type <code>b</code> might be a list, or some other type for which
evaluation to WHNF doesn't do a useful amount of work. We'd prefer not
to have to write a special <code>parallelMap</code> for lists, and for
every other type that needs special handling.</p>
<p>To address this problem, we will begin by considering a simpler
problem: how to force a value to be evaluated. Here is a function that
forces every element of a list to be evaluated to WHNF.</p>
<div class="captioned-content">
<div class="caption">
ParMap.hs
</div>
<div class="sourceCode" id="cb42"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forceList ::</span> [a] <span class="ot">-&gt;</span> ()</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>forceList (x<span class="op">:</span>xs) <span class="ot">=</span> x <span class="ot">`pseq`</span> forceList xs</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>forceList _      <span class="ot">=</span> ()</span></code></pre></div>
</div>
<p>Our function performs no computation on the list. (In fact, from
examining its type signature, we can tell that it <em>cannot</em>
perform any computation, since it knows nothing about the elements of
the list.) Its only purpose is to ensure that the spine of the list is
evaluated to head normal form. The only place that it makes any sense to
apply this function is in the first argument of <code>seq</code> or
<code>par</code>, for example as follows.</p>
<div class="captioned-content">
<div class="caption">
ParMap.hs
</div>
<div class="sourceCode" id="cb43"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a><span class="ot">stricterMap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>stricterMap f xs <span class="ot">=</span> forceList xs <span class="ot">`seq`</span> <span class="fu">map</span> f xs</span></code></pre></div>
</div>
<p>This still leaves us with the elements of the list evaluated only to
WHNF. We address this by adding a function as parameter that can force
an element to be evaluated more deeply.</p>
<div class="captioned-content">
<div class="caption">
ParMap.hs
</div>
<div class="sourceCode" id="cb44"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="ot">forceListAndElts ::</span> (a <span class="ot">-&gt;</span> ()) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> ()</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>forceListAndElts forceElt (x<span class="op">:</span>xs) <span class="ot">=</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    forceElt x <span class="ot">`seq`</span> forceListAndElts forceElt xs</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>forceListAndElts _        _      <span class="ot">=</span> ()</span></code></pre></div>
</div>
<p>The <code>Control.Parallel.Strategies</code> module generalizes this
idea into something we can use as a library. It introduces the idea of
an <em>evaluation strategy</em>.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb45"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Done</span> <span class="ot">=</span> ()</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> <span class="dt">Strategy</span> a <span class="ot">=</span> a <span class="ot">-&gt;</span> <span class="dt">Done</span></span></code></pre></div>
</div>
<p>An evaluation strategy performs no computation; it simply ensures
that a value is evaluated to some extent. The simplest strategy is named
<code>r0</code>, and does nothing at all.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb46"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="ot">r0 ::</span> <span class="dt">Strategy</span> a</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>r0 _ <span class="ot">=</span> ()</span></code></pre></div>
</div>
<p>Next is <code>whnf</code>, which evaluates a value to weak head
normal form.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb47"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="ot">rwhnf ::</span> <span class="dt">Strategy</span> a</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>rwhnf x <span class="ot">=</span> x <span class="ot">`seq`</span> ()</span></code></pre></div>
</div>
<p>To evaluate a value to normal form, the module provides a type class
with a method named <code>rnf</code>.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb48"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">NFData</span> a <span class="kw">where</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="ot">  rnf ::</span> <span class="dt">Strategy</span> a</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a>  rnf <span class="ot">=</span> rwhnf</span></code></pre></div>
</div>
<div class="TIP">
<p>Remembering those names</p>
<p>If the names of these functions and types are not sticking in your
head, look at them as acronyms. The name <code>rwhnf</code> expands to
"reduce to weak head normal form"; NFData becomes "normal form data";
and so on.</p>
</div>
<p>For the basic types, such as <code>Int</code>, weak head normal form
and normal form are the same thing, which is why the <code>NFData</code>
type class uses <code>rwhnf</code> as the default implementation of
<code>rnf</code>. For many common types, the
<code>Control.Parallel.Strategies</code> module provides instances of
<code>NFData</code>.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb49"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">Char</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> <span class="dt">Int</span></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-4"><a href="#cb49-4" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">NFData</span> a <span class="ot">=&gt;</span> <span class="dt">NFData</span> (<span class="dt">Maybe</span> a) <span class="kw">where</span></span>
<span id="cb49-5"><a href="#cb49-5" aria-hidden="true" tabindex="-1"></a>    rnf <span class="dt">Nothing</span>  <span class="ot">=</span> ()</span>
<span id="cb49-6"><a href="#cb49-6" aria-hidden="true" tabindex="-1"></a>    rnf (<span class="dt">Just</span> x) <span class="ot">=</span> rnf x</span>
<span id="cb49-7"><a href="#cb49-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-8"><a href="#cb49-8" aria-hidden="true" tabindex="-1"></a><span class="co">{- ... and so on ... -}</span></span></code></pre></div>
</div>
<p>From these examples, it should be clear how you might write an
<code>NFData</code> instance for a type of your own. Your implementation
of <code>rnf</code> must handle every constructor, and apply
<code>rnf</code> to every field of a constructor.</p>
<h2 data-number="11.2" id="separating-algorithm-from-strategy"><span
class="header-section-number">11.2</span> Separating algorithm from
strategy</h2>
<p>From these strategy building blocks, we can construct more elaborate
strategies. Many are already provided by
<code>Control.Parallel.Strategies</code>. For instance,
<code>parList</code> applies an evaluation strategy in parallel to every
element of a list.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb50"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parList ::</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> [a]</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>parList strat []     <span class="ot">=</span> ()</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a>parList strat (x<span class="op">:</span>xs) <span class="ot">=</span> strat x <span class="ot">`par`</span> (parList strat xs)</span></code></pre></div>
</div>
<p>The module uses this to define a parallel <code>map</code>
function.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb51"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a><span class="ot">parMap ::</span> <span class="dt">Strategy</span> b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [b]</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>parMap strat f xs <span class="ot">=</span> <span class="fu">map</span> f xs <span class="ot">`using`</span> parList strat</span></code></pre></div>
</div>
<p>This is where the code becomes interesting. On the left of
<code>using</code>, we have a normal application of <code>map</code>. On
the right, we have an evaluation strategy. The <code>using</code>
combinator tells us how to apply a strategy to a value, allowing us to
keep the code separate from how we plan to evaluate it.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb52"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="ot">using ::</span> a <span class="ot">-&gt;</span> <span class="dt">Strategy</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>using x s <span class="ot">=</span> s x <span class="ot">`seq`</span> x</span></code></pre></div>
</div>
<p>The <code>Control.Parallel.Strategies</code> module provides many
other functions that provide fine control over evaluation. For instance,
<code>parZipWith</code> that applies <code>zipWith</code> in parallel,
using an evaluation strategy.</p>
<div class="captioned-content">
<div class="caption">
Strat.hs
</div>
<div class="sourceCode" id="cb53"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="ot">vectorSum&#39; ::</span> (<span class="dt">NFData</span> a, <span class="dt">Num</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>vectorSum&#39; <span class="ot">=</span> parZipWith rnf (<span class="op">+</span>)</span></code></pre></div>
</div>
<h2 data-number="11.3" id="writing-a-simple-mapreduce-definition"><span
class="header-section-number">11.3</span> Writing a simple MapReduce
definition</h2>
<p>We can quickly suggest a type for a <code>mapReduce</code> function
by considering what it must do. We need a <em>map</em> component, to
which we will give the usual type <code>a -&gt; b</code>. And we need a
<em>reduce</em>; this term is a synonym for <em>fold</em>. Rather than
commit ourselves to using a specific kind of fold, we'll use a more
general type, <code>[b] -&gt; c</code>. This type lets us use a left or
right fold, so we can choose the one that suits our data and processing
needs.</p>
<p>If we plug these types together, the complete type looks like
this.</p>
<div class="captioned-content">
<div class="caption">
MapReduce.hs
</div>
<div class="sourceCode" id="cb54"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>simpleMapReduce</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b)      <span class="co">-- map function</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> ([b] <span class="ot">-&gt;</span> c)    <span class="co">-- reduce function</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> [a]           <span class="co">-- list to map over</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> c</span></code></pre></div>
</div>
<p>The code that goes with the type is extremely simple.</p>
<div class="captioned-content">
<div class="caption">
MapReduce.hs
</div>
<div class="sourceCode" id="cb55"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>simpleMapReduce mapFunc reduceFunc <span class="ot">=</span> reduceFunc <span class="op">.</span> <span class="fu">map</span> mapFunc</span></code></pre></div>
</div>
<h2 data-number="11.4" id="mapreduce-and-strategies"><span
class="header-section-number">11.4</span> MapReduce and strategies</h2>
<p>Our definition of <code>simpleMapReduce</code> is too simple to
really be interesting. To make it useful, we want to be able to specify
that some of the work should occur in parallel. We'll achieve this using
strategies, passing in a strategy for the map phase and one for the
reduction phase.</p>
<div class="captioned-content">
<div class="caption">
MapReduce.hs
</div>
<div class="sourceCode" id="cb56"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>mapReduce</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    ::</span> <span class="dt">Strategy</span> b    <span class="co">-- evaluation strategy for mapping</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)      <span class="co">-- map function</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> <span class="dt">Strategy</span> c    <span class="co">-- evaluation strategy for reduction</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> ([b] <span class="ot">-&gt;</span> c)    <span class="co">-- reduce function</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> [a]           <span class="co">-- list to map over</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>    <span class="ot">-&gt;</span> c</span></code></pre></div>
</div>
<p>Both the type and the body of the function must grow a little in size
to accommodate the strategy parameters.</p>
<div class="captioned-content">
<div class="caption">
MapReduce.hs
</div>
<div class="sourceCode" id="cb57"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>mapReduce mapStrat mapFunc reduceStrat reduceFunc input <span class="ot">=</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>    mapResult <span class="ot">`pseq`</span> reduceResult</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> mapResult    <span class="ot">=</span> parMap mapStrat mapFunc input</span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>        reduceResult <span class="ot">=</span> reduceFunc mapResult <span class="ot">`using`</span> reduceStrat</span></code></pre></div>
</div>
<h2 data-number="11.5" id="sizing-work-appropriately"><span
class="header-section-number">11.5</span> Sizing work appropriately</h2>
<p>To achieve decent performance, we must ensure that the work that we
do per application of <code>par</code> substantially outweighs its
book-keeping costs. If we are processing a huge file, splitting it on
line boundaries gives us far too little work compared to overhead.</p>
<p>We will develop a way to process a file in larger chunks in a later
section. What should those chunks consist of? Because a web server log
file ought to contain only ASCII text, we will see excellent performance
with a lazy <code>ByteString</code>: this type is highly efficient, and
consumes little memory when we stream it from a file.</p>
<div class="captioned-content">
<div class="caption">
LineChunks.hs
</div>
<div class="sourceCode" id="cb58"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">LineChunks</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>    (</span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a>      chunkedReadWith</span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a>    ) <span class="kw">where</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Exception</span> (bracket, finally)</span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM, liftM)</span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel.Strategies</span> (<span class="dt">NFData</span>, rnf)</span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Int</span> (<span class="dt">Int64</span>)</span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">LB</span></span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">GHC.Conc</span> (numCapabilities)</span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.IO</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ChunkSpec</span> <span class="ot">=</span> <span class="dt">CS</span> {</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a><span class="ot">      chunkOffset ::</span> <span class="op">!</span><span class="dt">Int64</span></span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>    ,<span class="ot"> chunkLength ::</span> <span class="op">!</span><span class="dt">Int64</span></span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>    } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a><span class="ot">withChunks ::</span> (<span class="dt">NFData</span> a) <span class="ot">=&gt;</span></span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>              (<span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">ChunkSpec</span>])</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> ([<span class="dt">LB.ByteString</span>] <span class="ot">-&gt;</span> a)</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">FilePath</span></span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>           <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>withChunks chunkFunc process path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>  (chunks, handles) <span class="ot">&lt;-</span> chunkedRead chunkFunc path</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> r <span class="ot">=</span> process chunks</span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>  (rnf r <span class="ot">`seq`</span> <span class="fu">return</span> r) <span class="ot">`finally`</span> <span class="fu">mapM_</span> hClose handles</span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a><span class="ot">chunkedReadWith ::</span> (<span class="dt">NFData</span> a) <span class="ot">=&gt;</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>                   ([<span class="dt">LB.ByteString</span>] <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>chunkedReadWith func path <span class="ot">=</span></span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>    withChunks (lineChunks (numCapabilities <span class="op">*</span> <span class="dv">4</span>)) func path</span></code></pre></div>
</div>
<p>We consume each chunk in parallel, taking careful advantage of lazy
I/O to ensure that we can stream these chunks safely.</p>
<ol>
<li><p>Mitigating the risks of lazy I/O</p>
<p>Lazy I/O poses a few well known hazards that we would like to
avoid.</p>
<ul>
<li>We may invisibly keep a file handle open for longer than necessary,
by not forcing the computation that pulls data from it to be evaluated.
Since an operating system will typically place a small, fixed limit on
the number of files we can have open at once, if we do not address this
risk, we can accidentally starve some other part of our program of file
handles.</li>
<li>If we do not explicitly close a file handle, the garbage collector
will automatically close it for us. It may take a long time to notice
that it should close the file handle. This poses the same starvation
risk as above.</li>
<li>We can avoid starvation by explicitly closing a file handle. If we
do so too early, though, we can cause a lazy computation to fail if it
expects to be able to pull more data from a closed file handle.</li>
</ul>
<p>On top of these well-known risks, we cannot use a single file handle
to supply data to multiple threads. A file handle has a single "seek
pointer" that tracks the position from which it should be reading, but
when we want to read multiple chunks, each needs to consume data from a
different position in the file.</p>
<p>With these ideas in mind, let's fill out the lazy I/O picture.</p>
<div class="captioned-content">
<div class="caption">
LineChunks.hs
</div>
<div class="sourceCode" id="cb59"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a><span class="ot">chunkedRead ::</span> (<span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">ChunkSpec</span>])</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">FilePath</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>            <span class="ot">-&gt;</span> <span class="dt">IO</span> ([<span class="dt">LB.ByteString</span>], [<span class="dt">Handle</span>])</span>
<span id="cb59-4"><a href="#cb59-4" aria-hidden="true" tabindex="-1"></a>chunkedRead chunkFunc path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb59-5"><a href="#cb59-5" aria-hidden="true" tabindex="-1"></a>  chunks <span class="ot">&lt;-</span> chunkFunc path</span>
<span id="cb59-6"><a href="#cb59-6" aria-hidden="true" tabindex="-1"></a>  liftM <span class="fu">unzip</span> <span class="op">.</span> forM chunks <span class="op">$</span> \spec <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb59-7"><a href="#cb59-7" aria-hidden="true" tabindex="-1"></a>    h <span class="ot">&lt;-</span> openFile path <span class="dt">ReadMode</span></span>
<span id="cb59-8"><a href="#cb59-8" aria-hidden="true" tabindex="-1"></a>    hSeek h <span class="dt">AbsoluteSeek</span> (<span class="fu">fromIntegral</span> (chunkOffset spec))</span>
<span id="cb59-9"><a href="#cb59-9" aria-hidden="true" tabindex="-1"></a>    chunk <span class="ot">&lt;-</span> LB.take (chunkLength spec) <span class="ot">`liftM`</span> LB.hGetContents h</span>
<span id="cb59-10"><a href="#cb59-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">return</span> (chunk, h)</span></code></pre></div>
</div>
<p>We avoid the starvation problem by explicitly closing file handles.
We allow multiple threads to read different chunks at once by supplying
each one with a distinct file handle, all reading the same file.</p>
<p>The final problem that we try to mitigate is that of a lazy
computation having a file handle closed behind its back. We use
<code>rnf</code> to force all of our processing to complete before we
return from <code>withChunks</code>. We can then close our file handles
explicitly, as they should no longer be read from. If you must use lazy
I/O in a program, it is often best to "firewall" it like this, so that
it cannot cause problems in unexpected parts of your code.</p>
<div class="TIP">
<p>Processing chunks via a fold</p>
<p>We can adapt the fold-with-early-termination technique from <a
href="9-a-library-for-searching-the-file-system.org::*Another way of looking at traversal">the
section called "Another way of looking at traversal"</a> stream-based
file processing. While this requires more work than the lazy I/O
approach, it nicely avoids the above problems.</p>
</div></li>
</ol>
<h2 data-number="11.6"
id="efficiently-finding-line-aligned-chunks"><span
class="header-section-number">11.6</span> Efficiently finding
line-aligned chunks</h2>
<p>Since a server log file is line-oriented, we need an efficient way to
break a file into large chunks, while making sure that each chunk ends
on a line boundary. Since a chunk might be tens of megabytes in size, we
don't want to scan all of the data in a chunk to determine where its
final boundary should be.</p>
<p>Our approach works whether we choose a fixed chunk size or a fixed
number of chunks. Here, we opt for the latter. We begin by seeking to
the approximate position of the end of a chunk, then scan forwards until
we reach a newline character. We then start the next chunk after the
newline, and repeat the procedure.</p>
<div class="captioned-content">
<div class="caption">
LineChunks.hs
</div>
<div class="sourceCode" id="cb60"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="ot">lineChunks ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FilePath</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> [<span class="dt">ChunkSpec</span>]</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>lineChunks numChunks path <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>  bracket (openFile path <span class="dt">ReadMode</span>) hClose <span class="op">$</span> \h <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>    totalSize <span class="ot">&lt;-</span> <span class="fu">fromIntegral</span> <span class="ot">`liftM`</span> hFileSize h</span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> chunkSize <span class="ot">=</span> totalSize <span class="ot">`div`</span> <span class="fu">fromIntegral</span> numChunks</span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a>        findChunks offset <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> newOffset <span class="ot">=</span> offset <span class="op">+</span> chunkSize</span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a>          hSeek h <span class="dt">AbsoluteSeek</span> (<span class="fu">fromIntegral</span> newOffset)</span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a>          <span class="kw">let</span> findNewline off <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a>                eof <span class="ot">&lt;-</span> hIsEOF h</span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a>                <span class="kw">if</span> eof</span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">then</span> <span class="fu">return</span> [<span class="dt">CS</span> offset (totalSize <span class="op">-</span> offset)]</span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a>                  <span class="kw">else</span> <span class="kw">do</span></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a>                    bytes <span class="ot">&lt;-</span> LB.hGet h <span class="dv">4096</span></span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a>                    <span class="kw">case</span> LB.elemIndex <span class="ch">&#39;\n&#39;</span> bytes <span class="kw">of</span></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Just</span> n <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>                        chunks<span class="op">@</span>(c<span class="op">:</span>_) <span class="ot">&lt;-</span> findChunks (off <span class="op">+</span> n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>                        <span class="kw">let</span> coff <span class="ot">=</span> chunkOffset c</span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">return</span> (<span class="dt">CS</span> offset (coff <span class="op">-</span> offset)<span class="op">:</span>chunks)</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>                      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> findNewline (off <span class="op">+</span> LB.length bytes)</span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a>          findNewline newOffset</span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>    findChunks <span class="dv">0</span></span></code></pre></div>
</div>
<p>The last chunk will end up a little shorter than its predecessors,
but this difference will be insignificant in practice.</p>
<h2 data-number="11.7" id="counting-lines"><span
class="header-section-number">11.7</span> Counting lines</h2>
<p>This simple example illustrates how to use the scaffolding we have
built.</p>
<div class="captioned-content">
<div class="caption">
LineCount.hs
</div>
<div class="sourceCode" id="cb61"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.Int</span> (<span class="dt">Int64</span>)</span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">LB</span></span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LineChunks</span> (chunkedReadWith)</span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MapReduce</span> (mapReduce, rnf)</span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a><span class="ot">lineCount ::</span> [<span class="dt">LB.ByteString</span>] <span class="ot">-&gt;</span> <span class="dt">Int64</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>lineCount <span class="ot">=</span> mapReduce rnf (LB.count <span class="ch">&#39;\n&#39;</span>)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a>                      rnf <span class="fu">sum</span></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-15"><a href="#cb61-15" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb61-16"><a href="#cb61-16" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb61-17"><a href="#cb61-17" aria-hidden="true" tabindex="-1"></a>  args <span class="ot">&lt;-</span> getArgs</span>
<span id="cb61-18"><a href="#cb61-18" aria-hidden="true" tabindex="-1"></a>  forM_ args <span class="op">$</span> \path <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb61-19"><a href="#cb61-19" aria-hidden="true" tabindex="-1"></a>    numLines <span class="ot">&lt;-</span> chunkedReadWith lineCount path</span>
<span id="cb61-20"><a href="#cb61-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">putStrLn</span> <span class="op">$</span> path <span class="op">++</span> <span class="st">&quot;: &quot;</span> <span class="op">++</span> <span class="fu">show</span> numLines</span></code></pre></div>
</div>
<p>If we compile this program with
<code>ghc -O2 --make -threaded</code>, it should perform well after an
initial run to "warm" the filesystem cache. On a dual core laptop,
processing a log file 248 megabytes (1.1 million lines) in size, this
program runs in 0.576 seconds using a single core, and 0.361 with two
(using <code>+RTS -N2</code>).</p>
<h2 data-number="11.8" id="finding-the-most-popular-urls"><span
class="header-section-number">11.8</span> Finding the most popular
URLs</h2>
<p>In this example, we count the number of times each URL is accessed.
This example comes from [<a
href="bibliography.org::Google08">Google08</a>], Google's original paper
discussing MapReduce. In the <em>map</em> phase, for each chunk, we
create a <code>Map</code> from URL to the number of times it was
accessed. In the <em>reduce</em> phase, we union-merge these maps into
one.</p>
<div class="captioned-content">
<div class="caption">
CommonURLs.hs
</div>
<div class="sourceCode" id="cb62"><pre
class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Parallel.Strategies</span> (<span class="dt">NFData</span>(..), rwhnf)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Control.Monad</span> (forM_)</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Data.List</span> (foldl&#39;, sortBy)</span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Lazy.Char8</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.ByteString.Char8</span> <span class="kw">as</span> <span class="dt">S</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Data.Map</span> <span class="kw">as</span> <span class="dt">M</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">Text.Regex.PCRE.Light</span> (compile, match)</span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">System.Environment</span> (getArgs)</span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">LineChunks</span> (chunkedReadWith)</span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="dt">MapReduce</span> (mapReduce)</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a><span class="ot">countURLs ::</span> [<span class="dt">L.ByteString</span>] <span class="ot">-&gt;</span> <span class="dt">M.Map</span> <span class="dt">S.ByteString</span> <span class="dt">Int</span></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>countURLs <span class="ot">=</span> mapReduce rwhnf (foldl&#39; augment M.empty <span class="op">.</span> L.lines)</span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>                      rwhnf (M.unionsWith (<span class="op">+</span>))</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">where</span> augment <span class="fu">map</span> line <span class="ot">=</span></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>            <span class="kw">case</span> match (compile <span class="kw">pattern</span> []) (strict line) [] <span class="kw">of</span></span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>              <span class="dt">Just</span> (_<span class="op">:</span>url<span class="op">:</span>_) <span class="ot">-&gt;</span> M.insertWith&#39; (<span class="op">+</span>) url <span class="dv">1</span> <span class="fu">map</span></span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>              _ <span class="ot">-&gt;</span> <span class="fu">map</span></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>        strict  <span class="ot">=</span> S.concat <span class="op">.</span> L.toChunks</span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>        <span class="kw">pattern</span> <span class="ot">=</span> S.pack <span class="st">&quot;\&quot;(?:GET|POST|HEAD) ([^ ]+) HTTP/&quot;</span></span></code></pre></div>
</div>
<p>To pick a URL out of a line of the log file, we use the bindings to
the PCRE regular expression library that we developed in <a
href="17-interfacing-with-c.org">Chapter 17, <em>Interfacing with C: the
FFI</em></a>.</p>
<p>Our driver function prints the ten most popular URLs. As with the
line counting example, this program runs about 1.8 times faster with two
cores than with one, taking 1.7 seconds to process the a log file
containing 1.1 million entries.</p>
<h2 data-number="11.9" id="conclusions"><span
class="header-section-number">11.9</span> Conclusions</h2>
<p>Given a problem that fits its model well, the MapReduce programming
model lets us write "casual" parallel programs in Haskell with good
performance, and minimal additional effort. We can easily extend the
idea to use other data sources, such as collections of files, or data
sourced over the network.</p>
<p>In many cases, the performance bottleneck will be streaming data at a
rate high enough to keep up with a core's processing capacity. For
instance, if we try to use either of the above sample programs on a file
that is not cached in memory or streamed from a high-bandwidth storage
array, we will spend most of our time waiting for disk I/O, gaining no
benefit from multiple cores.</p>
<h1 data-number="12" id="footnotes"><span
class="header-section-number">12</span> Footnotes</h1>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>As we will show later, GHC threads
are extraordinarily lightweight. If the runtime were to provide a way to
check the status of every thread, the overhead of every thread would
increase, even if this information were never used.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>The non-threaded runtime does not
understand this option, and will reject it with an error message.<a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>As we write this book, the garbage
collector is being retooled to use multiple cores, but we cannot yet
predict its future effect.<a href="#fnref3" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>The genesis of this idea comes from
Tim Bray.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
